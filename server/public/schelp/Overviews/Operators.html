<html><head><title>Operators</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider OVERVIEWS</div>
<div id='categories'><a href='./../Browse.html#Language'>Language</a>, <a href='./../Browse.html#Common methods'>Common methods</a></div>
<h1>Operators</h1>
<div id='summary'>common unary and binary operators</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../Reference/Adverbs.html">Adverbs for Binary Operators</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#Unary Operators'>Unary Operators</a></li>
<ul class='toc'><li class='toc2'><a href='#Arithmetics'>Arithmetics</a></li>
<ul class='toc'><li class='toc3'><a href='#.neg'>neg</a> </li>
<li class='toc3'><a href='#.reciprocal'>reciprocal</a> </li>
<li class='toc3'><a href='#.abs'>abs</a> </li>
<li class='toc3'><a href='#.floor'>floor</a> </li>
<li class='toc3'><a href='#.ceil'>ceil</a> </li>
<li class='toc3'><a href='#.frac'>frac</a> </li>
<li class='toc3'><a href='#.sign'>sign</a> </li>
<li class='toc3'><a href='#.squared'>squared</a> </li>
<li class='toc3'><a href='#.cubed'>cubed</a> </li>
<li class='toc3'><a href='#.sqrt'>sqrt</a> </li>
<li class='toc3'><a href='#.exp'>exp</a> </li>
</ul><li class='toc2'><a href='#Musical acoustics'>Musical acoustics</a></li>
<ul class='toc'><li class='toc3'><a href='#.midicps'>midicps</a> </li>
<li class='toc3'><a href='#.cpsmidi'>cpsmidi</a> </li>
<li class='toc3'><a href='#.midiratio'>midiratio</a> </li>
<li class='toc3'><a href='#.ratiomidi'>ratiomidi</a> </li>
<li class='toc3'><a href='#.dbamp'>dbamp</a> </li>
<li class='toc3'><a href='#.ampdb'>ampdb</a> </li>
<li class='toc3'><a href='#.octcps'>octcps</a> </li>
<li class='toc3'><a href='#.cpsoct'>cpsoct</a> </li>
</ul><li class='toc2'><a href='#Random operators'>Random operators</a></li>
<ul class='toc'><li class='toc3'><a href='#.rand'>rand</a> </li>
<li class='toc3'><a href='#.rand2'>rand2</a> </li>
<li class='toc3'><a href='#.linrand'>linrand</a> </li>
<li class='toc3'><a href='#.bilinrand'>bilinrand</a> </li>
<li class='toc3'><a href='#.sum3rand'>sum3rand</a> </li>
<li class='toc3'><a href='#.coin'>coin</a> </li>
</ul><li class='toc2'><a href='#Other'>Other</a></li>
<ul class='toc'><li class='toc3'><a href='#.log'>log</a> </li>
<li class='toc3'><a href='#.log2'>log2</a> </li>
<li class='toc3'><a href='#.log10'>log10</a> </li>
<li class='toc3'><a href='#.sin'>sin</a> </li>
<li class='toc3'><a href='#.cos'>cos</a> </li>
<li class='toc3'><a href='#.tan'>tan</a> </li>
<li class='toc3'><a href='#.asin'>asin</a> </li>
<li class='toc3'><a href='#.acos'>acos</a> </li>
<li class='toc3'><a href='#.atan'>atan</a> </li>
<li class='toc3'><a href='#.sinh'>sinh</a> </li>
<li class='toc3'><a href='#.cosh'>cosh</a> </li>
<li class='toc3'><a href='#.tanh'>tanh</a> </li>
<li class='toc3'><a href='#.distort'>distort</a> </li>
<li class='toc3'><a href='#.softclip'>softclip</a> </li>
<li class='toc3'><a href='#.isPositive'>isPositive</a> </li>
<li class='toc3'><a href='#.isNegative'>isNegative</a> </li>
<li class='toc3'><a href='#.isStrictlyPositive'>isStrictlyPositive</a> </li>
</ul></ul><li class='toc1'><a href='#Binary Operators'>Binary Operators</a></li>
<ul class='toc'><li class='toc2'><a href='#Arithmetics'>Arithmetics</a></li>
<ul class='toc'><li class='toc3'><a href='#.+'>+</a> </li>
<li class='toc3'><a href='#.-'>-</a> </li>
<li class='toc3'><a href='#.*'>*</a> </li>
<li class='toc3'><a href='#./'>/</a> </li>
<li class='toc3'><a href='#.%'>%</a> </li>
<li class='toc3'><a href='#.**'>**</a> </li>
<li class='toc3'><a href='#.pow'>pow</a> </li>
<li class='toc3'><a href='#.lcm'>lcm</a> </li>
<li class='toc3'><a href='#.gcd'>gcd</a> </li>
</ul><li class='toc2'><a href='#Comparisions'>Comparisions</a></li>
<ul class='toc'><li class='toc3'><a href='#.<'>&lt;</a> </li>
<li class='toc3'><a href='#.<='>&lt;=</a> </li>
<li class='toc3'><a href='#.>'>&gt;</a> </li>
<li class='toc3'><a href='#.>='>&gt;=</a> </li>
<li class='toc3'><a href='#.=='>==</a> </li>
<li class='toc3'><a href='#.!='>!=</a> </li>
</ul><li class='toc2'><a href='#Other'>Other</a></li>
<ul class='toc'><li class='toc3'><a href='#.<!'>&lt;!</a> </li>
<li class='toc3'><a href='#.min'>min</a> </li>
<li class='toc3'><a href='#.max'>max</a> </li>
<li class='toc3'><a href='#.round'>round</a> </li>
<li class='toc3'><a href='#.trunc'>trunc</a> </li>
<li class='toc3'><a href='#.hypot'>hypot</a> </li>
<li class='toc3'><a href='#.hypotApx'>hypotApx</a> </li>
<li class='toc3'><a href='#.atan2'>atan2</a> </li>
<li class='toc3'><a href='#.ring1'>ring1</a> </li>
<li class='toc3'><a href='#.ring2'>ring2</a> </li>
<li class='toc3'><a href='#.ring3'>ring3</a> </li>
<li class='toc3'><a href='#.ring4'>ring4</a> </li>
<li class='toc3'><a href='#.sumsqr'>sumsqr</a> </li>
<li class='toc3'><a href='#.difsqr'>difsqr</a> </li>
<li class='toc3'><a href='#.sqrsum'>sqrsum</a> </li>
<li class='toc3'><a href='#.sqrdif'>sqrdif</a> </li>
<li class='toc3'><a href='#.absdif'>absdif</a> </li>
<li class='toc3'><a href='#.moddif'>moddif</a> </li>
<li class='toc3'><a href='#.thresh'>thresh</a> </li>
<li class='toc3'><a href='#.amclip'>amclip</a> </li>
<li class='toc3'><a href='#.scaleneg'>scaleneg</a> </li>
<li class='toc3'><a href='#.clip2'>clip2</a> </li>
<li class='toc3'><a href='#.wrap2'>wrap2</a> </li>
<li class='toc3'><a href='#.fold2'>fold2</a> </li>
<li class='toc3'><a href='#.excess'>excess</a> </li>
</ul></ul></ul></div>
<p>SuperCollider supports operator overloading. Operators can thus be applied to a variety of different objects; Numbers, Ugens, Collections, and so on. When operators are applied to ugens they result in <a href="./../Classes/BinaryOpUGen.html">BinaryOpUGen</a>s or <a href="./../Classes/UnaryOpUGen.html">UnaryOpUGen</a>s, through the methods of <a href="./../Classes/AbstractFunction.html">AbstractFunction</a>.
<p>This is a list of some of the common unary and binary operators that are implemented by several classes. See the specific classes for details and other operators.
<p>You can see which classes implements a specific operator by clicking on the method name.<h2><a class='anchor' name='Unary Operators'>Unary Operators</a></h2>

<p>Unary operators may be written in two ways:<pre class='code prettyprint lang-sc'>a.operator
operator(a)</pre>
<h3><a class='anchor' name='Arithmetics'>Arithmetics</a></h3>
<h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.neg' href='./../Overviews/Methods.html#neg'>neg</a> </h3>
<div class='method'>
<p>Inversion.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{
    var a;
    a = FSinOsc.ar(300);
    [ a, a.neg ]
}.plot</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.reciprocal' href='./../Overviews/Methods.html#reciprocal'>reciprocal</a> </h3>
<div class='method'>
<p>Reciprocal (1/x).</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.abs' href='./../Overviews/Methods.html#abs'>abs</a> </h3>
<div class='method'>
<p>Absolute value.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.floor' href='./../Overviews/Methods.html#floor'>floor</a> </h3>
<div class='method'>
<p>Next lower integer.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{
    var a;
    a = Line.ar(-1, 1, 0.01);
    [ a, a.floor ]
}.plot</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.ceil' href='./../Overviews/Methods.html#ceil'>ceil</a> </h3>
<div class='method'>
<p>Next higher integer.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{
    var a;
    a = Line.ar(-1, 1, 0.01);
    [ a, a.ceil ]
}.plot</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.frac' href='./../Overviews/Methods.html#frac'>frac</a> </h3>
<div class='method'>
<p>Fractional part.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sign' href='./../Overviews/Methods.html#sign'>sign</a> </h3>
<div class='method'>
<p>Sign function.<h4>Returns:</h4>
<div class='returnvalue'>
<p>-1 when a &lt; 0, +1 when a &gt; 0, 0 when a is 0</div></div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.squared' href='./../Overviews/Methods.html#squared'>squared</a> </h3>
<div class='method'>
<p>Squared value.<h4>Returns:</h4>
<div class='returnvalue'>
<p><code class='code prettyprint lang-sc'>a*a</code></div></div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.cubed' href='./../Overviews/Methods.html#cubed'>cubed</a> </h3>
<div class='method'>
<p>Cubed value.<h4>Returns:</h4>
<div class='returnvalue'>
<p><code class='code prettyprint lang-sc'>a*a*a</code></div></div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sqrt' href='./../Overviews/Methods.html#sqrt'>sqrt</a> </h3>
<div class='method'>
<p>Square root.<h4>Discussion:</h4>

<p>The definition of square root is extended for signals so that sqrt(a) when a&lt;0 returns -sqrt(-a).</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.exp' href='./../Overviews/Methods.html#exp'>exp</a> </h3>
<div class='method'>
<p>Exponential.</div><h3><a class='anchor' name='Musical acoustics'>Musical acoustics</a></h3>
<h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.midicps' href='./../Overviews/Methods.html#midicps'>midicps</a> </h3>
<div class='method'>
<p>Convert MIDI note number to cycles per second.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{
    Saw.ar(Line.kr(24,108,10).midicps, 0.2)
}.play</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.cpsmidi' href='./../Overviews/Methods.html#cpsmidi'>cpsmidi</a> </h3>
<div class='method'>
<p>Convert cycles per second to MIDI note.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.midiratio' href='./../Overviews/Methods.html#midiratio'>midiratio</a> </h3>
<div class='method'>
<p>Convert an interval in MIDI notes into a frequency ratio.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.ratiomidi' href='./../Overviews/Methods.html#ratiomidi'>ratiomidi</a> </h3>
<div class='method'>
<p>Convert a frequency ratio to an interval in MIDI notes.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.dbamp' href='./../Overviews/Methods.html#dbamp'>dbamp</a> </h3>
<div class='method'>
<p>Convert decibels to linear amplitude.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.ampdb' href='./../Overviews/Methods.html#ampdb'>ampdb</a> </h3>
<div class='method'>
<p>Convert linear amplitude to decibels.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.octcps' href='./../Overviews/Methods.html#octcps'>octcps</a> </h3>
<div class='method'>
<p>Convert decimal octaves to cycles per second.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.cpsoct' href='./../Overviews/Methods.html#cpsoct'>cpsoct</a> </h3>
<div class='method'>
<p>Convert cycles per second to decimal octaves.</div><h3><a class='anchor' name='Random operators'>Random operators</a></h3>

<p>See also <a href="./../Guides/Randomness.html">Randomness</a><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.rand' href='./../Overviews/Methods.html#rand'>rand</a> </h3>
<div class='method'>
<p>Returns an evenly distributed random value between this and zero.<pre class='code prettyprint lang-sc'>10.rand;

{ SinOsc.ar(110).rand }.plot;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.rand2' href='./../Overviews/Methods.html#rand2'>rand2</a> </h3>
<div class='method'>
<p>Returns an evenly distributed random value between [+this ... - this].<pre class='code prettyprint lang-sc'>10.rand2;

{ SinOsc.ar(110).rand2 }.plot;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.linrand' href='./../Overviews/Methods.html#linrand'>linrand</a> </h3>
<div class='method'>
<p>Returns a linearly distributed random value between this and zero.<pre class='code prettyprint lang-sc'>10.linrand;

{ SinOsc.ar(110).linrand }.plot;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.bilinrand' href='./../Overviews/Methods.html#bilinrand'>bilinrand</a> </h3>
<div class='method'>
<p>Returns a linearly distributed random value between [+this ... - this].<pre class='code prettyprint lang-sc'>10.bilinrand;

{ SinOsc.ar(110).bilinrand }.plot;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sum3rand' href='./../Overviews/Methods.html#sum3rand'>sum3rand</a> </h3>
<div class='method'>
<p>Returns a value from a gaussian-like random distribution between this and zero. Larry Polansky's poor man's gaussian generator, follows the formula:<pre class='code prettyprint lang-sc'>{ 1.0.rand }.dup(3).sum - 1.5 * (2/3)</pre>
<pre class='code prettyprint lang-sc'>10.sum3rand;

{ SinOsc.ar(110).sum3rand }.plot;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.coin' href='./../Overviews/Methods.html#coin'>coin</a> </h3>
<div class='method'>
<p>Returns one or zero with the probability given by the argument.<pre class='code prettyprint lang-sc'>0.4.coin;

{ SinOsc.ar(110).coin }.plot;</pre>
</div><h3><a class='anchor' name='Other'>Other</a></h3>
<h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.log' href='./../Overviews/Methods.html#log'>log</a> </h3>
<div class='method'>
<p>Natural logarithm.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{
    var a, e;
    e = exp(1);
    a = Line.ar(e, 1/e, 0.01);
    a.log
}.plot</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.log2' href='./../Overviews/Methods.html#log2'>log2</a> </h3>
<div class='method'>
<p>Base 2 logarithm.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.log10' href='./../Overviews/Methods.html#log10'>log10</a> </h3>
<div class='method'>
<p>Base 10 logarithm.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sin' href='./../Overviews/Methods.html#sin'>sin</a> </h3>
<div class='method'>
<p>Sine.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.cos' href='./../Overviews/Methods.html#cos'>cos</a> </h3>
<div class='method'>
<p>Cosine.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.tan' href='./../Overviews/Methods.html#tan'>tan</a> </h3>
<div class='method'>
<p>Tangent.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.asin' href='./../Overviews/Methods.html#asin'>asin</a> </h3>
<div class='method'>
<p>Arcsine.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.acos' href='./../Overviews/Methods.html#acos'>acos</a> </h3>
<div class='method'>
<p>Arccosine.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.atan' href='./../Overviews/Methods.html#atan'>atan</a> </h3>
<div class='method'>
<p>Arctangent.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sinh' href='./../Overviews/Methods.html#sinh'>sinh</a> </h3>
<div class='method'>
<p>Hyperbolic sine.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.cosh' href='./../Overviews/Methods.html#cosh'>cosh</a> </h3>
<div class='method'>
<p>Hyperbolic cosine.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.tanh' href='./../Overviews/Methods.html#tanh'>tanh</a> </h3>
<div class='method'>
<p>Hyperbolic tangent.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.distort' href='./../Overviews/Methods.html#distort'>distort</a> </h3>
<div class='method'>
<p>Nonlinear distortion.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>(
{
    var a;
    a = Line.ar(-4, 4, 0.01);
    a.distort
}.plot
)

{ FSinOsc.ar(500, 0.0, XLine.kr(0.1, 10, 10)).distort * 0.25 }.scope;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.softclip' href='./../Overviews/Methods.html#softclip'>softclip</a> </h3>
<div class='method'>
<p>Nonlinear distortion.<h4>Discussion:</h4>

<p>Distortion with a perfectly linear region from -0.5 to +0.5<pre class='code prettyprint lang-sc'>(
{
    var a;
    a = Line.ar(-2, 2, 0.01);
    a.softclip
}.plot
)


{ FSinOsc.ar(500,0.0, XLine.kr(0.1, 10, 10)).softclip * 0.25 }.scope(2);</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.isPositive' href='./../Overviews/Methods.html#isPositive'>isPositive</a> </h3>
<div class='method'>
<p>Test if signal is &gt;= 0.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.isNegative' href='./../Overviews/Methods.html#isNegative'>isNegative</a> </h3>
<div class='method'>
<p>Test if signal is &lt; 0.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.isStrictlyPositive' href='./../Overviews/Methods.html#isStrictlyPositive'>isStrictlyPositive</a> </h3>
<div class='method'>
<p>Test if signal is &gt; 0.</div><h2><a class='anchor' name='Binary Operators'>Binary Operators</a></h2>

<p>Three different syntaxes can be used for binary operators consisting of letters:<pre class='code prettyprint lang-sc'>operator(a, b)

a operator: b

a.operator(b)</pre>

<p>Operators consisting of symbols are written like this:<pre class='code prettyprint lang-sc'>a + b</pre>
<h3><a class='anchor' name='Arithmetics'>Arithmetics</a></h3>
<h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.+' href='./../Overviews/Methods.html#+'>+</a> </h3>
<div class='method'>
<p>Addition.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.-' href='./../Overviews/Methods.html#-'>-</a> </h3>
<div class='method'>
<p>Subtraction.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.*' href='./../Overviews/Methods.html#*'>*</a> </h3>
<div class='method'>
<p>Multiplication.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='./' href='./../Overviews/Methods.html#/'>/</a> </h3>
<div class='method'>
<p>Division.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.%' href='./../Overviews/Methods.html#%'>%</a> </h3>
<div class='method'>
<p>Floating point modulo.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.**' href='./../Overviews/Methods.html#**'>**</a> </h3>
<div class='method'>
<p>Exponentiation. When used with UGens which produce a negative signal this function extends the usual definition of exponentiation and returns <code class='code prettyprint lang-sc'>neg(neg(a) ** b)</code>. This allows exponentiation of negative signal values by noninteger exponents. For the normal behaviour use pow (see below).</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.pow' href='./../Overviews/Methods.html#pow'>pow</a> </h3>
<div class='method'>
<p>Exponentiation.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.lcm' href='./../Overviews/Methods.html#lcm'>lcm</a> </h3>
<div class='method'>
<p>Least common multiple. This definition extends the usual definition and returns a negative number if <strong>any of the operands</strong> is negative. This makes it consistent with the lattice-theoretical interpretation and its idempotency, commutative, associative, absorption laws.
<p>Following the example of the programming language J (see: <a href="./../Guides/J-concepts-in-SC.html">J concepts in SC</a>), lcm is analogous to logical <strong>and</strong> (see also: <a href="http://www.jsoftware.com/papers/eem/gcd.htm">http://www.jsoftware.com/papers/eem/gcd.htm</a>).<pre class='code prettyprint lang-sc'>lcm(4, 6);
lcm(1, 1); // and
lcm(1624, 26);
lcm(1624, -26);
lcm(-1624, -26);
lcm(513, gcd(513, 44)) // absorption law -&gt; 513.</pre>

<p><pre class='code prettyprint lang-sc'>(
{
    var mx = MouseX.kr(-20, 20);
    var my = MouseY.kr(-20, 20);
    SinOsc.ar(SinOsc.kr(0.3) * 20 lcm: [mx, my] * 30 + 500) * 0.1
}.play;
)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.gcd' href='./../Overviews/Methods.html#gcd'>gcd</a> </h3>
<div class='method'>
<p>Greatest common divisor. This definition extends the usual definition and returns a negative number if <strong>both operands</strong> are negative. This makes it consistent with the lattice-theoretical interpretation and its idempotency, commutative, associative, absorption laws.
<p>"greater" means "divisible by" in this interpretation, so <code class='code prettyprint lang-sc'>gcd(-1, -1)</code> returns a negative number. This is necessary to make the whole system consistent (fundamental law of arithmetics, idempotency and absorption laws would fail).
<p>Following the example of the programming language J (see: <a href="./../Guides/J-concepts-in-SC.html">J concepts in SC</a>), gcd is analogous to logical <strong>or</strong> (see also: <a href="http://www.jsoftware.com/papers/eem/gcd.htm">http://www.jsoftware.com/papers/eem/gcd.htm</a>).<pre class='code prettyprint lang-sc'>gcd(4, 6);
gcd(0, 1); // or
gcd(1024, 256);
gcd(1024, -256);
gcd(-1024, -256); // "greater" means "divisible by" in this case, so this returns a negative number.
gcd(-1024, lcm(-1024, 256)) // absorption law -&gt; -1024.
gcd(66, 54) * lcm(66, 54) == (66 * 54); // true</pre>
<pre class='code prettyprint lang-sc'>(
{
    var mx = MouseX.kr(-200, 200);
    var my = MouseY.kr(-200, 200);
    SinOsc.ar(SinOsc.kr(0.3) * 20 gcd: [mx, my] * 30 + 500) * 0.1
}.play;
)</pre>
</div><h3><a class='anchor' name='Comparisions'>Comparisions</a></h3>
<h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.<' href='./../Overviews/Methods.html#&lt;'>&lt;</a> </h3>
<div class='method'>
<p>Less than.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.<=' href='./../Overviews/Methods.html#&lt;='>&lt;=</a> </h3>
<div class='method'>
<p>Less than or equal.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.>' href='./../Overviews/Methods.html#&gt;'>&gt;</a> </h3>
<div class='method'>
<p>Greater than.<h4>Discussion:</h4>

<p>With UGens, this can be useful for triggering purposes, among other things:<pre class='code prettyprint lang-sc'>(
{ // trigger an envelope
    var trig;
    trig = SinOsc.ar(1) &gt; 0;
    Out.ar(0,
        EnvGen.kr(Env.perc, trig, doneAction: 0)
            * SinOsc.ar(440,0,0.1)
    )
}.play
)

// trigger a synth
(
SynthDef("help-EnvGen",{ arg out=0;
    Out.ar(out,
        EnvGen.kr(Env.perc,1.0,doneAction: 2)
            * SinOsc.ar(440,0,0.1)
    )
}).add;

// This synth has no output. It only checks amplitude of input and looks for a transition from &lt; 0.2
// to &gt; 0.2

{ SendTrig.kr(Amplitude.kr(SoundIn.ar(0)) &gt; 0.2) }.play;

// OSCFunc to trigger synth
OSCFunc({ "triggered".postln; Synth.new("help-EnvGen") },'/tr', s.addr);
)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.>=' href='./../Overviews/Methods.html#&gt;='>&gt;=</a> </h3>
<div class='method'>
<p>Greater than or equal.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.==' href='./../Overviews/Methods.html#=='>==</a> </h3>
<div class='method'>
<p>Equal.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.!=' href='./../Overviews/Methods.html#!='>!=</a> </h3>
<div class='method'>
<p>Not equal.</div><h3><a class='anchor' name='Other'>Other</a></h3>
<h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.<!' href='./../Overviews/Methods.html#&lt;!'>&lt;!</a> </h3>
<div class='method'>
<p>Return first argument.<pre class='code prettyprint lang-sc'>// this is useful when two ugens need to be called, but only one of their outputs is needed
(
{
    var a, b, c;
    a = Dseq([1, 2, 3, 4], inf).dpoll("a");
    b = Dseq([1955, 1952, 1823, 1452], inf).dpoll("b");
    c = (a &lt;! b).dpoll("------&gt; a &lt;! b = "); // c only
    Duty.kr(0.4, 0, c);
    0.0
}.play
)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.min' href='./../Overviews/Methods.html#min'>min</a> </h3>
<div class='method'>
<p>Minimum.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{ // distorts and envelopes z
var z;
z = FSinOsc.ar(500);
z min: FSinOsc.ar(0.1);
}.play;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.max' href='./../Overviews/Methods.html#max'>max</a> </h3>
<div class='method'>
<p>Maximum.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{ // modulates and envelopes z
var z;
z = FSinOsc.ar(500);
z max: FSinOsc.ar(0.1);
}.play;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.round' href='./../Overviews/Methods.html#round'>round</a> </h3>
<div class='method'>
<p>Quantization by rounding. Rounds a to the nearest multiple of b.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.trunc' href='./../Overviews/Methods.html#trunc'>trunc</a> </h3>
<div class='method'>
<p>Quantization by truncation. Truncate a to a multiple of b.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.hypot' href='./../Overviews/Methods.html#hypot'>hypot</a> </h3>
<div class='method'>
<p>Hypotenuse. Returns the square root of the sum of the squares of a and b. Or equivalently, the distance from the origin to the point (x, y).<h4>Discussion:</h4>

<p>In this example, hypot is used to calculate a doppler shift pitch and amplitude based on distance.<pre class='code prettyprint lang-sc'>(
{
    var x, y, distance, velocity, pitchRatio, amplitude;
    // object travels 200 meters in 6 secs (=120kph) passing 10 meters
    // from the listener
    x = 10;
    y = LFSaw.kr(1/6, 0, 100);
    distance = hypot(x, y);
    velocity = Slope.kr(distance);
    pitchRatio = (344 - velocity) / 344;  // speed of sound is 344 meters/sec
    amplitude = 10 / distance.squared;
    FSinOsc.ar(1000 * pitchRatio, 0, amplitude)
}.play)</pre>

<p>The next example uses the distance to modulate a delay line.<pre class='code prettyprint lang-sc'>(
{
    var x, y, distance, velocity, pitchRatio, amplitude, motorSound;
    // object travels 200 meters in 6 secs (=120kph) passing 10 meters
    // from the listener
    x = 10;
    y = LFSaw.kr(1/6, 0, 100);
    distance = hypot(x, y);
    amplitude = 40 / distance.squared;
    motorSound = RLPF.ar(FSinOsc.ar(200, 0, LFPulse.ar(31.3, 0, 0.4)), 400, 0.3);
    DelayL.ar(motorSound, 110/344, distance/344, amplitude)
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.hypotApx' href='./../Overviews/Methods.html#hypotApx'>hypotApx</a> </h3>
<div class='method'>
<p>Hypotenuse approximation. Returns an approximation of the square root of the sum of the squares of x and y.<h4>Discussion:</h4>

<p>The formula used is :<pre class='code prettyprint lang-sc'>abs(x) + abs(y) - ((sqrt(2) - 1) * min(abs(x), abs(y)))</pre>

<p>hypotApx is used to implement Complex method magnitudeApx. This should not be used for simulating a doppler shift because it is discontinuous. Use hypot.
<p>See also <a href="#.hypot">.hypot</a>, <a href="#.atan2">.atan2</a>.</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.atan2' href='./../Overviews/Methods.html#atan2'>atan2</a> </h3>
<div class='method'>
<p>Returns the arctangent of y/x.<h4>Discussion:</h4>

<p>OK, now we can add a pan to the <a href="#.hypot">.hypot</a> doppler examples by using atan2 to find the azimuth, or direction angle, of the sound source. Assume speakers at +/- 45 degrees and clip the direction to between those.<pre class='code prettyprint lang-sc'>(
{
    var x, y, distance, velocity, pitchRatio, amplitude, azimuth, panValue;
    // object travels 200 meters in 6 secs (=120kph) passing 10 meters
    // from the listener
    x = 10;
    y = LFSaw.kr(1/6, 0, 100);
    distance = hypot(x, y);
    velocity = Slope.kr(distance);
    pitchRatio = (344 - velocity) / 344;  // speed of sound is 344 meters/sec
    amplitude = 10 / distance.squared;
    azimuth = atan2(y, x); // azimuth in radians
    panValue = (azimuth / 0.5pi).clip2(1);
    Pan2.ar(FSinOsc.ar(1000 * pitchRatio), panValue, amplitude)
}.play)

(
{
    var x, y, distance, velocity, pitchRatio, amplitude, motorSound,
            azimuth, panValue;
    // object travels 200 meters in 6 secs (=120kph) passing 10 meters
    // from the listener
    x = 10;
    y = LFSaw.kr(1/6, 0, 100);
    distance = hypot(x, y);
    amplitude = 40 / distance.squared;
    motorSound = RLPF.ar(FSinOsc.ar(200, 0, LFPulse.ar(31.3, 0, 0.4)), 400, 0.3);
    azimuth = atan2(y, x); // azimuth in radians
    panValue = (azimuth / 0.5pi).clip2(1); // make a value for Pan2 from azimuth
    Pan2.ar(DelayL.ar(motorSound, 110/344, distance/344), panValue, amplitude)
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.ring1' href='./../Overviews/Methods.html#ring1'>ring1</a> </h3>
<div class='method'>
<p>Ring modulation plus first source.<h4>Discussion:</h4>

<p>Return the value of ((a*b) + a). This is more efficient than using separate unit generators for the multiply and add.
<p>See also <a href="#.*">.*</a>, <a href="#.ring1">.ring1</a>, <a href="#.ring2">.ring2</a>, <a href="#.ring3">.ring3</a>, <a href="#.ring4">.ring4</a>.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) ring1: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    ((a * b) + a) * 0.125
}.play)</pre>

<p>normal ring modulation:<pre class='code prettyprint lang-sc'>(
{
    var a, b;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    (a * b) * 0.125
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.ring2' href='./../Overviews/Methods.html#ring2'>ring2</a> </h3>
<div class='method'>
<p>Ring modulation plus both sources.<h4>Discussion:</h4>

<p>Return the value of ((a*b) + a + b). This is more efficient than using separate unit generators for the multiply and adds.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) ring2: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    ((a * b) + a + b) * 0.125
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.ring3' href='./../Overviews/Methods.html#ring3'>ring3</a> </h3>
<div class='method'>
<p>Ring modulation variant.<h4>Discussion:</h4>

<p>Return the value of (a*a *b). This is more efficient than using separate unit generators for each multiply.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) ring3: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    (a * a * b) * 0.125;
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.ring4' href='./../Overviews/Methods.html#ring4'>ring4</a> </h3>
<div class='method'>
<p>Ring modulation variant.<h4>Discussion:</h4>

<p>Return the value of ((a*a *b) - (a*b*b)). This is more efficient than using separate unit generators for each operation.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) ring4: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    ((a * a * b) - (a * b * b)) * 0.125
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sumsqr' href='./../Overviews/Methods.html#sumsqr'>sumsqr</a> </h3>
<div class='method'>
<p>Sum of squares.<h4>Discussion:</h4>

<p>Return the value of (a*a) + (b*b). This is more efficient than using separate unit generators for each operation.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) sumsqr: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    ((a * a) + (b * b)) * 0.125
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.difsqr' href='./../Overviews/Methods.html#difsqr'>difsqr</a> </h3>
<div class='method'>
<p>Difference of squares.<h4>Discussion:</h4>

<p>Return the value of (a*a) - (b*b). This is more efficient than using separate unit generators for each operation.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) difsqr: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    ((a * a) - (b * b)) * 0.125
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sqrsum' href='./../Overviews/Methods.html#sqrsum'>sqrsum</a> </h3>
<div class='method'>
<p>Square of the sum.<h4>Discussion:</h4>

<p>Return the value of (a + b)**2. This is more efficient than using separate unit generators for each operation.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) sqrsum: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b, c;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    c = a + b;
    (c * c) * 0.125
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.sqrdif' href='./../Overviews/Methods.html#sqrdif'>sqrdif</a> </h3>
<div class='method'>
<p>Square of the difference.<h4>Discussion:</h4>

<p>Return the value of (a - b)**2. This is more efficient than using separate unit generators for each operation.<pre class='code prettyprint lang-sc'>{ (FSinOsc.ar(800) sqrdif: FSinOsc.ar(XLine.kr(200,500,5))) * 0.125 }.play;</pre>

<p>same as :<pre class='code prettyprint lang-sc'>(
{
    var a, b, c;
    a = FSinOsc.ar(800);
    b = FSinOsc.ar(XLine.kr(200,500,5));
    c = a - b;
    (c * c) * 0.125
}.play)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.absdif' href='./../Overviews/Methods.html#absdif'>absdif</a> </h3>
<div class='method'>
<p>Absolute value of the difference. <code class='code prettyprint lang-sc'>abs(a - b)</code><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>(
{ // creates a rhythm
var mul = 0.2 absdif: FSinOsc.ar(2, 0, 0.5);
FSinOsc.ar(440, 0, mul);
}.play;
)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.moddif' href='./../Overviews/Methods.html#moddif'>moddif</a> </h3>
<div class='method'>
<p>On a circle, there are two distances between two points. This operator returns the smaller value of the two.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{ Line.ar(0, 4, 0.01).moddif(0) }.plot;
(
{
var mul = 0.2 moddif: FSinOsc.ar(2, 0, 0.5);
FSinOsc.ar(440, 0, mul);
}.play;
)</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.thresh' href='./../Overviews/Methods.html#thresh'>thresh</a> </h3>
<div class='method'>
<p>Thresholding.<h4>Discussion:</h4>

<p>0 when a &lt; b, otherwise a.<pre class='code prettyprint lang-sc'>{ LFNoise0.ar(50, 0.5) thresh: 0.45 }.play // a low-rent gate</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.amclip' href='./../Overviews/Methods.html#amclip'>amclip</a> </h3>
<div class='method'>
<p>Two quadrant multiply.<h4>Discussion:</h4>

<p>0 when b &lt;= 0,  a*b when b &gt; 0<pre class='code prettyprint lang-sc'>{ WhiteNoise.ar.amclip(FSinOsc.kr(1,0.2)) }.play; // makes a sine envelope</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.scaleneg' href='./../Overviews/Methods.html#scaleneg'>scaleneg</a> </h3>
<div class='method'>
<p>Scale negative part of input.<h4>Discussion:</h4>

<p>a*b when a &lt; 0, otherwise a.<pre class='code prettyprint lang-sc'>{ FSinOsc.ar(500).scaleneg(Line.ar(1,-1,4)) }.play;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.clip2' href='./../Overviews/Methods.html#clip2'>clip2</a> </h3>
<div class='method'>
<p>Bilateral clipping.<h4>Discussion:</h4>

<p>clips input wave a to +/- b<pre class='code prettyprint lang-sc'>(
{
    var a;
    a = Line.ar(-2, 2, 0.01);
    a.clip2
}.plot2
)

{ FSinOsc.ar(400).clip2(0.2) }.scope; // clipping distortion

{ FSinOsc.ar(1000).clip2(Line.kr(0,1,8)) }.scope;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.wrap2' href='./../Overviews/Methods.html#wrap2'>wrap2</a> </h3>
<div class='method'>
<p>Bilateral wrapping.<h4>Discussion:</h4>

<p>wraps input wave to +/- b<pre class='code prettyprint lang-sc'>(
{
    var a;
    a = Line.ar(-2, 2, 0.01);
    a.wrap2
}.plot
)

{ FSinOsc.ar(1000).wrap2(Line.kr(0,1.01,8)) }.scope;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.fold2' href='./../Overviews/Methods.html#fold2'>fold2</a> </h3>
<div class='method'>
<p>Bilateral folding.<h4>Discussion:</h4>

<p>folds input wave a to +/- b<pre class='code prettyprint lang-sc'>(
{
    var a;
    a = Line.ar(-2, 2, 0.01);
    a.fold2
}.plot
)


{ FSinOsc.ar(1000).fold2(Line.kr(0,1,8)) }.scope;</pre>
</div><h3 class='imethodname'><span class='methprefix'>&nbsp;</span><a name='.excess' href='./../Overviews/Methods.html#excess'>excess</a> </h3>
<div class='method'>
<p>Residual of clipping.<h4>Discussion:</h4>

<p>Returns the difference of the original signal and its clipped form: (a - clip2(a,b)).<pre class='code prettyprint lang-sc'>(
{
    var a;
    a = Line.ar(-2, 2, 0.01);
    a.excess
}.plot
)

{ FSinOsc.ar(1000).excess(Line.kr(0,1,8)) }.play;</pre>
</div><div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Overviews/Operators.schelp'>/usr/local/share/SuperCollider/HelpSource/Overviews/Operators.schelp</a><br>link::Overviews/Operators::<br>sc version: 3.8dev</div></div></body></html>
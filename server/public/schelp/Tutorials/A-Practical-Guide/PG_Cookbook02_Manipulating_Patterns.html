<html><head><title>Pattern Guide Cookbook 02: Manipulating Patterns</title>
<link rel='stylesheet' href='./../../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../../scdoc.js' type='text/javascript'></script>
<script src='./../../docmap.js' type='text/javascript'></script>
<script src='./../../prettify.js' type='text/javascript'></script>
<script src='./../../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./../..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider TUTORIALS/A-PRACTICAL-GUIDE</div>
<div id='categories'><a href='./../../Browse.html#Streams-Patterns-Events>A-Practical-Guide'>Streams-Patterns-Events>A-Practical-Guide</a></div>
<h1>Pattern Guide Cookbook 02: Manipulating Patterns</h1>
<div id='summary'>Manipulating pattern data</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook01_Basic_Sequencing.html">Pattern Guide Cookbook 01: Basic Sequencing</a>, <a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook03_External_Control.html">Pattern Guide Cookbook 03: External Control</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#Manipulating pattern data'>Manipulating pattern data</a></li>
<ul class='toc'><li class='toc2'><a href='#Merging (interleaving) independent streams'>Merging (interleaving) independent streams</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Reading an array forward or backward arbitrarily'>Reading an array forward or backward arbitrarily</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Changing Pbind value patterns on the fly'>Changing Pbind value patterns on the fly</a></li>
<ul class='toc'></ul></ul></ul></div><h2><a class='anchor' name='Manipulating pattern data'>Manipulating pattern data</a></h2>
<h3><a class='anchor' name='Merging (interleaving) independent streams'>Merging (interleaving) independent streams</a></h3>

<p>Suppose you wanted a pattern that generated pitches in a lower range 70% of the time, and a higher range the other 30%. For purely random patterns, this is simple because the pattern for each range has no memory (the next value does not depend on the previous value in any perceptible way). The random number generator patterns ( <a href="./../../Classes/Pwhite.html">Pwhite</a> ) return one element before yielding control back to the "selector" ( <a href="./../../Classes/Pwrand.html">Pwrand</a> ).<pre class='code prettyprint lang-sc'>    \degree, Pwrand([Pwhite(-7, 11, 1), Pwhite(7, 18, 1)], #[0.7, 0.3], inf)</pre>

<p>This does not work if the ranges need to keep their own integrity. For that, <a href="./../../Classes/Pnsym1.html">Pnsym1</a> is ideal. We create a dictionary with named patterns, each of which maintain their own streams. Then we choose randomly between their names, picking one value from whichever stream is chosen this cycle.
<p>This use of <a href="./../../Classes/Pseries.html">Pseries</a> is essentially a random walk among scale degrees. It has more linear continuity than the equal distribution generated by Pwhite. Even though the higher range interrupts from time to time, the continuity should still be audible.<pre class='code prettyprint lang-sc'>(
var    melodies = (
        lowMelody: Pseries(4, Prand(#[-2, -1, 1, 2], inf), inf).fold(-7, 11),
        highMelody: Pseries(14, Prand(#[-3, -2, 2, 3], inf), inf).fold(7, 18)
    );

p = Pbind(
    \degree, Pnsym1(Pwrand(#[lowMelody, highMelody], [0.7, 0.3], inf), melodies),
    \dur, Pwrand(#[0.25, 0.5], #[0.4, 0.6], inf)
).play;
)

p.stop;</pre>
<h3><a class='anchor' name='Reading an array forward or backward arbitrarily'>Reading an array forward or backward arbitrarily</a></h3>

<p>Here's an interesting one. We have an array of possible output values, and we want the pattern to move forward or backward through the array depending on some kind of user input.
<p>There is actually a pattern that handles this already, based on the standard programming concept of a (random) walk. In a random walk, there is an "observer" who is at a position within an array. The observer moves randomly by some number of steps forward or backward. In the SuperCollider pattern implementation, <a href="./../../Classes/Pwalk.html">Pwalk</a>, the steps don't have to be random. So here, we determine the step size from a slider.
<p>In general, GUI objects should not be used for data storage. The approach here is to save the step size into a variable, and then refer to that variable in the Pwalk pattern.<pre class='code prettyprint lang-sc'>(
var    pitches = (0..14),    // replace with other pitches you want
    move = 0,
    window, slider;

window = Window.new("Mouse Transport", Rect(5, 100, 500, 50));
slider = Slider.new(window, Rect(5, 5, 490, 20))
    .action_({ |view|
        move = (view.value * 4 - 2).round;
    })
    .value_(0.5);
window.front;

p = Pbind(
        // Pfunc is the direction to move through the array
        // it could be anything
        //   - could read from MIDI or HID and convert it into a step
        //   - could be a GUI control, as it is here
    \degree, Pwalk(pitches, Pfunc { move }, 1, 7),
    \dur, 0.25
).play;
)

p.stop;</pre>

<p><strong>Third-party extension alert</strong> : The <a href="./../../Classes/Pwalk.html">Pwalk</a> pattern shown here moves forward and backward in a preset array. To do the same thing with the results of a pattern, see Pscratch in the <strong>ddwPatterns</strong> quark. An especially fun use of Pscratch is to use it on an event pattern like Pbind, skipping around in a series of fully realized note events.<h3><a class='anchor' name='Changing Pbind value patterns on the fly'>Changing Pbind value patterns on the fly</a></h3>

<p>Patterns are converted into streams to generate values (or events). By design, there is no way to access the internal state of the stream. This means, for Pbind and similar patterns, the streams producing values for the event keys are invisible. So, it isn't possible to reach inside the stream and change them while the pattern is playing.
<p>What we can do instead is base the Pbind on <strong>pattern proxies</strong> -- objects that take the place of a pattern. The <a href="./../../Classes/PatternProxy.html">PatternProxy</a> is a single object that creates a single stream within Pbind, but it looks for its values to the pattern and stream contained inside the proxy. Changing the proxy's pattern replaces the stream, without having to touch the Pbind's closed box.
<p>In the first example, pattern proxies are held in environment variables, and they can be manipulated through those variables.<pre class='code prettyprint lang-sc'>(
~degree = PatternProxy(Pn(Pseries(0, 1, 8), inf));
~dur = PatternProxy(Pn(0.25, inf));

p = Pbind(
    \degree, ~degree,
    \dur, ~dur
).play;
)

~degree.source = (Pexprand(1, 8, inf) - 1).round;

~dur.source = Pwrand(#[0.25, 0.5, 0.75], #[0.5, 0.3, 0.2], inf);

p.stop;</pre>

<p>Another way is to use <a href="./../../Classes/Pdefn.html">Pdefn</a>, which is a global namespace of proxies for value patterns. (Because of the different requirements for handling values and event patterns, there are two namespaces: <a href="./../../Classes/Pdef.html">Pdef</a> for event patterns like Pbind, and Pdefn for value patterns such as <code class='code prettyprint lang-sc'>\degree</code> and <code class='code prettyprint lang-sc'>\dur</code> here.) Storage is all taken care of for you, no need for variables of your own.<pre class='code prettyprint lang-sc'>(
Pdefn(\degree, Pn(Pseries(0, 1, 8), inf));
Pdefn(\dur, Pn(0.25, inf));

p = Pbind(
    \degree, Pdefn(\degree),
    \dur, Pdefn(\dur)
).play;
)

Pdefn(\degree, (Pexprand(1, 8, inf) - 1).round);

Pdefn(\dur, Pwrand(#[0.25, 0.5, 0.75], #[0.5, 0.3, 0.2], inf));

p.stop;</pre>

<p><strong>Third-party extension alert</strong> : The <strong>ddwChucklib</strong> quark defines a third way of doing this, using object prototyping (based on Environments) to create objects that encapsulate all the information needed to perform a musical behavior. Patterns stored in the prototype's variables are automatically available as pattern proxies to the object's pattern, making it easier to create complex, malleable "processes" which can be replicated as separate objects that don't interfere with each other. It's a step toward object-oriented modeling of musical behaviors without requiring hardcoded classes that are specific to one piece or another.
<p>Previous: <a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook01_Basic_Sequencing.html">Pattern Guide Cookbook 01: Basic Sequencing</a>
<p>Next: <a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook03_External_Control.html">Pattern Guide Cookbook 03: External Control</a><div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Tutorials/A-Practical-Guide/PG_Cookbook02_Manipulating_Patterns.schelp'>/usr/local/share/SuperCollider/HelpSource/Tutorials/A-Practical-Guide/PG_Cookbook02_Manipulating_Patterns.schelp</a><br>link::Tutorials/A-Practical-Guide/PG_Cookbook02_Manipulating_Patterns::<br>sc version: 3.8dev</div></div></body></html>
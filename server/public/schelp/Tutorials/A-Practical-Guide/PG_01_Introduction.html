<html><head><title>Pattern Guide 01: Introduction</title>
<link rel='stylesheet' href='./../../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../../scdoc.js' type='text/javascript'></script>
<script src='./../../docmap.js' type='text/javascript'></script>
<script src='./../../prettify.js' type='text/javascript'></script>
<script src='./../../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./../..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider TUTORIALS/A-PRACTICAL-GUIDE</div>
<div id='categories'><a href='./../../Browse.html#Streams-Patterns-Events>A-Practical-Guide'>Streams-Patterns-Events>A-Practical-Guide</a></div>
<h1>Pattern Guide 01: Introduction</h1>
<div id='summary'>Fundamental concepts of patterns and streams</div>
</div>
<div class='subheader'>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#Introduction'>Introduction</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Contents'>Contents</a></li>
<ul class='toc'><li class='toc2'><a href='#Pattern Cookbook'>Pattern Cookbook</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Reference material'>Reference material</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#Why patterns?'>Why patterns?</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#Patterns versus Streams'>Patterns versus Streams</a></li>
<ul class='toc'></ul></ul></div>
<p>by H. James Harkins <a class='footnote anchor' name='footnote_org_1' href='#footnote_1'><sup>1</sup></a> <h2><a class='anchor' name='Introduction'>Introduction</a></h2>

<p>Patterns are one of the most powerful elements of the SuperCollider language, but in some ways they can be difficult to approach using only the class-oriented help files. These documents seek to bridge the gap, explaining the conceptual background behind patterns, describing the usage of specific Pattern classes, and proceeding into examples of practical musical tasks written as patterns.<h2><a class='anchor' name='Contents'>Contents</a></h2>
<dl>
<dt><a href="./../../Tutorials/A-Practical-Guide/PG_01_Introduction.html">Pattern Guide 01: Introduction</a><dd>Fundamental concepts of patterns and streams<dt><a href="./../../Tutorials/A-Practical-Guide/PG_02_Basic_Vocabulary.html">Pattern Guide 02: Basic Vocabulary</a><dd>Common patterns to generate streams of single values<dt><a href="./../../Tutorials/A-Practical-Guide/PG_03_What_Is_Pbind.html">Pattern Guide 03: What Is Pbind</a><dd>Pattern-based musical sequencing with Pbind and cousins<dt><a href="./../../Tutorials/A-Practical-Guide/PG_04_Words_to_Phrases.html">Pattern Guide 04: Words to Phrases</a><dd>Nesting patterns, arranging music in terms of phrases<dt><a href="./../../Tutorials/A-Practical-Guide/PG_05_Math_on_Patterns.html">Pattern Guide 05: Math on Patterns</a><dd>Performing math and collection operations on patterns<dt><a href="./../../Tutorials/A-Practical-Guide/PG_060_Filter_Patterns.html">Pattern Guide 060: Filter Patterns</a><dd>Overview of patterns that modify the behavior of other patterns<dt><a href="./../../Tutorials/A-Practical-Guide/PG_06a_Repetition_Contraint_Patterns.html">Pattern Guide 06a: Repetition Contraint Patterns</a><dd>Patterns that repeat values, or cut other patterns off early<dt><a href="./../../Tutorials/A-Practical-Guide/PG_06b_Time_Based_Patterns.html">Pattern Guide 06b: Time Based Patterns</a><dd>Patterns using time as the basis for their evaluation<dt><a href="./../../Tutorials/A-Practical-Guide/PG_06c_Composition_of_Patterns.html">Pattern Guide 06c: Composition of Patterns</a><dd>Making multiple event patterns act as one<dt><a href="./../../Tutorials/A-Practical-Guide/PG_06d_Parallel_Patterns.html">Pattern Guide 06d: Parallel Patterns</a><dd>Running multiple event patterns simultaneously<dt><a href="./../../Tutorials/A-Practical-Guide/PG_06e_Language_Control.html">Pattern Guide 06e: Language Control</a><dd>Patterns that mimic some language-side control structures<dt><a href="./../../Tutorials/A-Practical-Guide/PG_06f_Server_Control.html">Pattern Guide 06f: Server Control</a><dd>Patterns that manage server-side resources<dt><a href="./../../Tutorials/A-Practical-Guide/PG_06g_Data_Sharing.html">Pattern Guide 06g: Data Sharing</a><dd>Writing patterns to use information from other patterns<dt><a href="./../../Tutorials/A-Practical-Guide/PG_07_Value_Conversions.html">Pattern Guide 07: Value Conversions</a><dd>Describes the default event's conversions for pitch, rhythm and amplitude<dt><a href="./../../Tutorials/A-Practical-Guide/PG_08_Event_Types_and_Parameters.html">Pattern Guide 08: Event Types and Parameters</a><dd>Describes the event types defined in the default event, and the parameters they expect</dl>
<h3><a class='anchor' name='Pattern Cookbook'>Pattern Cookbook</a></h3>

<p>The pattern cookbook is a set of examples with explanations.<dl>
<dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook01_Basic_Sequencing.html">Pattern Guide Cookbook 01: Basic Sequencing</a><dd><ul>
<li>Playing a predefined note sequence<li>"Multichannel" expansion<li>Using custom SynthDefs (including unpitched SynthDefs)</ul>

<p><dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook02_Manipulating_Patterns.html">Pattern Guide Cookbook 02: Manipulating Patterns</a><dd><ul>
<li>Merging (interleaving) independent streams<li>Reading an array forward or backward arbitrarily<li>Changing Pbind value patterns on the fly</ul>

<p><dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook03_External_Control.html">Pattern Guide Cookbook 03: External Control</a><dd><ul>
<li>Control of parameters by MIDI or HID<li>Triggering patterns by external control</ul>

<p><dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook04_Sending_MIDI.html">Pattern Guide Cookbook 04: Sending MIDI</a><dd><ul>
<li>Sending notes under pattern control to MIDI devices</ul>

<p><dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook05_Using_Samples.html">Pattern Guide Cookbook 05: Using Samples</a><dd><ul>
<li>Playing a pattern in time with a sampled loop<li>Using audio samples to play pitched material</ul>

<p><dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook06_Phrase_Network.html">Pattern Guide Cookbook 06: Phrase Network</a><dd><ul>
<li>Building a more complicated melody using shorter phrase patterns<li>Also illustrates PmonoArtic for portamento with articulation</ul>

<p><dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook07_Rhythmic_Variations.html">Pattern Guide Cookbook 07: Rhythmic Variations</a><dd><ul>
<li>An ever-changing drumbeat</ul>

<p><dt><a href="./../../Tutorials/A-Practical-Guide/PG_Cookbook08_Swing.html">Pattern Guide Cookbook 08: Swing</a><dd><ul>
<li>Emulating quantize-with-swing from conventional sequencers</ul>
</dl>
<h3><a class='anchor' name='Reference material'>Reference material</a></h3>
<dl>
<dt><a href="./../../Tutorials/A-Practical-Guide/PG_Ref01_Pattern_Internals.html">Pattern Guide Reference 01: Pattern Internals</a><dd>Details of pattern implementation, with guidance on writing new pattern classes</dl>
<h2><a class='anchor' name='Why patterns?'>Why patterns?</a></h2>

<p>Patterns describe calculations without explicitly stating every step. They are a higher-level representation of a computational task. While patterns are not ideally suited for every type of calculation, when they are appropriate they free the user from worrying about every detail of the process. Using patterns, one writes <em>what</em> is supposed to happen, rather than <em>how</em> to accomplish it.
<p>In SuperCollider, patterns are best for tasks that need to produce sequences, or streams, of information. Often these are numbers, but they don't have to be -- patterns can generate any kind of object.
<p>For a simple example, let's count upward starting from 0. We don't know how high we will need to count; we just know that every time we ask for values, we should get a continually increasing series.
<p>Writing everything out, it looks like this. <a href="./../../Classes/Routine.html">Routine</a> is used because this is a control structure that can interrupt what it's doing and remember where it was, so that it can pick up again at exactly that point. You can get some numbers out of it, and call it again later and it will keep counting from the last number returned. (This is an example of a <a href="./../../Classes/Stream.html">Stream</a>. You can find more about Streams in <a href="./../../Tutorials/Streams-Patterns-Events1.html">Understanding Streams, Patterns and Events - Part 1</a>.)<pre class='code prettyprint lang-sc'>a = Routine {
    var    i = 0;
    loop {
        i.yield;
        i = i + 1;
    };
};

a.nextN(10);</pre>

<p>SuperCollider's built-in control structures allow some simplification.<pre class='code prettyprint lang-sc'>a = Routine {
    (0..).do { |i|
        i.yield;
    };
};

a.nextN(10);</pre>

<p>But wouldn't it be nice just to say, "Give me an infinite series of numbers starting with 0, increasing by 1"? With <a href="./../../Classes/Pseries.html">Pseries</a>, you can. (Here, keyword addressing of the arguments is used for clarity, but <code class='code prettyprint lang-sc'>start</code>, <code class='code prettyprint lang-sc'>step</code> and <code class='code prettyprint lang-sc'>length</code> can be omitted.)<pre class='code prettyprint lang-sc'>a = Pseries(start: 0, step: 1, length: inf).asStream;

a.nextN(10);</pre>

<p>What are the advantages of the pattern representation?<ul>
<li>It's shorter.<li>It's tested and it works. You don't have to debug how Pseries works (whereas, if you write a Routine, you might make a mistake and then have to find it.)<li>With the Routine -- especially if it's complicated -- you will have to decipher it when you come back to the code later. The Pattern states the purpose right there in the code.</ul>

<p>What are some disadvantages?<ul>
<li>Patterns are a new vocabulary to learn. Until you know a critical mass of them, it can be hard to trust them. That's the purpose of this guide!<li>If there isn't a pattern that does quite what you want, then it might take some ingenuity to combine patterns into new designs. (Custom behaviors can always be written using Prout.)</ul>

<p>Using patterns for sequencing might seem to be an advanced usage, but for many uses they are easier than the equivalent code written out step by step. They can serve as a bridge for new and advanced users alike, to represent a musical conception more directly with less connective tissue explicitly stated.
<p>The first step in learning a new language is vocabulary, so the next chapter will concentrate on foundational patterns to generate data streams of nearly every sort.<h2><a class='anchor' name='Patterns versus Streams'>Patterns versus Streams</a></h2>

<p>Some context that is important to keep in mind throughout this discussion is the difference between patterns and streams. In the most general terms:
<p><em>Patterns define behavior; streams execute it.</em>
<p>A pattern is like a blueprint for a building, showing how all the parts fit together. The building doesn't exist until the contractors go and do what the plans specify. When a stream is made from a pattern, it follows the plans laid out in the pattern's blueprint. Rendering the plans into a real-world result does not change the blueprint in any way, but to get the result, the stream has to go through different states.
<p>A pattern is supposed to describe behavior, and in general, evaluating the pattern (by way of a stream) should not change anything in the Pattern object itself. In computer science terms, patterns are <em>stateless</em>; their definition does not change over time. The stream is what keeps track of where we are in the pattern's evaluation.
<p>This explains an easy "gotcha" with patterns -- forgetting to turn the pattern into a stream doesn't get the expected result. Since a pattern doesn't have any concept of a current state, calling <code class='code prettyprint lang-sc'>next</code> on it is meaningless, so <code class='code prettyprint lang-sc'>next</code> does what it does for most objects: return the receiver object itself. The method <code class='code prettyprint lang-sc'>asStream</code> creates the stream conforming to the pattern's specification, and calling <code class='code prettyprint lang-sc'>next</code> on the stream advances to its next state and returns the new value.<pre class='code prettyprint lang-sc'>p = Pseries(0, 1, 10);
p.next;    // always returns the Pseries, not actual numbers

q = p.asStream;
q.next;    // calling this repeatedly gets the desired increasing integers</pre>

<p>There is a concrete benefit to this strict division of labor. Since the stream does not modify the original pattern, any number of streams can be made from the same blueprint. All of those streams maintain their own independent states, and they can operate concurrently without interfering with each other.<pre class='code prettyprint lang-sc'>r = p.asStream;
r.next;    // starts from zero, even though q already gave out some numbers

q.next;    // resumes where q left off, with no effect from getting values from r

[q.next, r.next]    // and so on...</pre>

<p>Bear these points in mind as we move to the next subject: getting basic types of data (deterministic and random) out of patterns.
<p>Next: <a href="./../../Tutorials/A-Practical-Guide/PG_02_Basic_Vocabulary.html">Pattern Guide 02: Basic Vocabulary</a><div class='footnotes'>
<a class='anchor' name='footnote_1'/><div class='footnote'>[<a href='#footnote_org_1'>1</a>] - Documentation licensing
<p>The initial version of these documents was written December-February 2009 by H. James Harkins. As part of the SuperCollider package, they are released under the Creative Commons CC-BY-SA license. As SuperCollider is an open source project, it is expected (and encouraged) that other users will contribute to the series. Dr. Harkins, however, wishes to retain exclusive rights to revise and republish the original body of work independently of the open-source copy. This excludes material contributed into svn by others. The work may be redistributed at no charge with proper attribution:
<p>Harkins, Henry James. "A Practical Guide to Patterns." SuperCollider 3.3 Documentation, 2009.</div></div><div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Tutorials/A-Practical-Guide/PG_01_Introduction.schelp'>/usr/local/share/SuperCollider/HelpSource/Tutorials/A-Practical-Guide/PG_01_Introduction.schelp</a><br>link::Tutorials/A-Practical-Guide/PG_01_Introduction::<br>sc version: 3.8dev</div></div></body></html>
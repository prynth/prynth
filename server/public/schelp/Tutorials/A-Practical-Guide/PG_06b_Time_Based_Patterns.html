<html><head><title>Pattern Guide 06b: Time Based Patterns</title>
<link rel='stylesheet' href='./../../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../../scdoc.js' type='text/javascript'></script>
<script src='./../../docmap.js' type='text/javascript'></script>
<script src='./../../prettify.js' type='text/javascript'></script>
<script src='./../../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./../..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider TUTORIALS/A-PRACTICAL-GUIDE</div>
<div id='categories'><a href='./../../Browse.html#Streams-Patterns-Events>A-Practical-Guide'>Streams-Patterns-Events>A-Practical-Guide</a></div>
<h1>Pattern Guide 06b: Time Based Patterns</h1>
<div id='summary'>Patterns using time as the basis for their evaluation</div>
</div>
<div class='subheader'>
<div id='related'>See also: <a href="./../../Tutorials/A-Practical-Guide/PG_06a_Repetition_Contraint_Patterns.html">Pattern Guide 06a: Repetition Contraint Patterns</a>, <a href="./../../Tutorials/A-Practical-Guide/PG_06c_Composition_of_Patterns.html">Pattern Guide 06c: Composition of Patterns</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#Time-based patterns'>Time-based patterns</a></li>
<ul class='toc'><li class='toc2'><a href='#Using envelopes as patterns'>Using envelopes as patterns</a></li>
<ul class='toc'></ul></ul></ul></div><h2><a class='anchor' name='Time-based patterns'>Time-based patterns</a></h2>

<p>"Time-based patterns" here are value patterns that use time as part of their calculation. Event patterns are naturally time-driven when played on a clock. (Technically it's possible to request events from an event stream without running it in an EventStreamPlayer, but this is not typical usage.)
<p>Most of these patterns work by remembering the clock's current time at the moment the pattern is embedded into a value stream. The time value used for calculation is, then, the clock's time at the moment of evaluation minus the starting time -- that is, the number of beats elapsed since the patterns started embedding. If the pattern is embedded several times, the starting time is also reset so that the pattern begins again from the beginning.
<p>There is nothing to prevent using these patterns outside of a scheduling context. In these documents, that context would be an event pattern played on a clock, but streams made from these patterns can be used in scheduled routines or functions as well. Only a scheduling context can ensure precise timing of requests for values.<dl>
<dt><code class='code prettyprint lang-sc'>Ptime(repeats)</code><dd>Returns the amount of time elapsed since embedding. One nice trick with this pattern is to stop a value stream/pattern after a certain amount of time.
<p>This <a href="./../../Classes/Pif.html">Pif</a> pattern uses Ptime to get values from the true branch for exactly 4 beats after the first value is requested. After that, the condition will be false and Pif reverts to the false branch, which is nil. That causes the stream to stop. (This is like <a href="./../../Classes/Pfindur.html">Pfindur</a> for event patterns, but Pif/Ptime works for value patterns as well.)<pre class='code prettyprint lang-sc'>// This is a really useful trick: like Pfindur but for value patterns
(
p = Pbind(
    \degree, Pif(Ptime(inf) &lt; 4.0, Pwhite(-4, 11, inf)),
    \dur, 0.25
).play;
)</pre>
<dt><code class='code prettyprint lang-sc'>Pstep(levels, durs, repeats)</code><dd>Repeat a <code class='code prettyprint lang-sc'>level</code> value for its corresponding duration, then move to the next.<dt><code class='code prettyprint lang-sc'>Pseg(levels, durs, curves, repeats)</code><dd>Similar to Pstep, but interpolates to the next value instead of stepping abruptly at the end of the duration. Interpolation is linear by default, but any envelope segment curve can be used. <code class='code prettyprint lang-sc'>levels</code>, <code class='code prettyprint lang-sc'>durs</code> and <code class='code prettyprint lang-sc'>curves</code> should be patterns.<pre class='code prettyprint lang-sc'>// curve is 5 - here's what the curve looks like, ascending first then descending
Env(#[0, 1, 0], #[1, 1], 5).plot;

(
p = Pbind(
        // using \note b/c Pseg will give fractional note numbers
        // can't use \degree because it handles non-integers differently
    \note, Pseg(
        Pwhite(-7, 19, inf),    // chromatic note numbers
            // alternate version for diatonic numbers
            // PdegreeToKey does the same conversion as \degree --&gt; \note
//        PdegreeToKey(Pwhite(-4, 11, inf), Pkey(\scale), 12),
        Pwhite(1, 4, inf) * 0.5,
        5, inf),
    \dur, 0.125
).play;
)

p.stop;</pre>
</dl>
<h3><a class='anchor' name='Using envelopes as patterns'>Using envelopes as patterns</a></h3>

<p><a href="./../../Classes/Env.html">Env</a> supports the stream protocol: <code class='code prettyprint lang-sc'>asStream</code> turns an Env into a stream, and timed values can be obtained from it using <code class='code prettyprint lang-sc'>next</code>. The envelope stream returns the value the envelope would have at the elapsed time, in the same way <code class='code prettyprint lang-sc'>.at(time)</code> returns the envelope value at the specified time.<pre class='code prettyprint lang-sc'>e = Env.linen(1, 1, 1);
e.at(2);    // == 1
e.at(2.5);    // == 0.5

// print envelope values
r = fork {
    var stream = e.asStream;
    12.do({
        stream.next.postln;
        0.25.wait;
    });
};

// Use an envelope to pan notes from left to right and back
p = Pbind(
    \degree, Pwhite(-4, 11, 32),
    \pan, Env(#[-1, 1, -1], #[2, 2], \sin),
    \dur, 0.125
).play;

p.stop;</pre>

<p>The <code class='code prettyprint lang-sc'>releaseNode</code> and <code class='code prettyprint lang-sc'>loopNode</code> envelope parameters do not take effect, because they are meaningful only when used in a Synth with a gated EnvGen.
<p>When the envelope ends, the stream will hold the final level indefinitely. The <code class='code prettyprint lang-sc'>Pif(Ptime(inf) &lt; totalTime, Env(...))</code> trick can make it stop instead.<pre class='code prettyprint lang-sc'>// Use an envelope to pan notes from left to right and back
// Plays one cycle
(
p = Pbind(
        // change to inf: we don't need to know exactly how many events are needed
    \degree, Pwhite(-4, 11, inf),
    \pan, Pif(Ptime(inf) &lt;= 4.0, Env(#[-1, 1, -1], #[2, 2], \sin)),
    \dur, 0.125
).play;
)

p.stop;

// To keep looping the envelope, wrap Pif inside Pn
(
p = Pbind(
    \degree, Pwhite(-4, 11, inf),
    \pan, Pn(Pif(Ptime(inf) &lt;= 4.0, Env(#[-1, 1, -1], #[2, 2], \sin)), inf),
    \dur, 0.125
).play;
)

p.stop;</pre>

<p>Previous: <a href="./../../Tutorials/A-Practical-Guide/PG_06a_Repetition_Contraint_Patterns.html">Pattern Guide 06a: Repetition Contraint Patterns</a>
<p>Next: <a href="./../../Tutorials/A-Practical-Guide/PG_06c_Composition_of_Patterns.html">Pattern Guide 06c: Composition of Patterns</a><div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Tutorials/A-Practical-Guide/PG_06b_Time_Based_Patterns.schelp'>/usr/local/share/SuperCollider/HelpSource/Tutorials/A-Practical-Guide/PG_06b_Time_Based_Patterns.schelp</a><br>link::Tutorials/A-Practical-Guide/PG_06b_Time_Based_Patterns::<br>sc version: 3.8dev</div></div></body></html>
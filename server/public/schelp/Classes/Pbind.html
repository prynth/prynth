<html><head><title>Pbind</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CLASSES</div>
<div id='categories'><a href='./../Browse.html#Streams-Patterns-Events>Patterns>Event'>Streams-Patterns-Events>Patterns>Event</a></div>
<h1>Pbind</h1>
<div id='summary'>combine several value patterns to one event stream by binding keys to values</div>
</div>
<div class='subheader'>
<div id='filename'>Source: /usr/local/share/SuperCollider/SCClassLibrary/Common/Streams/<a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/Streams/Patterns.sc'>Patterns.sc</a></div><div id='superclasses'>Inherits from: <a href="../Classes/Pattern.html">Pattern</a> : <a href="../Classes/AbstractFunction.html">AbstractFunction</a> : <a href="../Classes/Object.html">Object</a></div>
<div id='related'>See also: <a href="./../Classes/Pattern.html">Pattern</a>, <a href="./../Classes/Event.html">Event</a>, <a href="./../Classes/Pmono.html">Pmono</a>, <a href="./../Classes/Rest.html">Rest</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*new'>new</a> </li>
<li class='toc2'><a href='#Inherited class methods'>Inherited class methods</a></li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Inherited instance methods'>Inherited instance methods</a></li>
<li class='toc2'><a href='#Undocumented instance methods'>Undocumented instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-embedInStream'>embedInStream</a> </li>
<li class='toc3'><a href='#-patternpairs'>patternpairs</a> </li>
</ul></ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'><li class='toc2'><a href='#SynthDef and Event'>SynthDef and Event</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Rests'>Rests</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#The Play Method'>The Play Method</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Realtime Control with EventStreamPlayer'>Realtime Control with EventStreamPlayer</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Additional arguments'>Additional arguments</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Multichannel Expansion'>Multichannel Expansion</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Experimenting with Patterns'>Experimenting with Patterns</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Sending to effects'>Sending to effects</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Additional examples'>Additional examples</a></li>
<ul class='toc'></ul></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>

<p>Pbind combines several value streams into one event stream. Each value stream is assigned to one or more keys in the resulting event stream. It specifies a stream of <strong>Events</strong> in terms of different patterns that are <strong>bound</strong> to different keys in the Event. The patterns bound to keys are referred to as <em>value patterns</em> and the Pbind itself is termed an event pattern.
<p>The keys used in a Pbind are usually determined by <a href="./../Classes/Event.html">Event</a>'s default mechanism and the controls defined for the <a href="./../Classes/SynthDef.html">SynthDef</a> to be played. (See <a href="#SynthDef and Event">SynthDef and Event</a> below for a brief discussion of both in relation to Pbind.)<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*new' href='./../Overviews/Methods.html#new'>new</a> ( <span class='argstr'>... pairs</span>)</h3>
<div class='method'>
<p>The arguments to Pbind are an alternating sequence of keys and patterns. A pattern can also be bount to an array of keys. In this case, the pattern must specify a sequence whose elements are arrays with at least as many elements as there are keys.</div><h3><a class='anchor' name='Inherited class methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3><a class='anchor' name='Inherited instance methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h3><a class='anchor' name='Undocumented instance methods'>Undocumented instance methods</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-embedInStream' href='./../Overviews/Methods.html#embedInStream'>embedInStream</a> (<span class='argstr'>inevent</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-patternpairs' href='./../Overviews/Methods.html#patternpairs'>patternpairs</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-patternpairs' href='./../Overviews/Methods.html#patternpairs'>patternpairs</a> = value</h3>
<h2><a class='anchor' name='examples'>Examples</a></h2>
<pre class='code prettyprint lang-sc'>(
a = Pbind(\x, Pseq([1, 2, 3]), \y, Prand([100, 300, 200], inf), \zzz, 99);
x = a.asStream;
)

x.next(()); // pass in an event ()
x.next(());
x.next(());
x.next(()); // end: nil</pre>
<pre class='code prettyprint lang-sc'>// sound examples

// using the default synth def
Pbind(\freq, Prand([300, 500, 231.2, 399.2], inf), \dur, 0.1).play;
Pbind(\freq, Prand([300, 500, 231.2, 399.2], inf), \dur, Prand([0.1, 0.3], inf)).play;

Pbind(\freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200, \dur, 0.1).play;</pre>
<pre class='code prettyprint lang-sc'>(
// a SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
    var audio = Blip.ar(freq, nharms, amp);
    var env = Linen.kr(gate, doneAction: 2);
    OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;
)

Pbind(\instrument, \test, \freq, Prand([1, 1.2, 2, 2.5, 3, 4], inf) * 200, \dur, 0.1).play;



// standard syntax, arguments alternate symbols and patterns
(
Pbind(
    \instrument,        \test,
    \nharms,             Pseq([4, 10, 40], inf),
    \dur,                Pseq([1, 1, 2, 1]/10, inf),
    #[freq, sustain],    Ptuple([ // assignment to multiple keys
                            Pseq( (1..16) * 50, 4),
                             Pseq([1/10, 0.5, 1, 2], inf)
                        ])
).play;
)::

It is possible to specify a Pbind with an link::Classes/Array:: preceded by *. Arrays treat identifiers ending with a colon as link::Classes/Symbol::s, making the syntax of the Pbind specification a bit more concise:

code::
(
// Alternative syntax, using a key/pattern array:
Pbind(*[
    instrument:            \test,
    nharms:                Pseq([4, 10, 40], inf),
    dur:                Pseq([1, 1, 2, 1]/10, inf),
    #[freq, sustain]:    Ptuple([
                            Pseq( (1..16) * 50, 4),
                            Pseq([1/10, 0.5, 1, 2], inf)
                        ])
]).play;
)</pre>
<h3><a class='anchor' name='SynthDef and Event'>SynthDef and Event</a></h3>

<p>The keys used in a Pbind are determined by the <a href="./../Classes/SynthDef.html">SynthDef</a> used and the structure of the extensive default mechanism provided by <a href="./../Classes/Event.html">Event</a>. This section provides a brief review of both.
<p>A <a href="./../Classes/SynthDef.html">SynthDef</a> assigns a name to an interconnection of unit generators to be run as a synth on a server. It also assigns <strong>control names</strong> to the synth's control inputs. In the following example the SynthDef \test has control inputs <strong>out</strong>, <strong>freq</strong>, <strong>amp</strong>, <strong>nharms</strong>, <strong>pan</strong>, and <strong>gate</strong>.<pre class='code prettyprint lang-sc'>SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
    var audio = Blip.ar(freq, nharms, amp);
    var env = Linen.kr(gate, doneAction: 2);
    OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;</pre>

<p>The SynthDef needs to be downloaded to the server upon which it is to be run. Use <strong>.add</strong> instead of .send to ensure that any patterns using this SynthDef have information about the available control inputs (see <a href="./../Classes/SynthDesc.html">SynthDesc</a>). Alternately, <strong>.store</strong> may be used to save the SynthDef to disk and add the SynthDesc to the library.
<p>An <a href="./../Classes/Event.html">Event</a> is a Dictionary that specifies an action to be taken in response to <strong>play</strong> and a time increment to be returned in response to <strong>delta</strong>. Events can be written as a series of key value pairs enclosed in parentheses. Empty parentheses create an empty event.
<p>By default, Events play synths on a server. Such <em>note events</em> use the following keys:<dl>
<dt>instrument (\default)<dd>The synthdef to be played<dt>variant (nil, optional)<dd>The set of variant control defaults to use (see <a href="./../Classes/SynthDef.html">SynthDef</a>)<dt>server (Server.default)<dd>The server that plays the synth<dt>group (1)<dd>The new synth's or the synth the new synth is placed before or after<dt>addAction (0)<dd>How the synth is placed relative to the target specified by <strong>group</strong><dl>
<dt>0<dd>head of group<dt>1<dd>tail of group<dt>2<dd>before group (could be a Synth)<dt>3<dd>after group (could be a Synth)</dl>

<p><dt>delta (function)<dd>The time until the next event in a sequence of events, generally specified indirectly through <strong>dur</strong></dl>

<p>When the Event is played, it creates an OSC command to play a synth. It uses the name assigned to <strong>instrument</strong> to the select the SynthDef to be played. The SynthDef's control names (found in its <a href="./../Classes/SynthDesc.html">SynthDesc</a>) are looked up in the event and the corresponding values included in the command.
<p>Playing a synth is the normal action taken by an Event. The default event structure defines several other event types that can perform a wide variety of server actions. See the <a href="./../Classes/Event.html">Event</a> help file for a list of event types.
<p>There are a number of coventional names typically used to identify controls in a synth.<dl>
<dt>out<dd>output bus index<dt>in<dd>input bus index (for filters, modulators, etc)<dt>gate<dd>envelope gate (not level!) - should default to 1.0, deletes synth when released<dt>trig<dd>envelope gate (not level!) - should default to 1.0, does not delete synth when released<dt>pan<dd>panning position<dt>bufnum<dd>buffer number (used in synths that utilize <a href="./../Classes/PlayBuf.html">PlayBuf</a>, <a href="./../Classes/DiskIn.html">DiskIn</a>, etc)<dt>sustain<dd>duration of the synth<dt>amp<dd>amplitude of the synth<dt>freq<dd>base pitch of the synth</dl>

<p>Event implements a layered specification scheme for some of these controls. In the following list, the first and leftmost name is the actual control name, names below and indented are more abstract ways to specify the control.<dl>
<dt>delta<dd>The time until the next event. Generally determined by:<dl>
<dt>dur<dd>The time until next event in a sequence of events<dt>stretch<dd>Scales event timings (i.e. stretch == 2 =&gt; durations are twice as long)</dl>

<p><dt>sustain<dd>Duration of the synth, typically determined (in stretched time units) by:<dl>
<dt>legato<dd>The ratio of the synth's duration to the event's duration</dl>

<p><dt>amp<dd>synth amplitude (typically ranging from 0 to 1), often determined by<dl>
<dt>db<dd>Amplitude in decibels</dl>

<p><dt>detunedFreq<dd>actual "pitch" of a synth, determined by:<dl>
<dt>freq + detune;<dd>freq is determined by:<dl>
<dt>(midinote + ctranspose).midicps * harmonic;<dd>midinote is determined by:<dl>
<dt>(note + gtranspose + root)/stepsPerOctave * octave * 12;<dd>note is determined by:<dl>
<dt>(degree + mtranspose).degreeToKey(scale, stepsPerOctave)<dd></dl>
</dl>
</dl>
</dl>
</dl>
<pre class='code prettyprint lang-sc'>(
// the SynthDef
SynthDef(\test, { | out, freq = 440, amp = 0.1, nharms = 10, pan = 0, gate = 1 |
    var audio = Blip.ar(freq, nharms, amp);
    var env = Linen.kr(gate, doneAction: 2);
    OffsetOut.ar(out, Pan2.ar(audio, pan, env) );
}).add;

// Events are written as parantheses enclosing key/value pairs
(instrument: \test).play;
(instrument: \test, freq: 20, nharms: 50).play;
)</pre>
<h3><a class='anchor' name='Rests'>Rests</a></h3>
See <a href="./../Classes/Rest.html">Rest</a> for a discussion of marking events as rests in Pbind.<h3><a class='anchor' name='The Play Method'>The Play Method</a></h3>

<p>While the play method is actually defined in the class <a href="./../Classes/Pattern.html">Pattern</a>, it is useful to review it here:<dl>
<dt>play (clock, protoEvent, quant)<dd>returns an <a href="./../Classes/EventStreamPlayer.html">EventStreamPlayer</a>.<dt>clock<dd>The clock that schedules the EventStreamPlayer, defaults to TempoClock.default. Patterns that change graphics must use <a href="./../Classes/AppClock.html">AppClock</a>.<dt>protoEvent<dd>The initial event modified by Pbind, defaults to Event.default.<dt>quant<dd>A quantization value used by clock. When a number, the pattern will start at the next even multiple of that number. May also be a <a href="./../Classes/Quant.html">Quant</a>, which specifies quantization, time position within that quantization, and a timingOffset. See <a href="./../Classes/Quant.html">Quant</a> for details.</dl>
<h3><a class='anchor' name='Realtime Control with EventStreamPlayer'>Realtime Control with EventStreamPlayer</a></h3>

<p>The <a href="./../Classes/EventStreamPlayer.html">EventStreamPlayer</a> provides realtime control through <strong>mute</strong>, <strong>unmute</strong>, <strong>stop</strong>, <strong>play</strong> and <strong>reset</strong>.<pre class='code prettyprint lang-sc'>(
SynthDef(\cfstring1, { arg i_out, freq = 360, gate = 1, pan, amp=0.1;
    var out, eg, fc, osc, a, b, w;
    fc = LinExp.kr(LFNoise1.kr(Rand(0.25, 0.4)), -1, 1, 500, 2000);
    osc = Mix.fill(8, {LFSaw.ar(freq * [Rand(0.99, 1.01), Rand(0.99, 1.01)], 0, amp) }).distort * 0.2;
    eg = EnvGen.kr(Env.asr(1, 1, 1), gate, doneAction:2);
    out = eg * RLPF.ar(osc, fc, 0.1);
    #a, b = out;
    Out.ar(i_out, Mix.ar(PanAz.ar(4, [a, b], [pan, pan+0.3])));
}).add;

e = Pbind(
    \degree, Pseq((0..12), inf),
    \dur, 0.2,
    \instrument, \cfstring1
).play; // returns an EventStream
)

( // an interactive session
e.stop
e.play
e.reset

e.mute; // keeps playing, but replaces notes with rests

e.unmute;

e.reset; // reset the stream.
e.reset; // reset the stream.
e.reset; // reset the stream.
e.reset; // reset the stream.

e.pause; // will resume where paused.

e.play;

e.stop; // will reset before resume.

e.play;
)</pre>

<p>In addition, the stream the EventStreamPlayer plays can be altered while it is running through the method <strong>stream_(aStream)</strong>.<pre class='code prettyprint lang-sc'>(
e.stream = Pbind(
    \degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
    \dur, Prand([0.2, 0.4, 0.8], inf),
    \amp, 0.05, \octave, 5,
    \instrument, \cfstring1, \ctranspose, 0
).asStream;
)

(
e.stream = Pbind(
    \degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
    \dur, Prand([0.2, 0.4, 0.8], inf),
    \amp, 0.05, \octave, 5,
    \instrument, \cfstring1, \ctranspose, 0
).asStream;
)

(
e.stream = Pbind(
    \degree, Pxrand([0, 1, 2, 4, 6, 3, 5, 7, 8], inf),
    \dur, Prand([0.2, 0.4, 0.8], inf), \amp, 0.05,
    \octave, 5, \instrument, \cfstring1
).asStream;
)</pre>
<h3><a class='anchor' name='Additional arguments'>Additional arguments</a></h3>

<p>Here is an example with more bindings. Here we have added a filter with cutoff and resonance arguments. You will need to hit command '.' before executing the next few pbind ex. without having them stack up. also, due to the synthdef's and synthdeclib, if the server is shut down you will have to reload the synthdef and re-read the synthdesclib.<pre class='code prettyprint lang-sc'>(
SynthDef(\acid, { arg out, freq = 1000, gate = 1, pan = 1, cut = 4000, rez = 0.8, amp = 1;
    Out.ar(out,
        Pan2.ar(
            RLPF.ar(
                Pulse.ar(freq, 0.05),
            cut, rez),
        pan) * EnvGen.kr(Env.linen(0.01, 1, 0.3), gate, amp, doneAction:2);
    )
}).add;
)

(
Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, -12,
    \degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
    \cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2).play;
)</pre>

<p>The <a href="./../Classes/ListPattern.html">ListPattern</a>s can be put around Event Streams to create sequences of Event Streams.<pre class='code prettyprint lang-sc'>(
Pseq([
    Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], 4), \root, -24,
        \degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
        \cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2),

    Pbind(\instrument, \acid, \dur, Pseq([0.25], 6), \root, -24, \degree, Pseq([18, 17, 11, 9], inf),
        \pan, Pfunc({1.0.rand2}), \cut, 1500, \rez, Pfunc({0.7.rand +0.3}), \amp, 0.16)

], inf).play;
)</pre>

<p>'Pseq' in the above ex. can be any pattern object:<pre class='code prettyprint lang-sc'>(
Prand([
    Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], 4), \root, -24,
        \degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
        \cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}),
        \amp, 0.2),

    Pbind(\instrument, \acid, \dur, Pseq([0.25], 6), \root, -24, \degree, Pseq([18, 17, 11, 9], inf),
        \pan, Pfunc({1.0.rand2}), \cut, 1500, \rez, Pfunc({0.7.rand +0.3}), \amp, 0.16)

], inf).play;
)</pre>
<h3><a class='anchor' name='Multichannel Expansion'>Multichannel Expansion</a></h3>

<p>If we supply an array for <strong>any</strong> argument, the synth node will automatically replicate to handle the additional arguments.
<p>The only <strong>exception</strong> to this is: <code class='code prettyprint lang-sc'>\instrument</code> and <code class='code prettyprint lang-sc'>\dur</code>. For the general schema, see also: <a href="./../Guides/Multichannel-Expansion.html">Multichannel Expansion</a>.<pre class='code prettyprint lang-sc'>// When we provide the 'root' argument an array, we should hear a chord.
// the synth def is defined above
(
Pbind(
    \instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf),
    \root, [-24, -17],  // expand root
    \degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf),
    \pan, Pfunc { 1.0.rand2 },
    \cut, Pxrand([1000, 500, 2000, 300], inf),
    \rez, Pfunc { 0.7.rand + 0.3 },
    \amp, 0.2).play;
);

// multiple arrays are correlated in parallel, the shorter one wraps:
(
Pbind(
    \instrument, \acid,
    \dur, Pseq([0.25, 0.5, 0.25], inf),
    \root, [-24, -17], // expand root ...
    \degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf) + [0, 6, 9], // ... and expand degrees
    \pan, Pfunc { 1.0.rand2 },
    \cut, Pxrand([1000, 500, 2000, 300], inf),
    \rez, Pfunc { 0.7.rand + 0.3 },
    \amp, 0.2).play;
);</pre>
<div class='note'><span class='notelabel'>NOTE:</span> In Pbind, you can’t have arrays of patterns, but only patterns that <strong>return</strong> arrays.</div><pre class='code prettyprint lang-sc'>// so this does not expand:
Pbind(\degree, [Pseq([0, 2, 3], inf), Pseq([2, 4, 5, 6], inf)]).play;

// but this does:
Pbind(\degree, Pseq([ [ 0, 2 ], [ 2, 4 ], [ 3, 5 ], [ 0, 6 ] ], inf)]).play;</pre>
<pre class='code prettyprint lang-sc'>// transform an array of patterns into a pattern that returns arrays, use Ptuple:
a = [Pseq([1, 2, 3], inf), Prand([100, 299, 399], inf), Pseries(0, 6, inf)];
b = Ptuple(a);
b.asStream.nextN(8)</pre>
<pre class='code prettyprint lang-sc'>Pbind(\degree, Ptuple([Pseq([0, 2, 3], inf), Pseq([2, 4, 5, 6], inf)])).play;</pre>
<pre class='code prettyprint lang-sc'>// an example: instead of \degree, [p1, p2] you write \degree, Ptuple([p1, p2])
(
Pdef(\x,
    Pbind(
        \instrument, \test,
        \legato, 0.2,
        \degree, Ptuple([0, Pwalk(Scale.hijaz.degrees, Prand([1, -1], inf))],
        \scale, Scale.hijaz,
        \strum, 0.05
    )
).play;
)</pre>
<h3><a class='anchor' name='Experimenting with Patterns'>Experimenting with Patterns</a></h3>

<p>Using <a href="./../Classes/Pdef.html">Pdef</a> (provided by <a href="./../Overviews/JITLib.html">JITLib</a>) makes it easy to replace patterns on the fly:<pre class='code prettyprint lang-sc'>(
Pdef(\buckyball).play;
)

(
Pdef(\buckyball, Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
    \degree, Pseq([0, 3, 5, 7, 9, 11, [5, 17], 1], inf), \pan, Pfunc({[1.0.rand2, 1.0.rand2]}),
    \cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, [0.15, 0.22]));
)
(
Pdef(\buckyball, Pbind(\instrument, \acid, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
    \degree, Pseq([0b, 3b, 5b, 7b, 9b, 11b, 5b, 0b], inf), \pan, Pfunc({1.0.rand2}), //notice the flats
    \cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.2));
)

//stop the Pdef
Pdef(\buckyball).stop;

//start the Pdef
Pdef(\buckyball).resume;

//removing the Pdef
Pdef.remove(\buckyball);</pre>
<h3><a class='anchor' name='Sending to effects'>Sending to effects</a></h3>

<p>Assignment to effect processors can be achieved by setting the 'out' argument to the desired efx's input bus. The effect Synth must also be created. Synth.new is one way of doing this.<pre class='code prettyprint lang-sc'>(
// efx synthdef- dig the timing on the delay and the pbind. :-P
SynthDef(\pbindefx, { arg out, in, time1=0.25, time2=0.5;
    var audio, efx;
    audio = In.ar([20, 21], 2);
    efx=CombN.ar(audio, 0.5, [time1, time2], 10, 1, audio);
    Out.ar(out, efx);
}).add;

// create efx synth
a = Synth.after(1, \pbindefx);

// if you don't like the beats change to 0.4, 0.24
// a.set(\time1, 0.4, \time2, 0.24);

SynthDef(\acid, { arg out, freq = 1000, gate = 1, pan = 0, cut = 4000, rez = 0.8, amp = 1;
    Out.ar(out,
        Pan2.ar(
            RLPF.ar(
                Pulse.ar(freq, 0.05),
            cut, rez),
        pan) * EnvGen.kr(Env.linen(0.02, 1, 0.3), gate, amp, doneAction:2);
    )
}).add;
)

(
Pbind(\instrument, \acid, \out, 20, \dur, Pseq([0.25, 0.5, 0.25], inf), \root, [-24, -17],
    \degree, Pseq([0, 3, 5, 7, 9, 11, 5, 1], inf), \pan, Pfunc({1.0.rand2}),
    \cut, Pxrand([1000, 500, 2000, 300], inf), \rez, Pfunc({0.7.rand +0.3}), \amp, 0.12).play;
)</pre>
<h3><a class='anchor' name='Additional examples'>Additional examples</a></h3>
<pre class='code prettyprint lang-sc'>(
SynthDef(\berlinb, { arg out=0, freq = 80, amp = 0.01, pan=0, gate=1;
    var synth, env;
    env = Decay2.kr(gate, 0.05, 8, 0.0003);
    synth = RLPF.ar(
        LFPulse.ar(freq, 0, SinOsc.kr(0.12, [0, 0.5pi], 0.48, 0.5)),
        freq * SinOsc.kr(0.21, 0, 18, 20),
        0.07
    );
    #a, b = synth*env;
    DetectSilence.ar(a, 0.1, doneAction: 2);
    Out.ar(out, amp * Mix.ar(PanAz.ar(4, [a, b], [pan, pan+1])));
}).add;
)

(
f = Pbind(
    \degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
    \dur, 0.5, \octave, 3, \instrument, \berlinb
).play;
)

(
f.stream = Pbind(
    \degree, Pseq([0, 1, 2, 4, 6, 3, 4, 8], inf),
    \dur, 0.5, \octave, [2, 1],
    \instrument, \berlinb,
    \pan, Pfunc({1.0.rand2})
).asStream;
)</pre>

<p><div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Classes/Pbind.schelp'>/usr/local/share/SuperCollider/HelpSource/Classes/Pbind.schelp</a><br>link::Classes/Pbind::<br>sc version: 3.8dev</div></div></body></html>
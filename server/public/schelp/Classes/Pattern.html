<html><head><title>Pattern</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CLASSES</div>
<div id='categories'><a href='./../Browse.html#Streams-Patterns-Events>Patterns'>Streams-Patterns-Events>Patterns</a></div>
<h1>Pattern</h1>
<div id='summary'>abstract class that holds a list</div>
</div>
<div class='subheader'>
<div id='filename'>Source: /usr/local/share/SuperCollider/SCClassLibrary/Common/Streams/<a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/Streams/Patterns.sc'>Patterns.sc</a></div><div id='superclasses'>Inherits from: <a href="../Classes/AbstractFunction.html">AbstractFunction</a> : <a href="../Classes/Object.html">Object</a></div>
<div id='subclasses'>Subclasses: <a href="../Classes/FilterPattern.html">FilterPattern</a>, <a href="../Classes/ListPattern.html">ListPattern</a>, <a href="../Classes/PatternProxy.html">PatternProxy</a>, <a href="../Classes/Pbeta.html">Pbeta</a>, <a href="../Classes/Pbind.html">Pbind</a>, <a href="../Classes/PbindProxy.html">PbindProxy</a>, <a href="../Classes/Pbinop.html">Pbinop</a>, <a href="../Classes/Pbrown.html">Pbrown</a>, <a href="../Classes/Pcauchy.html">Pcauchy</a>, <a href="../Classes/Pchain.html">Pchain</a>, <a href="../Classes/Pdict.html">Pdict</a>, <a href="../Classes/Penvir.html">Penvir</a>, <span id='hiddensubclasses' style='display:none;'><a href="../Classes/Pevent.html">Pevent</a>, <a href="../Classes/Peventmod.html">Peventmod</a>, <a href="../Classes/Pfhn.html">Pfhn</a>, <a href="../Classes/Pfunc.html">Pfunc</a>, <a href="../Classes/Pfuncn.html">Pfuncn</a>, <a href="../Classes/Pgauss.html">Pgauss</a>, <a href="../Classes/Pgbman.html">Pgbman</a>, <a href="../Classes/Pgeom.html">Pgeom</a>, <a href="../Classes/Pget.html">Pget</a>, <a href="../Classes/Phenon.html">Phenon</a>, <a href="../Classes/Pif.html">Pif</a>, <a href="../Classes/Pindex.html">Pindex</a>, <a href="../Classes/Pkey.html">Pkey</a>, <a href="../Classes/Platoo.html">Platoo</a>, <a href="../Classes/Plazy.html">Plazy</a>, <a href="../Classes/Plet.html">Plet</a>, <a href="../Classes/PlinCong.html">PlinCong</a>, <a href="../Classes/Plorenz.html">Plorenz</a>, <a href="../Classes/Pmono.html">Pmono</a>, <a href="../Classes/Pnaryop.html">Pnaryop</a>, <a href="../Classes/Ppatmod.html">Ppatmod</a>, <a href="../Classes/Ppoisson.html">Ppoisson</a>, <a href="../Classes/Pprob.html">Pprob</a>, <a href="../Classes/Pproto.html">Pproto</a>, <a href="../Classes/Pquad.html">Pquad</a>, <a href="../Classes/Prout.html">Prout</a>, <a href="../Classes/Pseries.html">Pseries</a>, <a href="../Classes/Pstandard.html">Pstandard</a>, <a href="../Classes/Pstep.html">Pstep</a>, <a href="../Classes/Pstep2add.html">Pstep2add</a>, <a href="../Classes/Pstep3add.html">Pstep3add</a>, <a href="../Classes/PstepNfunc.html">PstepNfunc</a>, <a href="../Classes/Pswitch.html">Pswitch</a>, <a href="../Classes/Ptime.html">Ptime</a>, <a href="../Classes/Punop.html">Punop</a>, <a href="../Classes/Pwhite.html">Pwhite</a>, <a href="../Classes/Spawner.html">Spawner</a></span><a class='subclass_toggle' href='#' onclick='javascript:showAllSubclasses(this); return false'>&hellip;&nbsp;see&nbsp;all</a></div>
<div id='related'>See also: <a href="./../Classes/Stream.html">Stream</a>, <a href="./../Classes/FilterPattern.html">FilterPattern</a>, <a href="./../Classes/ListPattern.html">ListPattern</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'><li class='toc2'><a href='#Patterns versus Streams'>Patterns versus Streams</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#example 1 - Pseq vs. Routine'>example 1 - Pseq vs. Routine</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#example 2 - Nesting patterns'>example 2 - Nesting patterns</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#example 3 - Stream-embedInStream'>example 3 - Stream-embedInStream</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Event Patterns'>Event Patterns</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Playing Event Patterns'>Playing Event Patterns</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Recording Event Patterns'>Recording Event Patterns</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Inherited class methods'>Inherited class methods</a></li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-asStream'>asStream</a> </li>
<li class='toc3'><a href='#-embedInStream'>embedInStream</a> </li>
<li class='toc3'><a href='#-play'>play</a> </li>
<li class='toc3'><a href='#-record'>record</a> </li>
<li class='toc2'><a href='#Inherited instance methods'>Inherited instance methods</a></li>
<li class='toc2'><a href='#Undocumented instance methods'>Undocumented instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-++'>++</a> </li>
<li class='toc3'><a href='#-<>'>&lt;&gt;</a> </li>
<li class='toc3'><a href='#-addDur'>addDur</a> </li>
<li class='toc3'><a href='#-asEventStreamPlayer'>asEventStreamPlayer</a> </li>
<li class='toc3'><a href='#-asScore'>asScore</a> </li>
<li class='toc3'><a href='#-buildForProxy'>buildForProxy</a> </li>
<li class='toc3'><a href='#-clump'>clump</a> </li>
<li class='toc3'><a href='#-collect'>collect</a> </li>
<li class='toc3'><a href='#-composeBinaryOp'>composeBinaryOp</a> </li>
<li class='toc3'><a href='#-composeNAryOp'>composeNAryOp</a> </li>
<li class='toc3'><a href='#-composeUnaryOp'>composeUnaryOp</a> </li>
<li class='toc3'><a href='#-ctranspose'>ctranspose</a> </li>
<li class='toc3'><a href='#-db'>db</a> </li>
<li class='toc3'><a href='#-detune'>detune</a> </li>
<li class='toc3'><a href='#-differentiate'>differentiate</a> </li>
<li class='toc3'><a href='#-do'>do</a> </li>
<li class='toc3'><a href='#-drop'>drop</a> </li>
<li class='toc3'><a href='#-fin'>fin</a> </li>
<li class='toc3'><a href='#-finDur'>finDur</a> </li>
<li class='toc3'><a href='#-flatten'>flatten</a> </li>
<li class='toc3'><a href='#-gtranspose'>gtranspose</a> </li>
<li class='toc3'><a href='#-integrate'>integrate</a> </li>
<li class='toc3'><a href='#-iter'>iter</a> </li>
<li class='toc3'><a href='#-keep'>keep</a> </li>
<li class='toc3'><a href='#-lag'>lag</a> </li>
<li class='toc3'><a href='#-legato'>legato</a> </li>
<li class='toc3'><a href='#-lock'>lock</a> </li>
<li class='toc3'><a href='#-mtranspose'>mtranspose</a> </li>
<li class='toc3'><a href='#-proxyControlClass'>proxyControlClass</a> </li>
<li class='toc3'><a href='#-reject'>reject</a> </li>
<li class='toc3'><a href='#-repeat'>repeat</a> </li>
<li class='toc3'><a href='#-reverseComposeBinaryOp'>reverseComposeBinaryOp</a> </li>
<li class='toc3'><a href='#-scaleDur'>scaleDur</a> </li>
<li class='toc3'><a href='#-select'>select</a> </li>
<li class='toc3'><a href='#-streamArg'>streamArg</a> </li>
<li class='toc3'><a href='#-stretch'>stretch</a> </li>
<li class='toc3'><a href='#-stutter'>stutter</a> </li>
<li class='toc3'><a href='#-trace'>trace</a> </li>
</ul></ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'><li class='toc2'><a href='#EVENT PATTERNS - patterns that generate or require event streams'>EVENT PATTERNS - patterns that generate or require event streams</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#GENERAL PATTERNS that work with both event and value streams'>GENERAL PATTERNS that work with both event and value streams</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#VALUE PATTERNS: these patterns define or act on streams of numbers'>VALUE PATTERNS: these patterns define or act on streams of numbers</a></li>
<ul class='toc'></ul></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>
<h3><a class='anchor' name='Patterns versus Streams'>Patterns versus Streams</a></h3>

<p><strong>Pattern</strong> is an abstract class that is the base for the Patterns library. These classes form a rich and concise score language for music. The series of help files entitled <a href="./../Tutorials/Streams-Patterns-Events1.html">Understanding Streams, Patterns and Events - Part 1</a> gives a detailed introduction. This attemps a briefer characterization.
<p>A <strong>Stream</strong> is an object that responds to <code class='code prettyprint lang-sc'>next</code>, <code class='code prettyprint lang-sc'>reset</code>, and <code class='code prettyprint lang-sc'>embedInStream</code>. Streams represent sequences of values that are obtained one at a time by with message <code class='code prettyprint lang-sc'>next</code>. A <code class='code prettyprint lang-sc'>reset</code> message will cause the stream to restart (many but not all streams actually repeat themselves.) If a stream runs out of values it returns <code class='code prettyprint lang-sc'>nil</code> in response to <code class='code prettyprint lang-sc'>next</code>. The message <code class='code prettyprint lang-sc'>embedInStream</code> allows a stream definition to allow another stream to "take over control" of the stream. All objects respond to <code class='code prettyprint lang-sc'>next</code> and <code class='code prettyprint lang-sc'>reset</code>, most by returning themselves in response to next. Thus, the number 7 defines a Stream that produces an infinite sequence of 7's. Most objects respond to <code class='code prettyprint lang-sc'>embedInStream</code> with a singleton Stream that returns the object once.
<p>A <strong>Pattern</strong> is an object that responds to <code class='code prettyprint lang-sc'>asStream</code> and <code class='code prettyprint lang-sc'>embedInStream</code>. A Pattern defines the behavior of a Stream and creates such streams in response to the messages <code class='code prettyprint lang-sc'>asStream</code>. The difference between a Pattern and a Stream is similar to the difference between a score and a performance of that score or a class and an instance of that class. All objects respond to this interface, most by returning themselves. So most objects are patterns that define streams that are an infinite sequence of the object and embed as singleton streams of that object returned once.
<p>Patterns are defined in terms of other Patterns rather than in terms of specific values. This allows a Pattern of arbitrary complexity to be substituted for a single value anywhere within a Pattern definition. A comparison between a Stream definition and a Pattern will help illustrate the usefulness of Patterns.<h3><a class='anchor' name='example 1 - Pseq vs. Routine'>example 1 - Pseq vs. Routine</a></h3>

<p>The Pattern class <strong>Pseq(array, repetitions)</strong> defines a Pattern that will create a Stream that iterates an array. The class <strong>Routine(func, stackSize)</strong> defines a single Stream, the function that runs within that stream is defined to perform the array iteration.
<p>Below a stream is created with <a href="./../Classes/Pseq.html">Pseq</a> and an <code class='code prettyprint lang-sc'>asStream</code> message and an identical stream is created directly using Routine.<pre class='code prettyprint lang-sc'>// a Routine vs a Pattern
(
    a = [-100, 00, 300, 400];            // the array to iterate

    p = Pseq(a);                    // make the Pattern
    q = p.asStream;                    // have the Pattern make a Stream
    r = Routine({ a.do({ arg v; v.yield}) }) ;    // make the Stream directly

    5.do({ Post &lt;&lt; Char.tab &lt;&lt; r.next &lt;&lt; " " &lt;&lt; q.next &lt;&lt; Char.nl; });
)</pre>
<h3><a class='anchor' name='example 2 - Nesting patterns'>example 2 - Nesting patterns</a></h3>

<p>In example 1, there is little difference between using <a href="./../Classes/Pseq.html">Pseq</a> and <a href="./../Classes/Routine.html">Routine</a>. But Pseq actually iterates its array as a collection of <em>patterns to be embedded</em>, allowing another Pseq to replace any of the values in the array. The Routine, on the other hand, needs to be completely redefined.<pre class='code prettyprint lang-sc'>(
    var routinesA;
    a = [3, Pseq([-100, 00, 300, 400]), Pseq([-100, 00, 300, 400].reverse) ];
    routinesA = [[3], [-100, 00, 300, 400], [-100, 00, 300, 400].reverse];
    p = Pseq(a);
    q = p.asStream;

    r = Routine({
        routinesA.do({ arg v;
            v.do({ arg i; i.yield})
        }) ;
    });
    10.do({ Post &lt;&lt; Char.tab &lt;&lt; r.next &lt;&lt; " " &lt;&lt; q.next &lt;&lt; Char.nl; });
)</pre>
<h3><a class='anchor' name='example 3 - Stream-embedInStream'>example 3 - Stream-embedInStream</a></h3>

<p>The message <code class='code prettyprint lang-sc'>embedInStream</code> is what allows Patterns to do this kind of nesting. Most objects (such as the number 3 below) respond to <code class='code prettyprint lang-sc'>embedInStream</code> by yielding themselves once and returning. Streams respond to embedInStream by iterating themselves to completion, effectively "taking over" the calling stream for that time.
<p>A Routine can perform a pattern simply by replacing calls to <code class='code prettyprint lang-sc'>yield</code> with calls to <code class='code prettyprint lang-sc'>embedInStream</code>.<pre class='code prettyprint lang-sc'>(
    a = [3, Pseq([-100, 00, 300, 400]), Pseq([-100, 00, 300, 400].reverse) ];

    r = Routine({ a.do({ arg v; v.embedInStream}) }) ;
    p = Pseq(a);
    q = p.asStream;
    10.do({ Post &lt;&lt; Char.tab &lt;&lt; r.next &lt;&lt; " " &lt;&lt; q.next &lt;&lt; Char.nl; });
)</pre>

<p>Of course, there is no concise way to <em>define</em> this stream without using Pseq.<div class='note'><span class='notelabel'>NOTE:</span> For reasons of efficiency, the implementation of <code class='code prettyprint lang-sc'>embedInStream</code> assumes that it is called from within a <a href="./../Classes/Routine.html">Routine</a>. Consequently, <code class='code prettyprint lang-sc'>embedInStream</code> should never be called from within the function that defines a <a href="./../Classes/FuncStream.html">FuncStream</a> or a <a href="./../Classes/Pfunc.html">Pfunc</a> (the pattern that creates FuncStreams).</div><h3><a class='anchor' name='Event Patterns'>Event Patterns</a></h3>

<p>An <a href="./../Classes/Event.html">Event</a> is a <a href="./../Classes/Environment.html">Environment</a> with a 'play' method. Typically, an Event consists of a collection of key/value pairs that determine what the play method actually does. The values may be any object including functions defined in terms of other named attributes. Changing those values can generate a succession of sounds sometimes called 'music'... The pattern <a href="./../Classes/Pbind.html">Pbind</a> connects specific patterns with specific names. Consult its help page for details.<h3><a class='anchor' name='Playing Event Patterns'>Playing Event Patterns</a></h3>

<p>The <a href="#-play">-play</a> method does not return the pattern itself. Instead, it returns the <a href="./../Classes/EventStreamPlayer.html">EventStreamPlayer</a> object that actually runs the pattern. Control instructions -- stop, pause, resume, play, reset -- should be addressed to the EventStreamPlayer. (The same pattern can play many times simultaneously, using different EventStreamPlayers.)<pre class='code prettyprint lang-sc'>p = Pbind(...);
p.play;
p.stop;    // does not stop because p is not the EventStreamPlayer that is actually playing

p = Pbind(...).play;
p.stop;    // DOES stop because p is the EventStreamPlayer</pre>
<h3><a class='anchor' name='Recording Event Patterns'>Recording Event Patterns</a></h3>

<p>Patterns may be recorded in realtime or non-realtime. See the method <a href="#-record">-record</a> for realtime recording.
<p>For non-realtime recording see the <a href="./../Classes/Score.html">Score</a> helpfile, especially "creating Score from a pattern." It can be tricky, because NRT recording launches a new server instance. That server instance is not aware of buffers or other resources loaded into the realtime server you might have been using for tests. The pattern is responsible for (re)loading any resources (buffers, effects etc.). <a href="./../Classes/Pfset.html">Pfset</a> or <a href="./../Classes/Pproto.html">Pproto</a> may be useful.<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3><a class='anchor' name='Inherited class methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asStream' href='./../Overviews/Methods.html#asStream'>asStream</a> </h3>
<div class='method'>
<p>Return a <a href="./../Classes/Stream.html">Stream</a> from this pattern. One pattern can be used to produce any number of independent streams.<pre class='code prettyprint lang-sc'>a = Pgeom(1, Pwhite(1.01, 1.2), inf);
b = a.asStream; c = a.asStream;

b.next;
b.next;
b.next;

c.next; // c is independent from b
c.next;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-embedInStream' href='./../Overviews/Methods.html#embedInStream'>embedInStream</a> (<span class='argstr'>inval</span>)</h3>
<div class='method'>
<p>Given a <a href="./../Classes/Stream.html">Stream</a> like e.g. <a href="./../Classes/Routine.html">Routine</a>, yield all values from this pattern before continuing. One pattern can be used to produce values for any number of independent streams.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>inval<td class='argumentdesc'>
<p>The inval is passed into all substreams and can be used to control how they behave from the outside.<pre class='code prettyprint lang-sc'>a = Pgeom(1, Pwhite(1.01, 1.2), 5);
r = Routine { 2.yield; 3.yield; a.embedInStream; 7.yield; };
r.nextN(12); // the next 12 values from r</pre>
</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-play' href='./../Overviews/Methods.html#play'>play</a> (<span class='argstr'>clock</span>, <span class='argstr'>protoEvent</span>, <span class='argstr'>quant</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>clock<td class='argumentdesc'>
<p>The tempo clock that will run the pattern. If omitted, TempoClock.default is used.<tr><td class='argumentname'>protoEvent<td class='argumentdesc'>
<p>The event prototype that will be fed into the pattern stream on each iteration. If omitted, event.default is used.<tr><td class='argumentname'>quant<td class='argumentdesc'>
<p>see the <a href="./../Classes/Quant.html">Quant</a> helpfile.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-record' href='./../Overviews/Methods.html#record'>record</a> (<span class='argstr'>path</span>, <span class='argstr'>headerFormat: "AIFF"</span>, <span class='argstr'>sampleFormat: "float"</span>, <span class='argstr'>numChannels: 2</span>, <span class='argstr'>dur</span>, <span class='argstr'>fadeTime: 0.2</span>, <span class='argstr'>clock</span>, <span class='argstr'>protoEvent</span>, <span class='argstr'>server</span>, <span class='argstr'>out: 0</span>)</h3>
<div class='method'>
<p>Opens a disk file for recording and plays the pattern into it.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>Disk location for the recorded file. If not given, a filename is generated for you and placed in the default recording directory: <code class='code prettyprint lang-sc'>thisProcess.platform.recordingsDir</code>.<tr><td class='argumentname'>headerFormat<td class='argumentdesc'>
<p>File format, default "AIFF" - see <a href="./../Classes/SoundFile.html">SoundFile</a> for supported header and sample formats.<tr><td class='argumentname'>sampleFormat<td class='argumentdesc'>
<p>Sample format, default "float".<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>Number of channels to recorde, default 2.<tr><td class='argumentname'>dur<td class='argumentdesc'>
<p>How long to run the pattern before stopping. If nil (default), the pattern will run until it finishes on its own; then recording stops. Or, use cmd-period to stop the recording. If a number is given, the pattern will run for that many beats and then stop (using <a href="./../Classes/Pfindur.html">Pfindur</a>), ending the recording as well.<tr><td class='argumentname'>fadeTime<td class='argumentdesc'>
<p>How many beats to allow after the last event before stopping the recording. Default = 0.2.<tr><td class='argumentname'>clock<td class='argumentdesc'>
<p>Which clock to use for play. Uses TempoClock.default if not otherwise specified.<tr><td class='argumentname'>protoEvent<td class='argumentdesc'>
<p>Which event prototype to use for play. Falls back to Event.default if not otherwise specified.<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>Which server to play and record. Server.default if not otherwise specified.<tr><td class='argumentname'>out<td class='argumentdesc'>
<p>Output bus to hear the pattern while recording, default = 0.</table></div><h3><a class='anchor' name='Inherited instance methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h3><a class='anchor' name='Undocumented instance methods'>Undocumented instance methods</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-++' href='./../Overviews/Methods.html#++'>++</a> (<span class='argstr'>aPattern</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-<>' href='./../Overviews/Methods.html#&lt;&gt;'>&lt;&gt;</a> (<span class='argstr'>aPattern</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-addDur' href='./../Overviews/Methods.html#addDur'>addDur</a> (<span class='argstr'>x</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asEventStreamPlayer' href='./../Overviews/Methods.html#asEventStreamPlayer'>asEventStreamPlayer</a> (<span class='argstr'>protoEvent</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asScore' href='./../Overviews/Methods.html#asScore'>asScore</a> (<span class='argstr'>duration: 1</span>, <span class='argstr'>timeOffset: 0</span>, <span class='argstr'>protoEvent</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/Control/asScore/asScore.sc'>/usr/local/share/SuperCollider/SCClassLibrary/Common/Control/asScore/asScore.sc</a></div>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-buildForProxy' href='./../Overviews/Methods.html#buildForProxy'>buildForProxy</a> (<span class='argstr'>proxy</span>, <span class='argstr'>channelOffset: 0</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/JITLib/ProxySpace/wrapForNodeProxy.sc'>/usr/local/share/SuperCollider/SCClassLibrary/JITLib/ProxySpace/wrapForNodeProxy.sc</a></div>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-clump' href='./../Overviews/Methods.html#clump'>clump</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-collect' href='./../Overviews/Methods.html#collect'>collect</a> (<span class='argstr'>function</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-composeBinaryOp' href='./../Overviews/Methods.html#composeBinaryOp'>composeBinaryOp</a> (<span class='argstr'>operator</span>, <span class='argstr'>pattern</span>, <span class='argstr'>adverb</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-composeNAryOp' href='./../Overviews/Methods.html#composeNAryOp'>composeNAryOp</a> (<span class='argstr'>selector</span>, <span class='argstr'>argList</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-composeUnaryOp' href='./../Overviews/Methods.html#composeUnaryOp'>composeUnaryOp</a> (<span class='argstr'>operator</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-ctranspose' href='./../Overviews/Methods.html#ctranspose'>ctranspose</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-db' href='./../Overviews/Methods.html#db'>db</a> (<span class='argstr'>db</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-detune' href='./../Overviews/Methods.html#detune'>detune</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-differentiate' href='./../Overviews/Methods.html#differentiate'>differentiate</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-do' href='./../Overviews/Methods.html#do'>do</a> (<span class='argstr'>function</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-drop' href='./../Overviews/Methods.html#drop'>drop</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-fin' href='./../Overviews/Methods.html#fin'>fin</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-finDur' href='./../Overviews/Methods.html#finDur'>finDur</a> (<span class='argstr'>dur</span>, <span class='argstr'>tolerance: 0.001</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-flatten' href='./../Overviews/Methods.html#flatten'>flatten</a> (<span class='argstr'>n: 1</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-gtranspose' href='./../Overviews/Methods.html#gtranspose'>gtranspose</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-integrate' href='./../Overviews/Methods.html#integrate'>integrate</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-iter' href='./../Overviews/Methods.html#iter'>iter</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-keep' href='./../Overviews/Methods.html#keep'>keep</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-lag' href='./../Overviews/Methods.html#lag'>lag</a> (<span class='argstr'>t</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-legato' href='./../Overviews/Methods.html#legato'>legato</a> (<span class='argstr'>x</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-lock' href='./../Overviews/Methods.html#lock'>lock</a> (<span class='argstr'>n: 1</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/JITLib/Patterns/extRoutine.sc'>/usr/local/share/SuperCollider/SCClassLibrary/JITLib/Patterns/extRoutine.sc</a></div>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-mtranspose' href='./../Overviews/Methods.html#mtranspose'>mtranspose</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-proxyControlClass' href='./../Overviews/Methods.html#proxyControlClass'>proxyControlClass</a> </h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/JITLib/ProxySpace/wrapForNodeProxy.sc'>/usr/local/share/SuperCollider/SCClassLibrary/JITLib/ProxySpace/wrapForNodeProxy.sc</a></div>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-reject' href='./../Overviews/Methods.html#reject'>reject</a> (<span class='argstr'>function</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-repeat' href='./../Overviews/Methods.html#repeat'>repeat</a> (<span class='argstr'>n: inf</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-reverseComposeBinaryOp' href='./../Overviews/Methods.html#reverseComposeBinaryOp'>reverseComposeBinaryOp</a> (<span class='argstr'>operator</span>, <span class='argstr'>pattern</span>, <span class='argstr'>adverb</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-scaleDur' href='./../Overviews/Methods.html#scaleDur'>scaleDur</a> (<span class='argstr'>x</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-select' href='./../Overviews/Methods.html#select'>select</a> (<span class='argstr'>function</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-streamArg' href='./../Overviews/Methods.html#streamArg'>streamArg</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-stretch' href='./../Overviews/Methods.html#stretch'>stretch</a> (<span class='argstr'>x</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-stutter' href='./../Overviews/Methods.html#stutter'>stutter</a> (<span class='argstr'>n</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-trace' href='./../Overviews/Methods.html#trace'>trace</a> (<span class='argstr'>key</span>, <span class='argstr'>printStream</span>, <span class='argstr'>prefix: ""</span>)</h3>
<h2><a class='anchor' name='examples'>Examples</a></h2>

<p>Below are brief examples for most of the classes derived from Pattern. These examples all rely on the patterns assigned to the Interpreter variable p, q, and r in the first block of code.<pre class='code prettyprint lang-sc'>s.boot;

(
SynthDef(\cfstring1, { arg i_out, freq = 360, gate = 1, pan, amp=0.1;
    var out, eg, fc, osc, a, b, w;
    fc = LinExp.kr(LFNoise1.kr(Rand(0.25, 0.4)), -1, 1, 500, 2000);
    osc = Mix.fill(8, {LFSaw.ar(freq * [Rand(0.99, 1.01), Rand(0.99, 1.01)], 0, amp) }).distort * 0.2;
    eg = EnvGen.kr(Env.asr(1, 1, 1), gate, doneAction:2);
    out = eg * RLPF.ar(osc, fc, 0.1);
    #a, b = out;
    Out.ar(i_out, Mix.ar(PanAz.ar(4, [a, b], [pan, pan+0.3])));
}).add;

SynthDef("sinegrain2",
    { arg out=0, freq=440, sustain=0.05, pan;
        var env;
        env = EnvGen.kr(Env.perc(0.01, sustain, 0.3), doneAction:2);
        Out.ar(out, Pan2.ar(SinOsc.ar(freq, 0, env), pan))
    }).add;

p = Pbind(
    [\degree, \dur], Pseq([[0, 0.1], [2, 0.1], [3, 0.1], [4, 0.1], [5, 0.8]], 1),
    \amp, 0.05, \octave, 6, \instrument, \cfstring1, \mtranspose, 0);

q = Pbindf(p, \instrument, \default );

r = Pset(\freq, Pseq([500, 600, 700], 2), q);

)</pre>
<h3><a class='anchor' name='EVENT PATTERNS - patterns that generate or require event streams'>EVENT PATTERNS - patterns that generate or require event streams</a></h3>
<pre class='code prettyprint lang-sc'>// Pbind( ArrayOfPatternPairs )

p = Pbind(
    [\degree, \dur], Pseq([[0, 0.1], [2, 0.1], [3, 0.1], [4, 0.1], [5, 0.8]], 1),
    \amp, 0.05, \octave, 6, \instrument, \cfstring1, \mtranspose, 0);

p.play;

//Ppar(arrayOfPatterns, repeats) - play in parallel

Ppar([Pseq([p], 4), Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

//Ptpar(arrayOfTimePatternPairs, repeats) - play in parallel at different times

Ptpar([1, Pseq([p], 4), 0, Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

// Pbindf( pattern, ArrayOfNamePatternPairs )

q = Pbindf(p, \instrument, \default );
q.play;

//Pfset(function, pattern)
// function constructs an event that is passed to the pattern.asStream

Pfset({ ~freq = Pseq([500, 600, 700], 2).asStream }, q).play;

//Pset(name, valPattern, pattern)
// set one field of the event on an event by event basis (Pmul, Padd are similar)

Pset(\freq, Pseq([500, 600, 700], 2), q).play;

//Psetp(name, valPattern, pattern)
// set once for each iteration of the pattern (Pmulp, Paddp are similar)

r = Pset(\freq, Pseq([500, 600, 700], 2), q);

Psetp(\legato, Pseq([0.01, 1.1], inf), r).play;

//Psetpre(name, valPattern, pattern)
// set before passing the event to the pattern (Pmulpre, Paddpre are similar)

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Psetp(\legato, Pseq([0.01, 1.1], inf), r).play;

//Pstretch(valPattern, pattern)
// stretches durations after

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Pstretch(Pn(Env([0.5, 2, 0.5], [10, 10])), Pn(r)).play;

Pset(\stretch, Pn(Env([0.5, 2, 0.5], [10, 10]) ), Pn(r)).play

//Pstretchp(valPattern, pattern)
// stretches durations after

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Pstretchp(Pn(Env([0.5, 2, 0.5], [10, 10])), r).play;

// Pfindur( duration, pattern ) - play pattern for duration

Pfindur(2, Pn(q, inf)).play;

// PfadeIn( pattern, fadeTime, holdTime, tolerance )
PfadeIn(Pn(q), 3, 0).play(quant: 0);

// PfadeOut( pattern, fadeTime, holdTime, tolerance )
PfadeOut(Pn(q), 3, 0).play(quant: 0);

// Psync( pattern, quantization, dur, tolerance )
// pattern is played for dur seconds (within tolerance), then a rest is played so the next pattern

Pn(Psync(
    Pbind(\dur, Pwhite(0.2, 0.5).round(0.2),
        \db, Pseq([-10, -15, -15, -15, -15, -15, -30])
    ), 2, 3
)).play

//Plag(duration, pattern)

Ppar([Plag(1.2, Pn(p, 4)), Pn(Pbindf(q, \ctranspose, -24), 5)]).play</pre>
<h3><a class='anchor' name='GENERAL PATTERNS that work with both event and value streams'>GENERAL PATTERNS that work with both event and value streams</a></h3>
<pre class='code prettyprint lang-sc'>//Ptrace(pattern, key, printStream) - print the contents of a pattern

r = Psetpre(\freq, Pseq([500, 600, 700], 2), q);

Ptrace(r).play;
Ptrace(r, \freq).play;

(
{ var printStream;
    printStream = CollStream.new;
    Pseq([Ptrace(r, \freq, printStream), Pfunc({printStream.collection.dump; nil }) ]).play;
}.value;
)

//Pseed(seed, pattern) - set the seed of the random number generator
// to force repetion of pseudo-random patterns

Pn(Pseed(44, Pbindf(q, \ctranspose, Pbrown(-3.0, 3.0, 10) ) ) ).play;

//Prout(function) - on exit, the function must return the last value returned by yield
// (otherwise, the pattern cannot be reliably manipulated by other patterns)

Prout({ arg inval;
    inval = p.embedInStream(inval);
    inval = Event.silent(4).yield;
    inval = q.embedInStream(inval);
    inval = r.embedInStream(inval);
    inval;
}).play

//Pfunc(function) - the function should not have calls to embedInStream, use Prout instead.

Pn(Pbindf(q, \legato, Pfunc({ arg inval; if (inval.at(\degree)== 5) {4} {0.2}; })) ).play



// the following patterns control the sequencing and repetition of other patterns

//Pseq(arrayOfPatterns, repeats) - play as a sequence

Pseq([Pseq([p], 4), Pseq([Pbindf(q, \ctranspose, -24)], 5)]).play

//Pser(arrayOfPatterns, num) - play num patterns from the arrayOfPatterns

Pser([p, q, r], 5).play

//Place(arrayOfPatterns, repeats) - similar to Pseq
// but array elements that are themselves arrays are iterated
// embedding the first element on the first repetition, second on the second, etc

Place([[p, q, r], q, r], 5).play

// Pn( pattern, patternRepetitions ) - repeat the pattern n times

Pn(p, 2).play;

// Pfin( eventcount, pattern ) - play n events from the pattern

Pfin(12, Pn(p, inf)).play;

// Pstutter( eventRepetitions, pattern ) - repeat each event from the pattern n times

Pstutter(4, q).play

//Pwhile(function, pattern)

Pwhile({coin(0.5).postln;}, q).play

// Pswitch( patternList, selectPattern ) - when a pattern ends, switch according to select

Pswitch([p, q, r], Pwhite(0, 100)).play

// Pswitch1( patternList, selectPattern ) - on each event switch according to select

Pn(Pswitch1([p, q, r], Pwhite(0, 2))).play

// Prand( patternList, repeats ) - random selection from list
Prand([p, q, r], inf).play

// Pxrand( patternList, repeats ) - random selection from list without repeats
Pxrand([p, q, r], inf).play

// Pwrand( patternList, weights, repeats ) - weighted random selection from list
Pwrand([p, q, r], #[1, 3, 5].normalizeSum, inf).play

// Pwalk( patternList, stepPattern, directionPattern ) - walk through a list of patterns

Pwalk([p, q, r], 1, Pseq([-1, 1], inf)).play

// Pslide(list, repeats, length, step, start)

Pbind(\degree, Pslide(#[1, 2, 3, 4, 5], inf, 3, 1, 0), \dur, 0.2).play

// Pshuf( patternList, repeats ) - random selection from list
Pn(Pshuf([p, q, r, r, p])).play

// Ptuple(list, repeats)

Pbind(\degree, Ptuple([Pwhite(1, -6), Pbrown(8, 15, 2)]),
    \dur, Pfunc({ arg ev; ev.at(\degree).last/80 round: 0.1}),
    \db, Pfunc({ if (coin(0.8)) {-25} {-20} })
).play



// the following patterns can alter the values returned by other patterns

//Pcollect(function, pattern)

Pcollect({ arg inval; inval.use({ ~freq = 1000.rand }); inval}, q).play

//Pselect(function, pattern)

Pselect({ arg inval; inval.at(\degree) != 0 }, q).play(quant: 0)

//Preject(function, pattern)

Preject({ arg inval; inval.at(\degree) != 0 }, q).play(quant: 0)

//Ppatmod(pattern, function, repeats) -
// function receives the current pattern as an argument and returns the next pattern to be played

Ppatmod(p, { arg oldPat; [p, q, r].choose }, inf).play</pre>
<h3><a class='anchor' name='VALUE PATTERNS: these patterns define or act on streams of numbers'>VALUE PATTERNS: these patterns define or act on streams of numbers</a></h3>
<pre class='code prettyprint lang-sc'>// Env as a pattern

Pbindf(Pn(q, inf), \ctranspose, Pn(Env.linen(3, 0, 0.3, 20), inf) ).play;

// Pwhite(lo, hi, length)

Pbindf(Pn(q, inf), \ctranspose, Pwhite(-3.0, 3.0) ).play;

// Pbrown(lo, hi, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pbrown(-3.0, 3.0, 2) ).play;

// Pseries(start, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pseries(0, 0.1, 10) ).play;

// Pgeom(start, step, length)

Pbindf(Pn(q, inf), \ctranspose, Pgeom(1, 1.2, 20) ).play;

// Pwrap(pattern, lo, hi)

Pbind(\note, Pwrap(Pwhite(0, 128), 10, 20).round(2), \dur, 0.05).play;

// PdegreeToKey(pattern, scale, stepsPerOctave)
// this reimplements part of pitchEvent (see Event)

Pbindf(Pn(q, inf), \note, PdegreeToKey(Pbrown(-8, 8, 2), [0, 2, 4, 5, 7, 9, 11]) ).play;

// Prewrite(pattern, dict, levels) - see help page for details.
// (notice use of Env to define a chord progression of sorts...

Pbind(\degree,
    Prewrite(0, ( 0: #[2, 0],
            1: #[0, 0, 1],
            2: #[1, 0, 1]
        ), 4
    ) + Pn(Env([4, 0, 1, 4, 3, 4], [6.4, 6.4, 6.4, 6.4, 6.4], 'step')),
    \dur, 0.2).play

// PdurStutter( repetitionPattern, patternOfDurations ) -
Pbindf(Pn(q), \dur, PdurStutter(
    Pseq(#[1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 3, 4, 5, 7, 15], inf),
    Pseq(#[0.5], inf)
    )
).play;


// Pstep2add( pat1, pat2 )
// Pstep3add( pat1, pat2, pat3 )
// PstepNadd(pat1, pat2, ...)
// PstepNfunc(function, patternArray )
// combine multiple patterns with depth first traversal

Pbind(
    \octave, 4,
    \degree, PstepNadd(
        Pseq([1, 2, 3]),
        Pseq([0, -2, [1, 3], -5]),
        Pshuf([1, 0, 3, 0], 2)
    ),
    \dur, PstepNadd(
        Pseq([1, 0, 0, 1], 2),
        Pshuf([1, 1, 2, 1], 2)
    ).loop * (1/8),
    \legato, Pn(Pshuf([0.2, 0.2, 0.2, 0.5, 0.5, 1.6, 1.4], 4), inf),
    \scale, #[0, 1, 3, 4, 5, 7, 8]
).play;</pre>

<p><div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Classes/Pattern.schelp'>/usr/local/share/SuperCollider/HelpSource/Classes/Pattern.schelp</a><br>link::Classes/Pattern::<br>sc version: 3.8dev</div></div></body></html>
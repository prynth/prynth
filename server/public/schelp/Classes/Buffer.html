<html><head><title>Buffer</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CLASSES</div>
<div id='categories'><a href='./../Browse.html#Server>Abstractions'>Server>Abstractions</a></div>
<h1>Buffer</h1>
<div id='summary'>Client-side representation of a buffer on a server</div>
</div>
<div class='subheader'>
<div id='filename'>Source: /usr/local/share/SuperCollider/SCClassLibrary/Common/Control/<a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/Control/Buffer.sc'>Buffer.sc</a></div><div id='superclasses'>Inherits from: <a href="../Classes/Object.html">Object</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'><li class='toc2'><a href='#Buffer Numbers and Allocation'>Buffer Numbers and Allocation</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Multichannel Buffers'>Multichannel Buffers</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Completion Messages and Action Functions'>Completion Messages and Action Functions</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Bundling'>Bundling</a></li>
<ul class='toc'></ul></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Creation with Immediate Memory Allocation'>Creation with Immediate Memory Allocation</a></li>
<ul class='toc'><li class='toc3'><a href='#*alloc'>alloc</a> </li>
<li class='toc3'><a href='#*allocConsecutive'>allocConsecutive</a> </li>
<li class='toc3'><a href='#*read'>read</a> </li>
<li class='toc3'><a href='#*readChannel'>readChannel</a> </li>
<li class='toc3'><a href='#*readNoUpdate'>readNoUpdate</a> </li>
<li class='toc3'><a href='#*cueSoundFile'>cueSoundFile</a> </li>
<li class='toc3'><a href='#*loadCollection'>loadCollection</a> </li>
<li class='toc3'><a href='#*sendCollection'>sendCollection</a> </li>
<li class='toc3'><a href='#*loadDialog'>loadDialog</a> </li>
</ul><li class='toc2'><a href='#Creation without Immediate Memory Allocation'>Creation without Immediate Memory Allocation</a></li>
<ul class='toc'><li class='toc3'><a href='#*new'>new</a> </li>
</ul><li class='toc2'><a href='#Cached Buffers'>Cached Buffers</a></li>
<ul class='toc'><li class='toc3'><a href='#*cachedBufferAt'>cachedBufferAt</a> </li>
<li class='toc3'><a href='#*cachedBuffersDo'>cachedBuffersDo</a> </li>
</ul><li class='toc2'><a href='#Inherited class methods'>Inherited class methods</a></li>
<li class='toc2'><a href='#Undocumented class methods'>Undocumented class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*freeAll'>freeAll</a> </li>
</ul></ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Variables'>Variables</a></li>
<ul class='toc'><li class='toc3'><a href='#-server'>server</a> </li>
<li class='toc3'><a href='#-bufnum'>bufnum</a> </li>
<li class='toc3'><a href='#-numFrames'>numFrames</a> </li>
<li class='toc3'><a href='#-numChannels'>numChannels</a> </li>
<li class='toc3'><a href='#-sampleRate'>sampleRate</a> </li>
<li class='toc3'><a href='#-path'>path</a> </li>
</ul><li class='toc2'><a href='#Explicit allocation'>Explicit allocation</a></li>
<ul class='toc'><li class='toc3'><a href='#-alloc'>alloc</a>  <a href='#-allocMsg'>allocMsg</a> </li>
<li class='toc3'><a href='#-allocRead'>allocRead</a>  <a href='#-allocReadMsg'>allocReadMsg</a> </li>
<li class='toc3'><a href='#-allocReadChannel'>allocReadChannel</a>  <a href='#-allocReadChannelMsg'>allocReadChannelMsg</a> </li>
</ul><li class='toc2'><a href='#Other methods'>Other methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-read'>read</a>  <a href='#-readMsg'>readMsg</a> </li>
<li class='toc3'><a href='#-readChannel'>readChannel</a>  <a href='#-readChannelMsg'>readChannelMsg</a> </li>
<li class='toc3'><a href='#-cueSoundFile'>cueSoundFile</a>  <a href='#-cueSoundFileMsg'>cueSoundFileMsg</a> </li>
<li class='toc3'><a href='#-write'>write</a>  <a href='#-writeMsg'>writeMsg</a> </li>
<li class='toc3'><a href='#-free'>free</a>  <a href='#-freeMsg'>freeMsg</a> </li>
<li class='toc3'><a href='#-zero'>zero</a>  <a href='#-zeroMsg'>zeroMsg</a> </li>
<li class='toc3'><a href='#-set'>set</a>  <a href='#-setMsg'>setMsg</a> </li>
<li class='toc3'><a href='#-setn'>setn</a>  <a href='#-setnMsg'>setnMsg</a> </li>
<li class='toc3'><a href='#-loadCollection'>loadCollection</a> </li>
<li class='toc3'><a href='#-sendCollection'>sendCollection</a> </li>
<li class='toc3'><a href='#-get'>get</a>  <a href='#-getMsg'>getMsg</a> </li>
<li class='toc3'><a href='#-getn'>getn</a>  <a href='#-getMsg'>getMsg</a> </li>
<li class='toc3'><a href='#-loadToFloatArray'>loadToFloatArray</a> </li>
<li class='toc3'><a href='#-getToFloatArray'>getToFloatArray</a> </li>
<li class='toc3'><a href='#-normalize'>normalize</a>  <a href='#-normalizeMsg'>normalizeMsg</a> </li>
<li class='toc3'><a href='#-fill'>fill</a>  <a href='#-fillMsg'>fillMsg</a> </li>
<li class='toc3'><a href='#-copyData'>copyData</a>  <a href='#-copyMsg'>copyMsg</a> </li>
<li class='toc3'><a href='#-close'>close</a>  <a href='#-closeMsg'>closeMsg</a> </li>
<li class='toc3'><a href='#-plot'>plot</a> </li>
<li class='toc3'><a href='#-play'>play</a> </li>
<li class='toc3'><a href='#-query'>query</a> </li>
<li class='toc3'><a href='#-updateInfo'>updateInfo</a> </li>
</ul><li class='toc2'><a href='#Buffer Fill Commands'>Buffer Fill Commands</a></li>
<ul class='toc'><li class='toc3'><a href='#-gen'>gen</a>  <a href='#-genMsg'>genMsg</a> </li>
<li class='toc3'><a href='#-sine1'>sine1</a>  <a href='#-sine1Msg'>sine1Msg</a> </li>
<li class='toc3'><a href='#-sine2'>sine2</a>  <a href='#-sine2Msg'>sine2Msg</a> </li>
<li class='toc3'><a href='#-sine3'>sine3</a>  <a href='#-sine3Msg'>sine3Msg</a> </li>
<li class='toc3'><a href='#-cheby'>cheby</a>  <a href='#-chebyMsg'>chebyMsg</a> </li>
</ul><li class='toc2'><a href='#Inherited instance methods'>Inherited instance methods</a></li>
<li class='toc2'><a href='#Undocumented instance methods'>Undocumented instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-asBufWithValues'>asBufWithValues</a> </li>
<li class='toc3'><a href='#-asControlInput'>asControlInput</a> </li>
<li class='toc3'><a href='#-asUGenInput'>asUGenInput</a> </li>
<li class='toc3'><a href='#-cache'>cache</a> </li>
<li class='toc3'><a href='#-doOnInfo'>doOnInfo</a> </li>
<li class='toc3'><a href='#-duration'>duration</a> </li>
<li class='toc3'><a href='#-getnMsg'>getnMsg</a> </li>
<li class='toc3'><a href='#-preparePartConv'>preparePartConv</a> </li>
<li class='toc3'><a href='#-queryDone'>queryDone</a> </li>
<li class='toc3'><a href='#-readNoUpdate'>readNoUpdate</a> </li>
<li class='toc3'><a href='#-setnMsgArgs'>setnMsgArgs</a> </li>
<li class='toc3'><a href='#-startFrame'>startFrame</a> </li>
<li class='toc3'><a href='#-streamCollection'>streamCollection</a> </li>
<li class='toc3'><a href='#-uncache'>uncache</a> </li>
</ul></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>

<p>A buffer is most often used to hold sampled audio, such as a soundfile loaded into memory, but can be used to hold other types of data as well. It is a globally available array of floating-point numbers on the server. The Buffer class encapsulates a number of common tasks, OSC messages, and capabilities related to server-side buffers â€“ see the examples lower down this document for many examples of using Buffers for sound playback and recording.
<p>Buffers are commonly used with <a href="./../Classes/PlayBuf.html">PlayBuf</a>, <a href="./../Classes/RecordBuf.html">RecordBuf</a>, <a href="./../Classes/DiskIn.html">DiskIn</a>, <a href="./../Classes/DiskOut.html">DiskOut</a>, <a href="./../Classes/BufWr.html">BufWr</a>, <a href="./../Classes/BufRd.html">BufRd</a>, and other UGens. (See their individual help files for more examples.) Buffers can be freed or altered even while being accessed. See <a href="./../Reference/Server-Architecture.html">Server Architecture</a> for some technical details.
<p>Buffer objects should not be created or modified within a <a href="./../Classes/SynthDef.html">SynthDef</a>. If this is needed, see <a href="./../Classes/LocalBuf.html">LocalBuf</a>.<h3><a class='anchor' name='Buffer Numbers and Allocation'>Buffer Numbers and Allocation</a></h3>

<p>Although the number of buffers on a server is set at the time it is booted, memory must still be allocated within the server app before they can hold values. (At boot time all buffers have a size of 0.)
<p><a href="./../Classes/Server.html">Server</a>-side buffers are identified by number, starting from 0. When using Buffer objects, buffer numbers are automatically allocated from the Server's bufferAllocator, unless you explicitly supply one. When you call <code class='code prettyprint lang-sc'>.free</code> on a Buffer object it will release the buffer's memory on the server, and free the buffer number for future reallocation. See <a href="./../Classes/ServerOptions.html">ServerOptions</a> for details on setting the number of available buffers.
<p>Normally you should not need to supply a buffer number. You should only do so if you are sure you know what you are doing. Similarly, in normal use you should not need to access the buffer number, since instances of Buffer can be used directly as <a href="./../Classes/UGen.html">UGen</a> inputs or <a href="./../Classes/Synth.html">Synth</a> args.<h3><a class='anchor' name='Multichannel Buffers'>Multichannel Buffers</a></h3>

<p>Multichannel buffers interleave their data. Thus the actual number of available values when requesting or setting values by index using methods such as <code class='code prettyprint lang-sc'>set, setn, get, getn</code>, etc., is equal to <code class='code prettyprint lang-sc'>numFrames * numChannels</code>. Indices start at 0 and go up to <code class='code prettyprint lang-sc'>(numFrames * numChannels) - 1</code>. In a two channel buffer for instance, index 0 will be the first value of the first channel, index 1 will be the first value of the second channel, index 2 will be the second value of the first channel, and so on.
<p>In some cases it is simpler to use multiple single channel buffers instead of a single multichannel one.<h3><a class='anchor' name='Completion Messages and Action Functions'>Completion Messages and Action Functions</a></h3>

<p>Many buffer operations (such as reading and writing files) are asynchronous, meaning that they will take an arbitrary amount of time to complete. Asynchronous commands are passed to a background thread on the server so as not to steal CPU time from the audio synthesis thread. Since they can last an aribitrary amount of time it is convenient to be able to specify something else that can be done immediately on completion. The ability to do this is implemented in two ways in Buffer's various methods: completion messages and action functions.
<p>A completion message is a second OSC command which is included in the message which is sent to the server. (See <a href="./../Guides/NodeMessaging.html">Node Messaging</a> for a discussion of OSC messages.) The server will execute this immediately upon completing the first command. An action function is a <a href="./../Classes/Function.html">Function</a> which will be evaluated when the client receives the appropriate reply from the server, indicating that the previous command is done. Action functions are therefore inherently more flexible than completion messages, but slightly less efficient due to the small amount of added latency involved in message traffic. Action functions are passed the Buffer object as an argument when they are evaluated.
<p>With Buffer methods that take a completion message, it is also possible to pass in a function that returns an OSC message. As in action functions this will be passed the Buffer as an argument. It is important to understand however that this function will be evaluated after the Buffer object has been created (so that its bufnum and other details are accessible), but before the corresponding message is sent to the server.<h3><a class='anchor' name='Bundling'>Bundling</a></h3>

<p>Many of the methods below have two versions: a regular one which sends its corresponding message to the server immediately, and one which returns the message in an <a href="./../Classes/Array.html">Array</a> so that it can be added to a bundle. It is also possible to capture the messages generated by the regular methods using Server's automated bundling capabilities. See <a href="./../Classes/Server.html">Server</a> and <a href="./../Guides/Bundled-Messages.html">Bundled Server Messages</a> for more details.<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3><a class='anchor' name='Creation with Immediate Memory Allocation'>Creation with Immediate Memory Allocation</a></h3>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*alloc' href='./../Overviews/Methods.html#alloc'>alloc</a> (<span class='argstr'>server</span>, <span class='argstr'>numFrames</span>, <span class='argstr'>numChannels: 1</span>, <span class='argstr'>completionMessage</span>, <span class='argstr'>bufnum</span>)</h3>
<div class='method'>
<p>Create and return a Buffer and immediately allocate the required memory on the server. The buffer's values will be initialised to 0.0.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffer. The default is the default Server.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels.<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>The number of channels for the Buffer. The default is 1.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.<tr><td class='argumentname'>bufnum<td class='argumentdesc'>
<p>An explicitly specified buffer number. Generally this is not needed.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>// Allocate 8 second stereo buffer
s.boot;
b = Buffer.alloc(s, s.sampleRate * 8.0, 2);
b.free;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*allocConsecutive' href='./../Overviews/Methods.html#allocConsecutive'>allocConsecutive</a> (<span class='argstr'>numBufs: 1</span>, <span class='argstr'>server</span>, <span class='argstr'>numFrames</span>, <span class='argstr'>numChannels: 1</span>, <span class='argstr'>completionMessage</span>, <span class='argstr'>bufnum</span>)</h3>
<div class='method'>
<p>Allocates a range of consecutively-numbered buffers, for use with UGens like <a href="./../Classes/VOsc.html">VOsc</a> and <a href="./../Classes/VOsc3.html">VOsc3</a> that require a contiguous block of buffers, and returns an array of corresponding Buffer objects.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>numBufs<td class='argumentdesc'>
<p>The number of consecutively indexed buffers to allocate.<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffers. The default is the default Server.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to allocate in each buffer. Actual memory use will correspond to numFrames * numChannels.<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>The number of channels for each buffer. The default is 1.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed each Buffer and its index in the array as arguments when evaluated.<tr><td class='argumentname'>bufnum<td class='argumentdesc'>
<p>An explicitly specified buffer number for the initial buffer. Generally this is not needed.</table><h4>Discussion:</h4>

<p>N.B. You must treat the array of Buffers as a group. Freeing them individually or resuing them can result in allocation errors. You should free all Buffers in the array at the same time by iterating over it with do.<pre class='code prettyprint lang-sc'>s.boot;
// allocate an array of Buffers and fill them with different harmonics
(
b = Buffer.allocConsecutive(8, s, 4096, 1, { |buf, i|
    buf.sine1Msg((1..((i+1)*6)).reciprocal) // completion Messages
});

a = { VOsc.ar(SinOsc.kr(0.5, 0).range(b.first.bufnum + 0.1, b.last.bufnum - 0.1),
    [440, 441], 0, 0.2) }.play;
)
a.free;

// iterate over the array and free it
b.do(_.free);</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*read' href='./../Overviews/Methods.html#read'>read</a> (<span class='argstr'>server</span>, <span class='argstr'>path</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>action</span>, <span class='argstr'>bufnum</span>)</h3>
<div class='method'>
<p>Allocate a buffer and immediately read a soundfile into it. This method sends a query message as a completion message so that the Buffer's instance variables will be updated automatically.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffer.<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.<tr><td class='argumentname'>bufnum<td class='argumentdesc'>
<p>An explicitly specified buffer number. Generally this is not needed.</table><h4>Discussion:</h4>

<p>N.B. You cannot rely on the buffer's instance variables being instantly updated, as there is a small amount of latency involved. action will be evaluated upon receipt of the reply to the query, so use this in cases where access to instance variables is needed.<pre class='code prettyprint lang-sc'>// read a soundfile
s.boot;
p = Platform.resourceDir +/+ "sounds/a11wlk01.wav";
b = Buffer.read(s, p);

// now play it
(
x = SynthDef(\help_Buffer, { arg out = 0, bufnum;
    Out.ar( out,
        PlayBuf.ar(1, bufnum, BufRateScale.kr(bufnum))
    )
}).play(s,[\bufnum, b]);
)
x.free; b.free;

// with an action function
// note that the vars are not immediately up-to-date
(
b = Buffer.read(s, p, action: { arg buffer;
    ("After update:" + buffer.numFrames).postln;
    x = { PlayBuf.ar(1, buffer, BufRateScale.kr(buffer)) }.play;
});
("Before update:" + b.numFrames).postln;
)
x.free; b.free;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*readChannel' href='./../Overviews/Methods.html#readChannel'>readChannel</a> (<span class='argstr'>server</span>, <span class='argstr'>path</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>channels</span>, <span class='argstr'>action</span>, <span class='argstr'>bufnum</span>)</h3>
<div class='method'>
<p>As <a href="#*read">*read</a> above, but takes an <a href="./../Classes/Array.html">Array</a> of channel indices to read in, allowing one to read only the selected channels.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffer.<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>channels<td class='argumentdesc'>
<p>An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.<tr><td class='argumentname'>bufnum<td class='argumentdesc'>
<p>An explicitly specified buffer number. Generally this is not needed.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
// first a standard read so we can see what's in the file
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff");
// Platform.resourceDir +/+ "sounds/SinedPink.aiff" contains SinOsc on left, PinkNoise on right
b.plot;
b.free;

// Now just the sine
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [0]);
b.plot;
b.free;

// Now just the pink noise
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [1]);
b.plot;
b.free;

// Now reverse channel order
b = Buffer.readChannel(s, Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [1, 0]);
b.plot;
b.free;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*readNoUpdate' href='./../Overviews/Methods.html#readNoUpdate'>readNoUpdate</a> (<span class='argstr'>server</span>, <span class='argstr'>path</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>bufnum</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>As <a href="#*read">*read</a> above, but without the automatic update of instance variables. Call <code class='code prettyprint lang-sc'>updateInfo</code> (see below) to update the vars.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffer.<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>bufnum<td class='argumentdesc'>
<p>An explicitly specified buffer number. Generally this is not needed.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>// with a completion message
s.boot;
(
SynthDef(\help_Buffer,{ arg out=0, bufnum;
    Out.ar( out,
        PlayBuf.ar(1,bufnum,BufRateScale.kr(bufnum))
    )
}).add;

y = Synth.basicNew(\help_Buffer); // not sent yet
b = Buffer.readNoUpdate(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav",
    completionMessage: { arg buffer;
        // synth add its s_new msg to follow
        // after the buffer read completes
        y.newMsg(s,[\bufnum, buffer],\addToTail)
    });
)
// note vars not accurate
b.numFrames; // nil
b.updateInfo;
b.numFrames; // 188893
// when done...
y.free;
b.free;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*cueSoundFile' href='./../Overviews/Methods.html#cueSoundFile'>cueSoundFile</a> (<span class='argstr'>server</span>, <span class='argstr'>path</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numChannels: 2</span>, <span class='argstr'>bufferSize: 32768</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>Allocate a buffer and preload a soundfile for streaming in using <a href="./../Classes/DiskIn.html">DiskIn</a>.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffer.<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The frame of the soundfile that DiskIn will start playing at.<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>The number of channels in the soundfile.<tr><td class='argumentname'>bufferSize<td class='argumentdesc'>
<p>This must be a multiple of (2 * the server's block size). 32768 is the default and is suitable for most cases.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
(
SynthDef(\help_Buffer_cue,{ arg out=0,bufnum;
    Out.ar(out,
        DiskIn.ar( 1, bufnum )
    )
}).add;
)

(
s.makeBundle(nil, {
    b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav", 0, 1);
    y = Synth(\help_Buffer_cue, [\bufnum, b], s);
});
)
b.free; y.free;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*loadCollection' href='./../Overviews/Methods.html#loadCollection'>loadCollection</a> (<span class='argstr'>server</span>, <span class='argstr'>collection</span>, <span class='argstr'>numChannels: 1</span>, <span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Load a large collection into a buffer on the server. Returns a Buffer object.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to create the buffer.<tr><td class='argumentname'>collection<td class='argumentdesc'>
<p>A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.</table><h4>Discussion:</h4>

<p>This is accomplished through writing the collection to a SoundFile and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use <code class='code prettyprint lang-sc'>sendCollection</code>, below. The file is automatically deleted after loading. This allows for larger collections than setn, below, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it is created.<pre class='code prettyprint lang-sc'>s.boot;
(
a = FloatArray.fill(44100 * 5.0, {1.0.rand2}); // 5 seconds of noise
b = Buffer.loadCollection(s, a);
)

// test it
b.get(20000,{|msg| (msg == a[20000]).postln});
// play it
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 0) * 0.5 }.play;
b.free; x.free;

// interleave a multi-dimensional array
(
l = Signal.sineFill(16384, Array.fill(200, {0}).add(1));
r = Array.fill(16384, {1.0.rand2});
m = [Array.newFrom(l), r]; // a multi-dimensional array
m = m.lace(32768); // interleave the two collections
b = Buffer.loadCollection(s, m, 2, {|buf|
    x = { PlayBuf.ar(2, buf, BufRateScale.kr(buf), loop: 1) * 0.5 }.play;
});
)
b.plot;
x.free; b.free;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*sendCollection' href='./../Overviews/Methods.html#sendCollection'>sendCollection</a> (<span class='argstr'>server</span>, <span class='argstr'>collection</span>, <span class='argstr'>numChannels: 1</span>, <span class='argstr'>wait: -1</span>, <span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Stream a large collection into a buffer on the server using multiple setn messages. Returns a Buffer object.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to create the buffer.<tr><td class='argumentname'>collection<td class='argumentdesc'>
<p>A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>The number of channels that the buffer should have. Note that buffers interleave multichannel data. You are responsible for providing an interleaved collection if needed. Multi-dimensional arrays will not work. See the example in <a href="#*loadCollection">*loadCollection</a> above, to see how to do this.<tr><td class='argumentname'>wait<td class='argumentdesc'>
<p>An optional wait time between sending setn messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.</table><h4>Discussion:</h4>

<p>This allows for larger collections than setn, below. This is not as safe as <a href="#*loadCollection">*loadCollection</a> above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.<pre class='code prettyprint lang-sc'>s.boot;
(
a = Array.fill(2000000,{ rrand(0.0,1.0) }); // a LARGE collection
b = Buffer.sendCollection(s, a, 1, 0, {arg buf; "finished".postln;});
)
b.get(1999999, {|msg| (msg == a[1999999]).postln});
b.free;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*loadDialog' href='./../Overviews/Methods.html#loadDialog'>loadDialog</a> (<span class='argstr'>server</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numFrames</span>, <span class='argstr'>action</span>, <span class='argstr'>bufnum</span>)</h3>
<div class='method'>
<p>As <a href="#*read">*read</a> above, but gives you a load dialog window to browse for a file. Cocoa and SwingOSC compatible.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffer.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.<tr><td class='argumentname'>bufnum<td class='argumentdesc'>
<p>An explicitly specified buffer number. Generally this is not needed.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
(
b = Buffer.loadDialog(s, action: { arg buffer;
    x = { PlayBuf.ar(buffer.numChannels, buffer, BufRateScale.kr(buffer)) }.play;
});
)
x.free; b.free;</pre>
</div><h3><a class='anchor' name='Creation without Immediate Memory Allocation'>Creation without Immediate Memory Allocation</a></h3>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*new' href='./../Overviews/Methods.html#new'>new</a> (<span class='argstr'>server</span>, <span class='argstr'>numFrames</span>, <span class='argstr'>numChannels</span>, <span class='argstr'>bufnum</span>)</h3>
<div class='method'>
<p>Create and return a new Buffer object, without immediately allocating the corresponding memory on the server. This combined with 'message' methods can be flexible with bundles.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>server<td class='argumentdesc'>
<p>The server on which to allocate the buffer. The default is the default Server.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to allocate. Actual memory use will correspond to numFrames * numChannels.<tr><td class='argumentname'>numChannels<td class='argumentdesc'>
<p>The number of channels for the Buffer. The default is 1.<tr><td class='argumentname'>bufnum<td class='argumentdesc'>
<p>An explicitly specified buffer number. Generally this is not needed.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.new(s, 44100 * 8.0, 2);
c = Buffer.new(s, 44100 * 4.0, 2);
b.query; // numFrames = 0
s.sendBundle(nil, b.allocMsg, c.allocMsg); // sent both at the same time
b.query; // now it's right
c.query;
b.free; c.free;</pre>
</div><h3><a class='anchor' name='Cached Buffers'>Cached Buffers</a></h3>

<p>To assist with automatic updates of buffer information (see <code class='code prettyprint lang-sc'>updateInfo</code> and <code class='code prettyprint lang-sc'>read</code>), buffer objects are cached in a collection associated with the <a href="./../Classes/Server.html">Server</a> object hosting the buffers. Freeing a buffer removes it from the cache; quitting the server clears all the cached buffers. (This also occurs if the server crashes unexpectedly.)
<p>You may access cached buffers using the following methods.
<p>It may be simpler to access them through the server object:<pre class='code prettyprint lang-sc'>myServer.cachedBufferAt(bufnum)
myServer.cachedBuffersDo(func)

b = Buffer.alloc(s, 2048, 1);
Buffer.cachedBufferAt(s, 0);    // assuming b has bufnum 0
s.cachedBufferAt(0);            // same result
s.cachedBuffersDo({ |buf| buf.postln });</pre>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*cachedBufferAt' href='./../Overviews/Methods.html#cachedBufferAt'>cachedBufferAt</a> (<span class='argstr'>server</span>, <span class='argstr'>bufnum</span>)</h3>
<div class='method'>
<p>Access a buffer by its number.</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*cachedBuffersDo' href='./../Overviews/Methods.html#cachedBuffersDo'>cachedBuffersDo</a> (<span class='argstr'>server</span>, <span class='argstr'>func</span>)</h3>
<div class='method'>
<p>Iterate over all cached buffers. The iteration is not in any order, but will touch all buffers.</div><h3><a class='anchor' name='Inherited class methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h3><a class='anchor' name='Undocumented class methods'>Undocumented class methods</a></h3>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*freeAll' href='./../Overviews/Methods.html#freeAll'>freeAll</a> (<span class='argstr'>server</span>)</h3>
<h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3><a class='anchor' name='Variables'>Variables</a></h3>

<p>The following variables have getter methods.<h3 class='imethodname'><span class='methprefix'>-</span><a name='-server' href='./../Overviews/Methods.html#server'>server</a> </h3>
<div class='method'>
<p>Returns the Buffer's Server object.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-bufnum' href='./../Overviews/Methods.html#bufnum'>bufnum</a> </h3>
<div class='method'>
<p>Returns the buffer number of the corresponding server-side buffer. In normal use you should not need to access this value, since instances of Buffer can be used directly as UGen inputs or Synth args.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.alloc(s,44100 * 8.0,2);
b.bufnum.postln;
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-numFrames' href='./../Overviews/Methods.html#numFrames'>numFrames</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-numFrames' href='./../Overviews/Methods.html#numFrames'>numFrames</a> = value</h3>
<div class='method'>
<p>Returns the number of sample frames in the corresponding server-side buffer. Note that multichannel buffers interleave their samples, so when dealing with indices in methods like get and getn, the actual number of available values is numFrames * numChannels.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-numChannels' href='./../Overviews/Methods.html#numChannels'>numChannels</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-numChannels' href='./../Overviews/Methods.html#numChannels'>numChannels</a> = value</h3>
<div class='method'>
<p>Returns the number of channels in the corresponding server-side buffer.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sampleRate' href='./../Overviews/Methods.html#sampleRate'>sampleRate</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-sampleRate' href='./../Overviews/Methods.html#sampleRate'>sampleRate</a> = value</h3>
<div class='method'>
<p>Returns the sample rate of the corresponding server-side buffer.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-path' href='./../Overviews/Methods.html#path'>path</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-path' href='./../Overviews/Methods.html#path'>path</a> = value</h3>
<div class='method'>
<p>Returns a string containing the path of a soundfile that has been loaded into the corresponding server-side buffer.</div><h3><a class='anchor' name='Explicit allocation'>Explicit allocation</a></h3>

<p>These methods allocate the necessary memory on the server for a Buffer previously created with <a href="#*new">*new</a>.<h3 class='imethodname'><span class='methprefix'>-</span><a name='-alloc' href='./../Overviews/Methods.html#alloc'>alloc</a> (<span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-allocMsg' href='./../Overviews/Methods.html#allocMsg'>allocMsg</a> (<span class='argstr'>completionMessage</span>)</h3>
<div class='method'><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.new(s, 44100 * 8.0, 2);
b.query; // numFrames = 0
b.alloc;
b.query; // numFrames = 352800
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-allocRead' href='./../Overviews/Methods.html#allocRead'>allocRead</a> (<span class='argstr'>argpath</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-allocReadMsg' href='./../Overviews/Methods.html#allocReadMsg'>allocReadMsg</a> (<span class='argstr'>argpath</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>Read a soundfile into a buffer on the server for a Buffer previously created with <a href="#*new">*new</a>. Note that this will not autoupdate instance variables. Call <code class='code prettyprint lang-sc'>updateInfo</code> in order to do this.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argpath<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.new(s);
b.allocRead(Platform.resourceDir +/+ "sounds/a11wlk01.wav");
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * 0.5 }.play;
x.free; b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-allocReadChannel' href='./../Overviews/Methods.html#allocReadChannel'>allocReadChannel</a> (<span class='argstr'>argpath</span>, <span class='argstr'>startFrame</span>, <span class='argstr'>numFrames: 0</span>, <span class='argstr'>channels: -1</span>, <span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-allocReadChannelMsg' href='./../Overviews/Methods.html#allocReadChannelMsg'>allocReadChannelMsg</a> (<span class='argstr'>argpath</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>channels</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>As <a href="#-allocRead">-allocRead</a> above, but allows you to specify which channels to read.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argpath<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>channels<td class='argumentdesc'>
<p>An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.new(s);
// read only the first channel (a Sine wave) of a stereo file
b.allocReadChannel(Platform.resourceDir +/+ "sounds/SinedPink.aiff", channels: [0]);
x = { PlayBuf.ar(1, b, BufRateScale.kr(b), loop: 1) * 0.5 }.play;
x.free; b.free;</pre>
</div><h3><a class='anchor' name='Other methods'>Other methods</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-read' href='./../Overviews/Methods.html#read'>read</a> (<span class='argstr'>argpath</span>, <span class='argstr'>fileStartFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>bufStartFrame: 0</span>, <span class='argstr'>leaveOpen: false</span>, <span class='argstr'>action</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-readMsg' href='./../Overviews/Methods.html#readMsg'>readMsg</a> (<span class='argstr'>argpath</span>, <span class='argstr'>fileStartFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>bufStartFrame: 0</span>, <span class='argstr'>leaveOpen: false</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>Read a soundfile into an already allocated buffer.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argpath<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>fileStartFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>bufStartFrame<td class='argumentdesc'>
<p>The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer.<tr><td class='argumentname'>leaveOpen<td class='argumentdesc'>
<p>A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskIn you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size). A common number is 32768 frames. cueSoundFile below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.<tr><td class='argumentname'>(completionMessage)<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table><h4>Discussion:</h4>

<p>Note that if the number of frames in the file is greater than the number of frames in the buffer, it will be truncated. Note that readMsg will not auto-update instance variables. Call updateInfo in order to do this.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-readChannel' href='./../Overviews/Methods.html#readChannel'>readChannel</a> (<span class='argstr'>argpath</span>, <span class='argstr'>fileStartFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>bufStartFrame: 0</span>, <span class='argstr'>leaveOpen: false</span>, <span class='argstr'>channels</span>, <span class='argstr'>action</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-readChannelMsg' href='./../Overviews/Methods.html#readChannelMsg'>readChannelMsg</a> (<span class='argstr'>argpath</span>, <span class='argstr'>fileStartFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>bufStartFrame: 0</span>, <span class='argstr'>leaveOpen: false</span>, <span class='argstr'>channels</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>As <a href="#-read">-read</a> above, but allows you to specify which channels to read.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argpath<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>fileStartFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to read. The default is -1, which will read the whole file.<tr><td class='argumentname'>bufStartFrame<td class='argumentdesc'>
<p>The index of the frame in the buffer at which to start reading. The default is 0, which is the beginning of the buffer.<tr><td class='argumentname'>leaveOpen<td class='argumentdesc'>
<p>A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskIn you will want this to be true, as the buffer will be used for streaming the soundfile in from disk. (For this the buffer must have been allocated with a multiple of (2 * synth block size). A common number is 32768 frames. cueSoundFile below, provides a simpler way of doing this.) The default is false which is the correct value for all other cases.<tr><td class='argumentname'>channels<td class='argumentdesc'>
<p>An Array of channels to be read from the soundfile. Indices start from zero. These will be read in the order provided. The number of channels requested must match this Buffer's numChannels.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.<tr><td class='argumentname'>(completionMessage)<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-cueSoundFile' href='./../Overviews/Methods.html#cueSoundFile'>cueSoundFile</a> (<span class='argstr'>path</span>, <span class='argstr'>startFrame</span>, <span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-cueSoundFileMsg' href='./../Overviews/Methods.html#cueSoundFileMsg'>cueSoundFileMsg</a> (<span class='argstr'>path</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>A convenience method to cue a soundfile into the buffer for use with a <a href="./../Classes/DiskIn.html">DiskIn</a>. The buffer must have been allocated with a multiple of (2 * the server's block size) frames. A common size is 32768 frames.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be read.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The first frame of the soundfile to read. The default is 0, which is the beginning of the file.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
//create with cueSoundFile class method
b = Buffer.cueSoundFile(s, Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff", 0, 1);
x = { DiskIn.ar(1, b) }.play;
b.close;    // must call close in between cueing
// now use like named instance method, but different arguments
b.cueSoundFile(Platform.resourceDir +/+ "sounds/a11wlk01-44_1.aiff");
// have to do all this to clean up properly!
x.free; b.close; b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-write' href='./../Overviews/Methods.html#write'>write</a> (<span class='argstr'>path</span>, <span class='argstr'>headerFormat: "aiff"</span>, <span class='argstr'>sampleFormat: "int24"</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>leaveOpen: false</span>, <span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-writeMsg' href='./../Overviews/Methods.html#writeMsg'>writeMsg</a> (<span class='argstr'>path</span>, <span class='argstr'>headerFormat: "aiff"</span>, <span class='argstr'>sampleFormat: "int24"</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>leaveOpen: false</span>, <span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>Write the contents of the buffer to a file. See <a href="./../Classes/SoundFile.html">SoundFile</a> for information on valid values for headerFormat and sampleFormat.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>path<td class='argumentdesc'>
<p>A String representing the path of the soundfile to be written. If no path is given, Buffer writes into the default recording directory with a generic name.<tr><td class='argumentname'>headerFormat<td class='argumentdesc'>
<p>A String.<tr><td class='argumentname'>sampleFormat<td class='argumentdesc'>
<p>A String.<tr><td class='argumentname'>numFrames<td class='argumentdesc'>
<p>The number of frames to write. The default is -1, which will write the whole buffer.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The index of the frame in the buffer from which to start writing. The default is 0, which is the beginning of the buffer.<tr><td class='argumentname'>leaveOpen<td class='argumentdesc'>
<p>A boolean indicating whether or not the Buffer should be left 'open'. For use with DiskOut you will want this to be true. The default is false which is the correct value for all other cases.<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-free' href='./../Overviews/Methods.html#free'>free</a> (<span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-freeMsg' href='./../Overviews/Methods.html#freeMsg'>freeMsg</a> (<span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>Release the buffer's memory on the server and return the bufferID back to the server's buffer number allocator for future reuse.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-zero' href='./../Overviews/Methods.html#zero'>zero</a> (<span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-zeroMsg' href='./../Overviews/Methods.html#zeroMsg'>zeroMsg</a> (<span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>Sets all values in this buffer to 0.0.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-set' href='./../Overviews/Methods.html#set'>set</a> (<span class='argstr'>index</span>, <span class='argstr'>float</span> <span class='argstr'>... morePairs</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-setMsg' href='./../Overviews/Methods.html#setMsg'>setMsg</a> (<span class='argstr'>index</span>, <span class='argstr'>float</span> <span class='argstr'>... morePairs</span>)</h3>
<div class='method'>
<p>Set the value in the buffer at index to be equal to float. Additional pairs of indices and floats may be included in the same message.<h4>Discussion:</h4>

<p>Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to <code class='code prettyprint lang-sc'>numFrames * numChannels</code>. Indices start at 0.<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.alloc(s, 4, 2);
b.set(0, 0.2, 1, 0.3, 7, 0.4); // set the values at indices 0, 1, and 7.
b.getn(0, 8, {|msg| msg.postln});
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-setn' href='./../Overviews/Methods.html#setn'>setn</a> ( <span class='argstr'>... args</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-setnMsg' href='./../Overviews/Methods.html#setnMsg'>setnMsg</a> ( <span class='argstr'>... args</span>)</h3>
<div class='method'>
<p>Set a contiguous range of values in the buffer starting at the index startAt to be equal to the Array of floats or integers, values. The number of values set corresponds to the size of values. Additional pairs of starting indices and arrays of values may be included in the same message.<h4>Discussion:</h4>

<p>Note that multichannel buffers interleave their sample data, therefore the actual number of available values is equal to <code class='code prettyprint lang-sc'>numFrames * numChannels</code>. You are responsible for interleaving the data in values if needed. Multi-dimensional arrays will not work. Indices start at 0.
<p>N.B. The maximum number of values that you can set with a single setn message is 1633 when the server is using UDP as its communication protocol. Use <a href="#-loadCollection">-loadCollection</a> and <a href="#-sendCollection">-sendCollection</a> to set larger ranges of values.<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.alloc(s,16);
b.setn(0, Array.fill(16, { rrand(0,1) }));
b.getn(0, b.numFrames, {|msg| msg.postln});
b.setn(0, [1, 2, 3], 4, [1, 2, 3]);
b.getn(0, b.numFrames, {|msg| msg.postln});
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-loadCollection' href='./../Overviews/Methods.html#loadCollection'>loadCollection</a> (<span class='argstr'>collection</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Load a large collection into this buffer. This is accomplished through writing the collection to a SoundFile and loading it from there. For this reason this method will only work with a server on your local machine. For a remote server use sendCollection, below. The file is automatically deleted after loading.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>collection<td class='argumentdesc'>
<p>A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The index of the frame at which to start loading the collection. The default is 0, which is the start of the buffer.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.</table><h4>Discussion:</h4>

<p>This allows for larger collections than setn, above, and is in general the safest way to get a large collection into a buffer. The sample rate of the buffer will be the sample rate of the server on which it was created. The number of channels and frames will have been determined when the buffer was allocated. You are responsible for making sure that the size of collection is not greater than numFrames, and for interleaving any data if needed.<pre class='code prettyprint lang-sc'>s.boot;
(
v = Signal.sineFill(128, 1.0/[1,2,3,4,5,6]);
b = Buffer.alloc(s, 128);
)
(
b.loadCollection(v, action: {|buf|
    x = { PlayBuf.ar(buf.numChannels, buf, BufRateScale.kr(buf), loop: 1)
        * 0.2 }.play;
});
)
x.free; b.free;

// interleave a multi-dimensional array
(
l = Signal.sineFill(16384, Array.fill(200, {0}).add(1));
r = Array.fill(16384, {1.0.rand2});
m = [Array.newFrom(l), r]; // a multi-dimensional array
m = m.lace(32768); // interleave the two collections
b = Buffer.alloc(s, 16384, 2);
)
(
b.loadCollection(m, 0, {|buf|
    x = { PlayBuf.ar(2, buf, BufRateScale.kr(buf), loop: 1) * 0.5 }.play;
});
)
b.plot;
x.free; b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sendCollection' href='./../Overviews/Methods.html#sendCollection'>sendCollection</a> (<span class='argstr'>collection</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>wait: -1</span>, <span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Stream a large collection into this buffer using multiple setn messages.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>collection<td class='argumentdesc'>
<p>A subclass of Collection (i.e. an Array) containing only floats and integers. Multi-dimensional arrays will not work.<tr><td class='argumentname'>startFrame<td class='argumentdesc'>
<p>The index of the frame at which to start streaming in the collection. The default is 0, which is the start of the buffer.<tr><td class='argumentname'>wait<td class='argumentdesc'>
<p>An optional wait time between sending setn messages. In a high traffic situation it may be safer to set this to something above zero, which is the default.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.</table><h4>Discussion:</h4>

<p>This allows for larger collections than setn. This is not as safe as loadCollection, above, but will work with servers on remote machines. The sample rate of the buffer will be the sample rate of the server on which it is created.<pre class='code prettyprint lang-sc'>s.boot;
(
a = Array.fill(2000000,{ rrand(0.0,1.0) });
b = Buffer.alloc(s, 2000000);
)
b = b.sendCollection(a, action: {arg buf; "finished".postln;});
b.get(1999999, {|msg| (msg == a[1999999]).postln});
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-get' href='./../Overviews/Methods.html#get'>get</a> (<span class='argstr'>index</span>, <span class='argstr'>action</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-getMsg' href='./../Overviews/Methods.html#getMsg'>getMsg</a> (<span class='argstr'>index</span>)</h3>
<div class='method'>
<p>Send a message requesting the value in the buffer at index. action is a Function which will be passed the value as an argument and evaluated when a reply is received.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.alloc(s,16);
b.setn(0, Array.fill(16, { rrand(0.0, 1.0) }));
b.get(0, {|msg| msg.postln});
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-getn' href='./../Overviews/Methods.html#getn'>getn</a> (<span class='argstr'>index</span>, <span class='argstr'>count</span>, <span class='argstr'>action</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-getMsg' href='./../Overviews/Methods.html#getMsg'>getMsg</a> (<span class='argstr'>index</span>)</h3>
<div class='method'>
<p>Send a message requesting the a contiguous range of values of size count starting from index. action is a Function which will be passed the values in an Array as an argument and evaluated when a reply is received. See setn above for an example.<h4>Discussion:</h4>

<p>N.B. The maximum number of values that you can get with a single getn message is 1633 when the server is using UDP as its communication protocol. Use <a href="#-loadToFloatArray">-loadToFloatArray</a> and <a href="#-getToFloatArray">-getToFloatArray</a> to get larger ranges of values.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-loadToFloatArray' href='./../Overviews/Methods.html#loadToFloatArray'>loadToFloatArray</a> (<span class='argstr'>index: 0</span>, <span class='argstr'>count: -1</span>, <span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Write the buffer to a file and then load it into a FloatArray.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>index<td class='argumentdesc'>
<p>The index in the buffer to begin writing from. The default is 0.<tr><td class='argumentname'>count<td class='argumentdesc'>
<p>The number of values to write. The default is -1, which writes from index until the end of the buffer.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function which will be passed the resulting FloatArray as an argument and evaluated when loading is finished.</table><h4>Discussion:</h4>

<p>This is safer than getToFloatArray but only works with a server on your local machine. In general this is the safest way to get a large range of values from a server buffer into the client app.<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// same as Buffer.plot
b.loadToFloatArray(action: { arg array; a = array; {a.plot;}.defer; "done".postln;});
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-getToFloatArray' href='./../Overviews/Methods.html#getToFloatArray'>getToFloatArray</a> (<span class='argstr'>index: 0</span>, <span class='argstr'>count</span>, <span class='argstr'>wait: 0.01</span>, <span class='argstr'>timeout: 3</span>, <span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Stream the buffer to the client using a series of getn messages and put the results into a FloatArray.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>index<td class='argumentdesc'>
<p>The index in the buffer to begin writing from. The default is 0.<tr><td class='argumentname'>count<td class='argumentdesc'>
<p>The number of values to write. The default is -1, which writes from index until the end of the buffer.<tr><td class='argumentname'>wait<td class='argumentdesc'>
<p>The amount of time in seconds to wait between sending getn messages. Longer times are safer. The default is 0.01 seconds which seems reliable under normal circumstances. A setting of 0 is not recommended.<tr><td class='argumentname'>timeout<td class='argumentdesc'>
<p>The amount of time in seconds after which to post a warning if all replies have not yet been received. the default is 3.<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function which will be passed the resulting FloatArray as an argument and evaluated when all replies have been received.</table><h4>Discussion:</h4>

<p>This is more risky than loadToFloatArray but does works with servers on remote machines. In high traffic situations it is possible for data to be lost. If this method has not received all its replies by timeout it will post a warning saying that the method has failed. In general use loadToFloatArray instead wherever possible.<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
// like Buffer.plot
b.getToFloatArray(wait:0.01,action:{arg array; a = array; {a.plot;}.defer;"done".postln;});
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-normalize' href='./../Overviews/Methods.html#normalize'>normalize</a> (<span class='argstr'>newmax: 1</span>, <span class='argstr'>asWavetable: false</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-normalizeMsg' href='./../Overviews/Methods.html#normalizeMsg'>normalizeMsg</a> (<span class='argstr'>newmax: 1</span>, <span class='argstr'>asWavetable: false</span>)</h3>
<div class='method'>
<p>Normalizes the buffer so that the peak absolute value is newmax (which defaults to 1). If your buffer is in Wavetable format then set the asWavetable argument to true.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-fill' href='./../Overviews/Methods.html#fill'>fill</a> (<span class='argstr'>startAt</span>, <span class='argstr'>numFrames</span>, <span class='argstr'>value</span> <span class='argstr'>... more</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-fillMsg' href='./../Overviews/Methods.html#fillMsg'>fillMsg</a> (<span class='argstr'>startAt</span>, <span class='argstr'>numFrames</span>, <span class='argstr'>value</span> <span class='argstr'>... more</span>)</h3>
<div class='method'>
<p>Starting at the index startAt, set the next numFrames to value. Additional ranges may be included in the same message.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-copyData' href='./../Overviews/Methods.html#copyData'>copyData</a> (<span class='argstr'>buf</span>, <span class='argstr'>dstStartAt: 0</span>, <span class='argstr'>srcStartAt: 0</span>, <span class='argstr'>numSamples: -1</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-copyMsg' href='./../Overviews/Methods.html#copyMsg'>copyMsg</a> (<span class='argstr'>buf</span>, <span class='argstr'>dstStartAt: 0</span>, <span class='argstr'>srcStartAt: 0</span>, <span class='argstr'>numSamples: -1</span>)</h3>
<div class='method'>
<p>Starting at the index srcStartAt, copy numSamples samples from this to the destination buffer buf starting at dstStartAt. If numSamples is negative, the maximum number of samples possible is copied. The default is start from 0 in the source and copy the maximum number possible starting at 0 in the destination.<h4>Discussion:</h4>

<p>Note: This method used to be called copy, but this conflicts with the method for object-copying. Therefore Buffer:copy is now intended to create a copy of the client-side Buffer object. Its use for copying buffer data on the server is deprecated. If you see a deprecation warning, the data will still be copied on the server and your code will still work, but you should update your code for the new method name.<pre class='code prettyprint lang-sc'>s.boot;
(
SynthDef(\help_Buffer_copy, { arg out=0, buf;
    Line.ar(0, 0, dur: BufDur.kr(buf), doneAction: 2); // frees itself
    Out.ar(out, PlayBuf.ar(1, buf));
}).add;
)

(
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
c = Buffer.alloc(s, 120000);
)

Synth(\help_Buffer_copy, [\buf, b]);

// copy the whole buffer
b.copyData(c);
Synth(\help_Buffer_copy, [\buf, c]);

// copy some samples
c.zero;
b.copyData(c, numSamples: 4410);
Synth(\help_Buffer_copy, [\buf, c]);

// buffer "compositing"
c.zero;
b.copyData(c, numSamples: 4410);
b.copyData(c, dstStartAt: 4410, numSamples: 15500);
Synth(\help_Buffer_copy, [\buf, c]);

b.free;
c.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-close' href='./../Overviews/Methods.html#close'>close</a> (<span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-closeMsg' href='./../Overviews/Methods.html#closeMsg'>closeMsg</a> (<span class='argstr'>completionMessage</span>)</h3>
<div class='method'>
<p>After using a Buffer with a DiskOut or DiskIn, it is necessary to close the soundfile. Failure to do so can cause problems.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>completionMessage<td class='argumentdesc'>
<p>A valid OSC message or a Function which will return one. A Function will be passed this Buffer as an argument when evaluated.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-plot' href='./../Overviews/Methods.html#plot'>plot</a> (<span class='argstr'>name</span>, <span class='argstr'>bounds</span>, <span class='argstr'>minval</span>, <span class='argstr'>maxval</span>, <span class='argstr'>separately: false</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/GUI/PlusGUI/Math/PlotView.sc'>/usr/local/share/SuperCollider/SCClassLibrary/Common/GUI/PlusGUI/Math/PlotView.sc</a></div>
<div class='method'>
<p>Plot the contents of the Buffer in a GUI window.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>name<td class='argumentdesc'>
<p>The name of the resulting window.<tr><td class='argumentname'>bounds<td class='argumentdesc'>
<p>An instance of Rect determining the size of the resulting view.<tr><td class='argumentname'>minval<td class='argumentdesc'>
<p>the minimum value in the plot<tr><td class='argumentname'>maxval<td class='argumentdesc'>
<p>the maximum value in the plot<tr><td class='argumentname'>parent<td class='argumentdesc'>
<p>a window to place the plot in. If nil, one will be created for you</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.plot;
b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-play' href='./../Overviews/Methods.html#play'>play</a> (<span class='argstr'>loop: false</span>, <span class='argstr'>mul: 1</span>)</h3>
<div class='method'>
<p>Plays the contents of the buffer on the server and returns a corresponding Synth.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>loop<td class='argumentdesc'>
<p>A Boolean indicating whether or not to loop playback. If false the synth will automatically be freed when done. The default is false.<tr><td class='argumentname'>mul<td class='argumentdesc'>
<p>A value by which to scale the output. The default is 1.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.read(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.play; // frees itself
x = b.play(true);
x.free; b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-query' href='./../Overviews/Methods.html#query'>query</a> </h3>
<div class='method'>
<p>Sends a b_query message to the server, asking for a description of this buffer. The results are posted to the post window. Does not update instance vars.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-updateInfo' href='./../Overviews/Methods.html#updateInfo'>updateInfo</a> (<span class='argstr'>action</span>)</h3>
<div class='method'>
<p>Sends a b_query message to the server, asking for a description of this buffer. Upon reply this Buffer's instance variables are automatically updated.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>action<td class='argumentdesc'>
<p>A Function to be evaluated once the file has been read and this Buffer's instance variables have been updated. The function will be passed this Buffer as an argument.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.readNoUpdate(s, Platform.resourceDir +/+ "sounds/a11wlk01.wav");
b.numFrames; // incorrect, shows nil
b.updateInfo({|buf| buf.numFrames.postln; }); // now it's right
b.free;</pre>
</div><h3><a class='anchor' name='Buffer Fill Commands'>Buffer Fill Commands</a></h3>

<p>These correspond to the various b_gen OSC Commands, which fill the buffer with values for use. See <a href="./../Reference/Server-Command-Reference.html">Server Command Reference</a> for more details.<h3 class='imethodname'><span class='methprefix'>-</span><a name='-gen' href='./../Overviews/Methods.html#gen'>gen</a> (<span class='argstr'>genCommand</span>, <span class='argstr'>genArgs</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-genMsg' href='./../Overviews/Methods.html#genMsg'>genMsg</a> (<span class='argstr'>genCommand</span>, <span class='argstr'>genArgs</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<div class='method'>
<p>This is a generalized version of the commands below.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>genCommand<td class='argumentdesc'>
<p>A String indicating the name of the command to use. See Server-Command-Reference for a list of valid command names.<tr><td class='argumentname'>genArgs<td class='argumentdesc'>
<p>An Array containing the corresponding arguments to the command.<tr><td class='argumentname'>normalize<td class='argumentdesc'>
<p>A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.<tr><td class='argumentname'>asWavetable<td class='argumentdesc'>
<p>A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.<tr><td class='argumentname'>clearFirst<td class='argumentdesc'>
<p>A Boolean indicating whether or not to clear the buffer before writing. The default is true.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sine1' href='./../Overviews/Methods.html#sine1'>sine1</a> (<span class='argstr'>amps</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-sine1Msg' href='./../Overviews/Methods.html#sine1Msg'>sine1Msg</a> (<span class='argstr'>amps</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<div class='method'>
<p>Fill this buffer with a series of sine wave harmonics using specified amplitudes.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>amps<td class='argumentdesc'>
<p>An Array containing amplitudes for the harmonics. The first float value specifies the amplitude of the first partial, the second float value specifies the amplitude of the second partial, and so on.<tr><td class='argumentname'>normalize<td class='argumentdesc'>
<p>A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.<tr><td class='argumentname'>asWavetable<td class='argumentdesc'>
<p>A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.<tr><td class='argumentname'>clearFirst<td class='argumentdesc'>
<p>A Boolean indicating whether or not to clear the buffer before writing. The default is true.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
(
b = Buffer.alloc(s, 512, 1);
b.sine1(1.0 / [1, 2, 3, 4], true, true, true);
x = { Osc.ar(b, 200, 0, 0.5) }.play;
)
x.free; b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sine2' href='./../Overviews/Methods.html#sine2'>sine2</a> (<span class='argstr'>freqs</span>, <span class='argstr'>amps</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-sine2Msg' href='./../Overviews/Methods.html#sine2Msg'>sine2Msg</a> (<span class='argstr'>freqs</span>, <span class='argstr'>amps</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<div class='method'>
<p>Fill this buffer with a series of sine wave partials using specified frequencies and amplitudes.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>freqs<td class='argumentdesc'>
<p>An Array containing frequencies (in cycles per buffer) for the partials.<tr><td class='argumentname'>amps<td class='argumentdesc'>
<p>An Array containing amplitudes for the partials. This should contain the same number of items as freqs.<tr><td class='argumentname'>normalize<td class='argumentdesc'>
<p>A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.<tr><td class='argumentname'>asWavetable<td class='argumentdesc'>
<p>A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.<tr><td class='argumentname'>clearFirst<td class='argumentdesc'>
<p>A Boolean indicating whether or not to clear the buffer before writing. The default is true.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>s.boot;
(
b = Buffer.alloc(s, 512, 1);
b.sine2([1.0, 3], [1, 0.5]);
x = { Osc.ar(b, 200, 0, 0.5) }.play;
)
x.free; b.free;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-sine3' href='./../Overviews/Methods.html#sine3'>sine3</a> (<span class='argstr'>freqs</span>, <span class='argstr'>amps</span>, <span class='argstr'>phases</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-sine3Msg' href='./../Overviews/Methods.html#sine3Msg'>sine3Msg</a> (<span class='argstr'>freqs</span>, <span class='argstr'>amps</span>, <span class='argstr'>phases</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<div class='method'>
<p>Fill this buffer with a series of sine wave partials using specified frequencies, amplitudes, and initial phases.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>freqs<td class='argumentdesc'>
<p>An Array containing frequencies (in cycles per buffer) for the partials.<tr><td class='argumentname'>amps<td class='argumentdesc'>
<p>An Array containing amplitudes for the partials. This should contain the same number of items as freqs.<tr><td class='argumentname'>phases<td class='argumentdesc'>
<p>An Array containing initial phase for the partials (in radians). This should contain the same number of items as freqs.<tr><td class='argumentname'>normalize<td class='argumentdesc'>
<p>A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.<tr><td class='argumentname'>asWavetable<td class='argumentdesc'>
<p>A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.<tr><td class='argumentname'>clearFirst<td class='argumentdesc'>
<p>A Boolean indicating whether or not to clear the buffer before writing. The default is true.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-cheby' href='./../Overviews/Methods.html#cheby'>cheby</a> (<span class='argstr'>amplitudes</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-chebyMsg' href='./../Overviews/Methods.html#chebyMsg'>chebyMsg</a> (<span class='argstr'>amplitudes</span>, <span class='argstr'>normalize: true</span>, <span class='argstr'>asWavetable: true</span>, <span class='argstr'>clearFirst: true</span>)</h3>
<div class='method'>
<p>Fill this buffer with a series of Chebyshev polynomials, which can be defined as: <code class='code prettyprint lang-sc'>cheby(n) = amplitude  * cos(n * acos(x))</code>. To eliminate a DC offset when used as a waveshaper, the wavetable is offset so that the center value is zero.
<p>Similar functionality can be found in <a href="./../Classes/Signal.html#*chebyFill">Signal.chebyFill</a> and <a href="./../Classes/Wavetable.html#*chebyFill">Wavetable.chebyFill</a>. If you require Chebyshev polynomials that do not include the offset compensation, it is recommended to use one of these.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>amplitudes<td class='argumentdesc'>
<p>An Array containing amplitudes for the harmonics. The first float value specifies the amplitude for n = 1, the second float value specifies the amplitude for n = 2, and so on.<tr><td class='argumentname'>normalize<td class='argumentdesc'>
<p>A Boolean indicating whether or not to normalize the buffer to a peak value of 1.0. The default is true.<tr><td class='argumentname'>asWavetable<td class='argumentdesc'>
<p>A Boolean indicating whether or not to write to the buffer in wavetable format so that it can be read by interpolating oscillators. The default is true.<tr><td class='argumentname'>clearFirst<td class='argumentdesc'>
<p>A Boolean indicating whether or not to clear the buffer before writing. The default is true.</table><h4>Discussion:</h4>
<div class='note'><span class='notelabel'>NOTE:</span> In previous versions, offsetting (to ensure the center value is zero) was performed incorrectly. This was fixed in version 3.7, so any code that may have relied on the (wrong) behavior may need to be changed. If using a Chebyshev buffer as a waveshaper, the simplest fix is to wrap the <a href="./../Classes/Shaper.html">Shaper</a> in a <a href="./../Classes/LeakDC.html">LeakDC</a> UGen.</div>
<p><pre class='code prettyprint lang-sc'>s.boot;
b = Buffer.alloc(s, 512, 1, {arg buf; buf.chebyMsg([1,0,1,1,0,1])});
(
x = {
    Shaper.ar(
        b,
        SinOsc.ar(300, 0, Line.kr(0,1,6)),
        0.5
    )
}.play;
)
x.free; b.free;</pre>
</div><h3><a class='anchor' name='Inherited instance methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h3><a class='anchor' name='Undocumented instance methods'>Undocumented instance methods</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asBufWithValues' href='./../Overviews/Methods.html#asBufWithValues'>asBufWithValues</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asControlInput' href='./../Overviews/Methods.html#asControlInput'>asControlInput</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asUGenInput' href='./../Overviews/Methods.html#asUGenInput'>asUGenInput</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-cache' href='./../Overviews/Methods.html#cache'>cache</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-doOnInfo' href='./../Overviews/Methods.html#doOnInfo'>doOnInfo</a><h3 class='imethodname'><span class='methprefix'>-</span><a name='-doOnInfo' href='./../Overviews/Methods.html#doOnInfo'>doOnInfo</a> = value</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-duration' href='./../Overviews/Methods.html#duration'>duration</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-getnMsg' href='./../Overviews/Methods.html#getnMsg'>getnMsg</a> (<span class='argstr'>index</span>, <span class='argstr'>count</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-preparePartConv' href='./../Overviews/Methods.html#preparePartConv'>preparePartConv</a> (<span class='argstr'>buf</span>, <span class='argstr'>fftsize</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/Audio/PartConv.sc'>/usr/local/share/SuperCollider/SCClassLibrary/Common/Audio/PartConv.sc</a></div>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-queryDone' href='./../Overviews/Methods.html#queryDone'>queryDone</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-readNoUpdate' href='./../Overviews/Methods.html#readNoUpdate'>readNoUpdate</a> (<span class='argstr'>argpath</span>, <span class='argstr'>fileStartFrame: 0</span>, <span class='argstr'>numFrames: -1</span>, <span class='argstr'>bufStartFrame: 0</span>, <span class='argstr'>leaveOpen: false</span>, <span class='argstr'>completionMessage</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-setnMsgArgs' href='./../Overviews/Methods.html#setnMsgArgs'>setnMsgArgs</a> ( <span class='argstr'>... args</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-startFrame' href='./../Overviews/Methods.html#startFrame'>startFrame</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-startFrame' href='./../Overviews/Methods.html#startFrame'>startFrame</a> = value</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-streamCollection' href='./../Overviews/Methods.html#streamCollection'>streamCollection</a> (<span class='argstr'>collstream</span>, <span class='argstr'>collsize</span>, <span class='argstr'>startFrame: 0</span>, <span class='argstr'>wait: -1</span>, <span class='argstr'>action</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-uncache' href='./../Overviews/Methods.html#uncache'>uncache</a> </h3>
<div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Classes/Buffer.schelp'>/usr/local/share/SuperCollider/HelpSource/Classes/Buffer.schelp</a><br>link::Classes/Buffer::<br>sc version: 3.8dev</div></div></body></html>
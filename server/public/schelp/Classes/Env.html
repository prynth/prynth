<!doctype html><html lang='en'><head><title>Env | SuperCollider 3.11.2 Help</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../codemirror.css' type='text/css' />
<link rel='stylesheet' href='./../editor.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta name='viewport' content='width=device-width, initial-scale=1'>
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../lib/jquery.min.js'></script>
<script src='./../lib/codemirror-5.39.2.min.js' type='text/javascript'></script>
<script src='./../lib/codemirror-addon-simple-5.39.2.min.js' type='text/javascript'></script>
<script>
var helpRoot = './..';
var scdoc_title = 'Env';
var scdoc_sc_version = '3.11.2';
</script>
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='qrc:///qtwebchannel/qwebchannel.js' type='text/javascript'></script>
</head>
<body onload='fixTOC()'>
<div id='toc'>
<div id='toctitle'>Env:</div>
<span class='toc_search'>Filter: <input id='toc_search'></span><ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*new'>new</a> </li>
<li class='toc3'><a href='#*newClear'>newClear</a> </li>
<li class='toc3'><a href='#*shapeNames'>shapeNames</a> </li>
<li class='toc3'><a href='#*shapeNumber'>shapeNumber</a> </li>
<li class='toc2'><a href='#Standard%20Shape%20Envelope%20Creation%20Methods'>Standard Shape Envelope Creation Methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*linen'>linen</a> </li>
<li class='toc3'><a href='#*triangle'>triangle</a> </li>
<li class='toc3'><a href='#*sine'>sine</a> </li>
<li class='toc3'><a href='#*perc'>perc</a> </li>
<li class='toc3'><a href='#*pairs'>pairs</a> </li>
<li class='toc3'><a href='#*xyc'>xyc</a> </li>
</ul><li class='toc2'><a href='#Sustained%20Envelope%20Creation%20Methods'>Sustained Envelope Creation Methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*step'>step</a> </li>
<li class='toc3'><a href='#*adsr'>adsr</a> </li>
<li class='toc3'><a href='#*dadsr'>dadsr</a> </li>
<li class='toc3'><a href='#*asr'>asr</a> </li>
<li class='toc3'><a href='#*cutoff'>cutoff</a> </li>
<li class='toc3'><a href='#*circle'>circle</a> </li>
</ul><li class='toc2'><a href='#Multichannel%20expansion'>Multichannel expansion</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Inherited%20class%20methods'>Inherited class methods</a></li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-ar'>ar</a>  <a href='#-kr'>kr</a> </li>
<li class='toc3'><a href='#-blend'>blend</a> </li>
<li class='toc3'><a href='#-delay'>delay</a> </li>
<li class='toc3'><a href='#-duration'>duration</a> </li>
<li class='toc3'><a href='#-totalDuration'>totalDuration</a> </li>
<li class='toc3'><a href='#-circle'>circle</a> </li>
<li class='toc3'><a href='#-test'>test</a> </li>
<li class='toc3'><a href='#-plot'>plot</a> </li>
<li class='toc3'><a href='#-asSignal'>asSignal</a> </li>
<li class='toc3'><a href='#-asArray'>asArray</a> </li>
<li class='toc3'><a href='#-asMultichannelArray'>asMultichannelArray</a> </li>
<li class='toc3'><a href='#-isSustained'>isSustained</a> </li>
<li class='toc3'><a href='#-range'>range</a>  <a href='#-exprange'>exprange</a>  <a href='#-curverange'>curverange</a> </li>
<li class='toc2'><a href='#Client-side%20Access%20and%20Stream%20Support'>Client-side Access and Stream Support</a></li>
<ul class='toc'><li class='toc3'><a href='#-at'>at</a> </li>
<li class='toc3'><a href='#-embedInStream'>embedInStream</a> </li>
<li class='toc3'><a href='#-asStream'>asStream</a> </li>
</ul><li class='toc2'><a href='#Inherited%20instance%20methods'>Inherited instance methods</a></li>
<li class='toc2'><a href='#Undocumented%20instance%20methods'>Undocumented instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-=='>==</a> </li>
<li class='toc3'><a href='#-array'>array</a> </li>
<li class='toc3'><a href='#-asArrayForInterpolation'>asArrayForInterpolation</a> </li>
<li class='toc3'><a href='#-asControlInput'>asControlInput</a> </li>
<li class='toc3'><a href='#-asMultichannelSignal'>asMultichannelSignal</a> </li>
<li class='toc3'><a href='#-asOSCArgEmbeddedArray'>asOSCArgEmbeddedArray</a> </li>
<li class='toc3'><a href='#-asPseg'>asPseg</a> </li>
<li class='toc3'><a href='#-curveValue'>curveValue</a> </li>
<li class='toc3'><a href='#-curves'>curves</a> </li>
<li class='toc3'><a href='#-discretize'>discretize</a> </li>
<li class='toc3'><a href='#-hash'>hash</a> </li>
<li class='toc3'><a href='#-levels'>levels</a> </li>
<li class='toc3'><a href='#-loopNode'>loopNode</a> </li>
<li class='toc3'><a href='#-offset'>offset</a> </li>
<li class='toc3'><a href='#-releaseNode'>releaseNode</a> </li>
<li class='toc3'><a href='#-releaseTime'>releaseTime</a> </li>
<li class='toc3'><a href='#-times'>times</a> </li>
</ul></ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'><li class='toc2'><a href='#blend'>blend</a></li>
<ul class='toc'></ul></ul></ul></div><div id='menubar'></div>
<div class='contents'>
<div class='header'>
<div id='label'>
<span id='folder'>Classes</span>
 | <span id='categories'><a href='./../Browse.html#Control'>Control</a> | <a href='./../Browse.html#Envelopes'>Envelopes</a></span>
</div><h1>Env<span id='superclasses'> : <a href="../Classes/Object.html">Object</a></span>
</h1>
<div id='summary'>Specification for a segmented envelope</div>
</div>
<div class='subheader'>
<div id='filename'>Source: <a href='file:///usr/share/SuperCollider/SCClassLibrary/Common/Audio/Env.sc' title='/usr/share/SuperCollider/SCClassLibrary/Common/Audio/Env.sc'>Env.sc</a></div><div id='subclasses'>Subclasses: <a href="../Classes/Penv.html">Penv</a></div>
<div id='related'>See also: <a href="./../Classes/EnvGen.html">EnvGen</a>, <a href="./../Classes/IEnvGen.html">IEnvGen</a>, <a href="./../Classes/Pseg.html">Pseg</a></div>
</div>
<h2><a class='anchor' name='description'>Description</a></h2>

<p>An Env is a specification for a segmented envelope. Envs can be used both server-side, by an <a href="./../Classes/EnvGen.html">EnvGen</a> or an <a href="./../Classes/IEnvGen.html">IEnvGen</a> within a <a href="./../Classes/SynthDef.html">SynthDef</a>, and clientside, with methods such as <a href="#-at">-at</a> and <a href="#-asStream">-asStream</a>, below.
<p>An Env can have any number of segments which can stop at a particular value or loop several segments when sustaining. It can have several shapes for its segments.
<p>The envelope is conceived as a sequence of <em>nodes</em> (not to be confused with a synthesis-Node) : the first node gives the initial level of the envelope, and the following have three parameters: a target level, a time duration from the previous node, and a shape. The three parameters for each node are kept in separate arrays as explained below.<textarea class='editor'>Env.new(levels: [0, 1, 0.9, 0], times: [0.1, 0.5, 1], curve: [-5, 0, -5]).plot;</textarea>

<p>In this envelope, there are four <em>nodes</em> :<ul>
<li>the first <em>node</em> is the initial level of the envelope : 0 <li>the second <em>node</em> has level 1 and is reached in 0.1 second<li>the third <em>nodes</em> has level 0.9 and is reached in 0.5 second<li>the fourth <em>nodes</em> has level 0 and is reached in 1 second</ul>

<p>Close attention must be paid when retriggering envelopes. Starting from their value at the moment of retrigger, envelopes will cycle through all of their nodes, with the exception of the first. The first node is an envelope's initial value and is only output prior to the initial trigger.<textarea class='editor'>(
{
    EnvGen.kr(
        Env(
            levels: [0, 0.1, 0.2, 0.3], 
            times: [0.1, 0.1, 0.1],
            curve: 8
        ),
        gate: Impulse.kr(3)
    );
}.plot(duration: 1);
)</textarea>

<p>In the above example, the initial level (0) is never repeated. When retriggered, the envelope moves from its current value (0.3), to the value of the second node (0.1), and so forth.<div class='note'><span class='notelabel'>NOTE:</span> In some situations we deal with control points or breakpoints. If these control points have associated x positions (say in an envelope GUI, see <a href="./../Classes/EnvelopeView.html">EnvelopeView</a>) they must be converted to time differences between points to be used as nodes in a Env object. The methods <a href="#*xyc">*xyc</a> and <a href="#*pairs">*pairs</a> can be used to specify an envelope in terms of points.</div><textarea class='editor'>// an envelope in a synth
(
{
    var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]);
    SinOsc.ar(470) * EnvGen.kr(env, doneAction: Done.freeSelf)
}.play
)
// an envelope to control a parameter in a pattern
(
Pbind(
    \note,  Env([0, 12, 6, 13, 0], [1, 5, 2, 10]),
    \dur, 0.1
).play
)</textarea>
<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*new' href='./../Overviews/Methods.html#new'>new</a>(<span class='argstr'>levels: [ 0, 1, 0 ]</span>, <span class='argstr'>times: [ 1, 1 ]</span>, <span class='argstr'>curve: 'lin'</span>, <span class='argstr'>releaseNode</span>, <span class='argstr'>loopNode</span>, <span class='argstr'>offset: 0</span>)</h3>
<div class='method'>
<p>Create a new envelope specification.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>levels<td class='argumentdesc'>
<p>an array of levels. The first value is the initial level of the envelope. When the envelope is used with an EnvGen, levels can be any UGen (new level values are updated only when the envelope has reached that point). When the array of levels contains itself an array, the envelope returns a multichannel output (for a discussion, see <a href="#Multichannel%20expansion">Multichannel expansion</a>)<tr><td class='argumentname'>times<td class='argumentdesc'>
<p>an array of durations of segments in seconds. There should be one fewer duration than there are levels, but if shorter, the array is extended by wrapping around the given values.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>a <a href="./../Classes/Symbol.html">Symbol</a>, <a href="./../Classes/Float.html">Float</a>, or an <a href="./../Classes/Array.html">Array</a> of those. Determines the shape of the envelope segments.
<p>The possible values are:<table>
<tr><td><code>\step</code><td><td>flat segments (immediately jumps to final value)<tr><td><code>\hold</code><td><td>flat segments (holds initial value, jump to final value at the end of the segment)<tr><td><code>\linear</code><td><code>\lin</code><td>linear segments, the default<tr><td><code>\exponential</code><td><code>\exp</code><td>natural exponential growth and decay. In this case, the levels must all be nonzero and have the same sign.<tr><td><code>\sine</code><td><code>\sin</code><td>sinusoidal S shaped segments.<tr><td><code>\welch</code><td><code>\wel</code><td>sinusoidal segments shaped like the sides of a Welch window.<tr><td><code>\squared</code><td><code>\sqr</code><td>squared segment<tr><td><code>\cubed</code><td><code>\cub</code><td>cubed segment<tr><td>a <a href="./../Classes/Float.html">Float</a><td><td>a curvature value for all segments. 0 means linear, positive and negative numbers curve the segment up and down.<tr><td>an <a href="./../Classes/Array.html">Array</a> of symbols or floats<td><td>curvature values for each segment.</table>
<tr><td class='argumentname'>releaseNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. The envelope will sustain at the releaseNode until released.<textarea class='editor'>(
{
    EnvGen.kr(
        Env.new(
            levels: [0, 1, 0.5, 0], 
            times: [0.01, 0.01, 0.01],
            releaseNode: 2 // sustains at level 0.5 until gate is closed
        ), 
        gate: Trig.kr(Impulse.kr(3), dur: 0.3)
    );
}.plot(duration: 1);
)</textarea>

<p>In the above example, the release node is set to the third node, which means it will sustain at the level of 0.5 until it is released. The envelope will then continue on until its last node is reached.<tr><td class='argumentname'>loopNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. Creates a segment of looping nodes. You must specify a releaseNode in order for loopNode to have any effect. The loopNode is the initial node of the loop and is never repeated. Upon reaching the releaseNode, the envelope will move back to the node that immediately follows loopNode. The envelope will loop until its gate is closed. When released, a looping envelope will move from its current position to the node that immediately follows releaseNode and continue until the end.<textarea class='editor'>(
{
    EnvGen.kr(
        Env([0, 1, 0, 0.2, 0, 0.5, 0.8, 0], [0.01, 0.01, 0.01, 0.01, 0.01, 0.01, 0.01], releaseNode: 5, loopNode: 1),
        gate: Trig.kr(1, 0.9)
    );
}.plot(duration: 1)
)</textarea>

<p>In this example :<ul>
<li>the starting level of the envelope is 0<li>the loop goes from nodes[5] (value : 0.5) to the nodes[1+1] (value : 0)<li>at time = 0.9, the loop is released, so the envelope goes to nodes[5+1] (value : 0.8)</ul>
<tr><td class='argumentname'>offset<td class='argumentdesc'>
<p>an offset to all time values (only applies in <a href="./../Classes/IEnvGen.html">IEnvGen</a>).</table><h4>Discussion:</h4>
<textarea class='editor'>(
{
    var env = Env([0.0, 0.5, 0.0, 1.0, 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
    var envgen = EnvGen.ar(env, doneAction: Done.freeSelf);
    SinOsc.ar(
        envgen * 1000 + 440
    ) * envgen * 0.1
}.play
);</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*newClear' href='./../Overviews/Methods.html#newClear'>newClear</a>(<span class='argstr'>numSegments: 8</span>, <span class='argstr'>numChannels: 1</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification with <strong>numSegments</strong> and <strong>numChannels</strong> for filling in later.<h4>Discussion:</h4>

<p>This can be useful when passing Env parameters as args to a <a href="./../Classes/Synth.html">Synth</a>. Note that the maximum number of segments is fixed and cannot be changed once embedded in a <a href="./../Classes/SynthDef.html">SynthDef</a>. Trying to set an Env with more segments than then this may result in other args being unexpectedly set.<textarea class='editor'>(
SynthDef(\help_Env_newClear, { |out = 0, gate = 1|
    var env, envctl;
    // make an empty 4 segment envelope
    env = Env.newClear(4);
    // create a control argument array
    envctl = \env.kr(env.asArray);
    Out.ar(out, SinOsc.ar(EnvGen.kr(envctl, gate), 0) * -12.dbamp);
}).add;
)

Synth(\help_Env_newClear, [\env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

// reset then play again:
Synth(\help_Env_newClear, [ \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

// the same written as an event:
(instrument: \help_Env_newClear, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*shapeNames' href='./../Overviews/Methods.html#shapeNames'>shapeNames</a></h3>
<div class='method'>
<p>returns the dictionary containing the available shapes for the envelopes' curves</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*shapeNumber' href='./../Overviews/Methods.html#shapeNumber'>shapeNumber</a>(<span class='argstr'>shapeName</span>)</h3>
<div class='method'>
<p>returns the index in the dictionary of the given curve shape<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>shapeName<td class='argumentdesc'>
<p>name of the shape. e.g. \lin, \cub ...</table></div><h3><a class='anchor' name='Standard%20Shape%20Envelope%20Creation%20Methods'>Standard Shape Envelope Creation Methods</a></h3>

<p>The following class methods create some frequently used envelope shapes based on supplied durations.<h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*linen' href='./../Overviews/Methods.html#linen'>linen</a>(<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>sustainTime: 1.0</span>, <span class='argstr'>releaseTime: 1.0</span>, <span class='argstr'>level: 1.0</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has a trapezoidal shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>sustainTime<td class='argumentdesc'>
<p>the duration of the sustain portion.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the level of the sustain portion.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>Env.linen(0.1, 0.2, 0.1, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6, \sine).test.plot;
Env.linen(1, 2, 3, 0.6, \welch).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, [[\sine, \welch, \lin, \exp]]).plot;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*triangle' href='./../Overviews/Methods.html#triangle'>triangle</a>(<span class='argstr'>dur: 1.0</span>, <span class='argstr'>level: 1.0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has a triangle shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>dur<td class='argumentdesc'>
<p>the duration of the envelope.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>Env.triangle(1, 1).test.plot;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*sine' href='./../Overviews/Methods.html#sine'>sine</a>(<span class='argstr'>dur: 1.0</span>, <span class='argstr'>level: 1.0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has a hanning window shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>dur<td class='argumentdesc'>
<p>the duration of the envelope.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>Env.sine(1, 1).test.plot;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*perc' href='./../Overviews/Methods.html#perc'>perc</a>(<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>releaseTime: 1.0</span>, <span class='argstr'>level: 1.0</span>, <span class='argstr'>curve: -4.0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which (usually) has a percussive shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>Env.perc(0.05, 1, 1, -4).test.plot;
Env.perc(0.001, 1, 1, -4).test.plot;    // sharper attack
Env.perc(0.001, 1, 1, -8).test.plot;    // change curvature
Env.perc(1, 0.01, 1, 4).test.plot;    // reverse envelope</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*pairs' href='./../Overviews/Methods.html#pairs'>pairs</a>(<span class='argstr'>pairs</span>, <span class='argstr'>curve</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification from coordinates / control points<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>pairs<td class='argumentdesc'>
<p>an array of pairs [[time, level], ...]
<p>if possible, pairs are sorted regarding their point in time<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>Env.pairs([[0, 1], [2.1, 0.5],  [3, 1.4]], \exp).plot;
Env.pairs([[0, 1], [3, 1.4], [2.1, 0.5], [3, 4]], \exp).plot; // *if possible*, pairs are sorted according to time
Env.pairs({ { 1.0.rand } ! 2 } ! 16, \exp).plot;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*xyc' href='./../Overviews/Methods.html#xyc'>xyc</a>(<span class='argstr'>xyc</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification from coordinates / control points with curvature.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>xyc<td class='argumentdesc'>
<p>an array of triplets [[time, level, curve], ...]
<p>if possible, pairs are sorted regarding their point in time</table><h4>Discussion:</h4>
<textarea class='editor'>Env.xyc([[0, 1, \sin], [2.1, 0.5, \lin],  [3, 1.4, \lin]]).plot;
Env.xyc([[2.1, 0.5, \lin], [0, 1, \sin], [3, 1.4, \lin]]).plot; // *if possible*, pairs are sorted according to time
Env.xyc({ [1.0.rand, 10.0.rand, -4.rand2] } ! 16, \exp).plot;</textarea>
</div><h3><a class='anchor' name='Sustained%20Envelope%20Creation%20Methods'>Sustained Envelope Creation Methods</a></h3>

<p>The following methods create some frequently used envelope shapes which have a sustain segment. They are typically used in SynthDefs in situations where at the time of starting the synth it is not known when it will end. Typical cases are external interfaces, midi input, or quickly varying TempoClock.<textarea class='editor'>(
SynthDef(\env_help, { |out, gate = 1, amp = 0.1, release = 0.1|
    var env = Env.adsr(0.02, release, amp);
    var gen = EnvGen.kr(env, gate, doneAction: Done.freeSelf);
    Out.ar(out, PinkNoise.ar(1 ! 2) * gen)
}).add
);

a = Synth(\env_help);
b = Synth(\env_help, [\release, 2]);
a.set(\gate, 0); // alternatively, you can write a.release;
b.set(\gate, 0);</textarea>
<h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*step' href='./../Overviews/Methods.html#step'>step</a>(<span class='argstr'>levels: [ 0, 1 ]</span>, <span class='argstr'>times: [ 1, 1 ]</span>, <span class='argstr'>releaseNode</span>, <span class='argstr'>loopNode</span>, <span class='argstr'>offset: 0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification where all the segments are horizontal lines. Given n values of times only n levels need to be provided, corresponding to the fixed value of each segment.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>levels<td class='argumentdesc'>
<p>an array of levels. Levels can be any UGen (new level values are updated only when the envelope has reached that point). When the array of levels contains itself an array, the envelope returns a multichannel output (for a discussion, see <a href="#Multichannel%20expansion">Multichannel expansion</a>)<tr><td class='argumentname'>times<td class='argumentdesc'>
<p>an array of durations of segments in seconds. It should be the same size as the levels array.<tr><td class='argumentname'>releaseNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. The envelope will sustain at the release node until released.<tr><td class='argumentname'>loopNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. If not nil the output will loop through those nodes starting at the loop node to the node immediately preceding the release node, before back to the loop node, and so on. Note that the envelope only transitions to the release node when released. Examples are below. The loop is escaped when a gate signal is sent, when the output transitions to the release node, as described below.<tr><td class='argumentname'>offset<td class='argumentdesc'>
<p>an offset to all time values (only applies in <a href="./../Classes/IEnvGen.html">IEnvGen</a>).</table><h4>Discussion:</h4>
<textarea class='editor'>(
{
    var env = Env.step([0, 3, 5, 2, 7, 3, 0, 3, 4, 0], [0.5, 0.1, 0.2, 1.0, 1.5, 2, 0.2, 0.1, 0.2, 0.1]);
    var envgen = EnvGen.kr(env);
    var freq = (envgen + 60).midicps;
    SinOsc.ar(freq) * 0.1
}.play
);</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*adsr' href='./../Overviews/Methods.html#adsr'>adsr</a>(<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>decayTime: 0.3</span>, <span class='argstr'>sustainLevel: 0.5</span>, <span class='argstr'>releaseTime: 1.0</span>, <span class='argstr'>peakLevel: 1.0</span>, <span class='argstr'>curve: -4.0</span>, <span class='argstr'>bias: 0.0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which is shaped like traditional analog attack-decay-sustain-release (adsr) envelopes.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>decayTime<td class='argumentdesc'>
<p>the duration of the decay portion.<tr><td class='argumentname'>sustainLevel<td class='argumentdesc'>
<p>the level of the sustain portion as a ratio of the peak level.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>peakLevel<td class='argumentdesc'>
<p>the peak level of the envelope.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.<tr><td class='argumentname'>bias<td class='argumentdesc'>
<p>offset</table><h4>Discussion:</h4>
<textarea class='editor'>Env.adsr(0.02, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(0.45).plot;    // release after 0.45 sec</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*dadsr' href='./../Overviews/Methods.html#dadsr'>dadsr</a>(<span class='argstr'>delayTime: 0.1</span>, <span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>decayTime: 0.3</span>, <span class='argstr'>sustainLevel: 0.5</span>, <span class='argstr'>releaseTime: 1.0</span>, <span class='argstr'>peakLevel: 1.0</span>, <span class='argstr'>curve: -4.0</span>, <span class='argstr'>bias: 0.0</span>)</h3>
<div class='method'>
<p>As <a href="#*adsr">*adsr</a> above, but with its onset delayed by <strong>delayTime</strong> in seconds. The default delay is 0.1.</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*asr' href='./../Overviews/Methods.html#asr'>asr</a>(<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>sustainLevel: 1.0</span>, <span class='argstr'>releaseTime: 1.0</span>, <span class='argstr'>curve: -4.0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which is shaped like traditional analog attack-sustain-release (asr) envelopes.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>sustainLevel<td class='argumentdesc'>
<p>the level of the sustain portion as a ratio of the peak level.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>Env.asr(0.02, 0.5, 1, -4).test(2).plot;
Env.asr(0.001, 0.5, 1, -4).test(2).plot; // sharper attack
Env.asr(0.02, 0.5, 1, 'linear').test(2).plot; // linear segments</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*cutoff' href='./../Overviews/Methods.html#cutoff'>cutoff</a>(<span class='argstr'>releaseTime: 0.1</span>, <span class='argstr'>level: 1.0</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has no attack segment. It simply sustains at the peak level until released. Useful if you only need a fadeout, and more versatile than <a href="./../Classes/Line.html">Line</a>.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>Env.cutoff(1, 1).test(2).plot;
Env.cutoff(1, 1, 4).test(2).plot;
Env.cutoff(1, 1, \sine).test(2).plot;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>Env.</span><a class='method-name' name='*circle' href='./../Overviews/Methods.html#circle'>circle</a>(<span class='argstr'>levels</span>, <span class='argstr'>times</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which cycles through its values. For making a given envelope cyclic, you can use the instance method <a href="#-circle">-circle</a><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>levels<td class='argumentdesc'>
<p>The levels through which the envelope passes.<tr><td class='argumentname'>times<td class='argumentdesc'>
<p>The time between subsequent points in the envelope, which may be a single value (number), or an array of them. If too short, the array is extended. In difference to the *new method, the size of the times array is the same as that of the levels, because it includes the loop time.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>The curvature of the envelope, which may be a single value (number or symbol), or an array of them. If too short, the array is extended. In difference to the *new method, the size of the curve array is the same as that of the levels, because it includes the loop time.</table><h4>Discussion:</h4>
<textarea class='editor'>{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0], [0.01, 0.5, 0.2])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, 2, 0, 1, 0], [0.01, 0.3])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, (2..4), 0, (1..3), 0], [0.01, 0.3])) * 440 + 200).sum * 0.2 }.play; // multichannel expanded levels</textarea>
</div><h3><a class='anchor' name='Multichannel%20expansion'>Multichannel expansion</a></h3>

<p>If one of the values within either levels, times, or curves is itself an array, the envelope expands to multiple channels wherever appropriate. This means that when such an envelope is passed to an EnvGen, this EnvGen will expand, and when the envelope is queried via the methods <a href="#-at">-at</a> or <a href="#-asSignal">-asSignal</a>, it will return an array of values.<textarea class='editor'>(
{
    var env = Env([0.0, 0.5, 0.0, [1.0, 1.25, 1.5], 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
    var envgen = EnvGen.ar(env, doneAction: Done.freeSelf);
    SinOsc.ar(
        envgen * 1000 + 440
    ) * envgen * 0.1
}.play
);

(
{
    var env = Env([1, [1, 2, 3], 0.5, 0.5, [3, 2, 1], 2], [1, 1, 0.5, 1], [[\exp, \sin]]);
    env.plot;
    Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


(
{
    var levels = (1..30);
    var env = Env([1, levels, 0.5, levels / 2.5, 2], [1, 0.15, 1, 0.25, 0.1], \exp);
    Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


// accessing the envelope by indexing

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);

e = Env([1, 1, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);


// multichannel levels

Env([0.1, 1, 0.1], [1, [1, 2, 3]], \exp).plot;
Env([0.1, 1, 0.1], [1, [1, 2, 3]], [\lin, [\lin, \exp, \sin]]).plot;

Env([1, 1, 0.5, 3, 2], [1, 0.5, 1, 0.25], \exp).plot;
Env([0, 1, 0, 2, 0] * [[1, 2, 3]], [1, 0.5, 1, 0.25], \lin).plot;


// multichannel curves

Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [[\lin, \sqr]]).plot;

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [[\lin, \cub, \sin, \cubed, \welch, \step, \exp]]).plot(bounds: Rect(30, 100, 500, 700));

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));
Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));


Env([[0, 0.01], 1, 0], [0.5, 0.5], [[\lin, \exp], \step]).plot;
Env([[0, 0.01], 1, [0, 0.01]], [0.5, 1], [[\lin, \exp]]).plot;

// multichannel times

Env([[2, 1], 0], [[1, 2]], \lin).plot;
Env([0, 1], [1/(1..5)], [(-4..4)]).plot(bounds: Rect(30, 100, 300, 700));
Env([0, 1], [1/(1..5)], \lin).plot(bounds: Rect(30, 100, 300, 700));


// mixed expansions

Env([1, [ 1, 2, 3, 4, 5 ], 0.5, [3, 2, 1], 2], [1, 0.5, 1, 0.25], [[\exp, \lin]]).plot;
Env([1, [ 1, 2, 3, 4, 5 ], 0.5, 4, 2], [1, 0.5, 1, 0.25], \exp).plot;


// expanding control point envelopes

Env.xyc([[2, 0.5, [\lin, \exp]], [0, 1, \lin], [3, 1.4, \lin]]).plot;
Env.xyc({ [1.0.rand, 1.0.rand, {[\lin, \exp, \step].choose} ! 3] } ! 8).plot

Env.xyc([[[2.0, 2.3], 0.5, \lin], [0, 1, \lin], [3, 1.4, \lin]]).plot; // multiple times</textarea>
<h3><a class='anchor' name='Inherited%20class%20methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-ar' href='./../Overviews/Methods.html#ar'>ar</a>(<span class='argstr'>doneAction: 0</span>, <span class='argstr'>gate: 1.0</span>, <span class='argstr'>timeScale: 1.0</span>, <span class='argstr'>levelScale: 1.0</span>, <span class='argstr'>levelBias: 0.0</span>)</h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-kr' href='./../Overviews/Methods.html#kr'>kr</a>(<span class='argstr'>doneAction: 0</span>, <span class='argstr'>gate: 1.0</span>, <span class='argstr'>timeScale: 1.0</span>, <span class='argstr'>levelScale: 1.0</span>, <span class='argstr'>levelBias: 0.0</span>)</h3>
<div class='method'>
<p>Instead of using an <a href="./../Classes/EnvGen.html">EnvGen</a> inside a UGen graph, this message does the same implicitly for convenience. Its argument order corresponds to the most common arguments.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>doneAction<td class='argumentdesc'>
<p>An integer representing an action to be executed when the env is finished playing. This can be used to free the enclosing synth, etc. See <a href="./../Classes/Done.html">Done</a> for more detail.<tr><td class='argumentname'>gate<td class='argumentdesc'>
<p>This triggers the envelope and holds it open while &gt; 0. If the Env is fixed-length (e.g. Env.linen, Env.perc), the gate argument is used as a simple trigger. If it is an sustaining envelope (e.g. Env.adsr, Env.asr), the envelope is held open until the gate becomes 0, at which point is released.
<p>If <strong>gate</strong> &lt; 0, force release with time <code>-1.0 - gate</code>. See <a href="./../Classes/EnvGen.html#Forced%20release">EnvGen: Forced release</a> example.<tr><td class='argumentname'>timeScale<td class='argumentdesc'>
<p>The durations of the segments are multiplied by this value. This value can be modulated, but is only sampled at the start of a new envelope segment.<tr><td class='argumentname'>levelScale<td class='argumentdesc'>
<p>The levels of the breakpoints are multiplied by this value. This value can be modulated, but is only sampled at the start of a new envelope segment.<tr><td class='argumentname'>levelBias<td class='argumentdesc'>
<p>This value is added as an offset to the levels of the breakpoints. This value can be modulated, but is only sampled at the start of a new envelope segment.</table><h4>Discussion:</h4>
<textarea class='editor'>{ Blip.ar(50, 200, Env.perc(1, 0.1, 0.2).kr(2)) }.play;
(
{
    Blip.ar(
        Env({ exprand(3, 2000.0) } ! 18, 0.2, \exp).kr,
        200,
        Env({ rrand(0.1, 0.2) } ! 18 ++ 0, 0.2).kr(2))
    }.play;
)</textarea>
</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-blend' href='./../Overviews/Methods.html#blend'>blend</a>(<span class='argstr'>argAnotherEnv</span>, <span class='argstr'>argBlendFrac: 0.5</span>)</h3>
<div class='method'>
<p>Blend two envelopes. Returns a new Env. See <a href="#blend">blend</a> example below.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argAnotherEnv<td class='argumentdesc'>
<p>an Env.<tr><td class='argumentname'>argBlendFrac<td class='argumentdesc'>
<p>a number from zero to one.</table></div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-delay' href='./../Overviews/Methods.html#delay'>delay</a>(<span class='argstr'>delay</span>)</h3>
<div class='method'>
<p>Returns a new Env based on the receiver in which the start value will be held for <strong>delay</strong> number of seconds.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>delay<td class='argumentdesc'>
<p>The amount of time to delay the start of the envelope.</table><h4>Discussion:</h4>
<textarea class='editor'>a = Env.perc(0.05, 1, 1, -4);
b = a.delay(2);
a.test.plot;
b.test.plot;

a = Env([0.5, 1, 0], [1, 1]).plot;
a.delay(1).plot;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-duration' href='./../Overviews/Methods.html#duration'>duration</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-duration' href='./../Overviews/Methods.html#duration'>duration</a> = <span class='argstr'>dur</span></h3>
<div class='method'>
<p>Set the total duration of times, by stretching them.<h4>Discussion:</h4>
<textarea class='editor'>e = Env([0, 1, 0], [1, 2]);
e.duration;
e.duration = 2;
e.duration;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-totalDuration' href='./../Overviews/Methods.html#totalDuration'>totalDuration</a></h3>
<div class='method'>
<p>Get the total duration of the envelope. In multi-channel envelopes, this is the duration of the longest one.<h4>Discussion:</h4>
<textarea class='editor'>e = Env([0, 1, 0], [[1, 2], 2]);
e.duration;
e.totalDuration;</textarea>
</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-circle' href='./../Overviews/Methods.html#circle'>circle</a>(<span class='argstr'>timeFromLastToFirst: 0.0</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>circle from end to beginning over the time specified, with the curve specified. See also the class method <a href="#*circle">*circle</a><h4>Discussion:</h4>
<textarea class='editor'>(
{ SinOsc.ar(
    EnvGen.kr(
        Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle.postcs)
    ) * 0.1
    + Impulse.ar(1) }.play;
)

(
{ SinOsc.ar(
    EnvGen.kr(
        Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle(1).postcs,
        MouseX.kr &gt; 0.5)
    ) * 0.1
    + Impulse.ar(1) }.play;
)</textarea>
</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-test' href='./../Overviews/Methods.html#test'>test</a>(<span class='argstr'>releaseTime: 3.0</span>)</h3>
<div class='method'>
<p>Test the envelope on the default <a href="./../Classes/Server.html">Server</a> with a <a href="./../Classes/SinOsc.html">SinOsc</a>.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>If this is a sustaining envelope, it will be released after this much time in seconds. The default is 3 seconds.</table></div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-plot' href='./../Overviews/Methods.html#plot'>plot</a>(<span class='argstr'>size: 400</span>, <span class='argstr'>bounds</span>, <span class='argstr'>minval</span>, <span class='argstr'>maxval</span>, <span class='argstr'>name</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/share/SuperCollider/SCClassLibrary/Common/GUI/PlusGUI/Math/PlotView.sc'>/usr/share/SuperCollider/SCClassLibrary/Common/GUI/PlusGUI/Math/PlotView.sc</a></div>
<div class='method'>
<p>Plot this envelope's shape in a window.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>size<td class='argumentdesc'>
<p>The size of the plot. The default is 400.<tr><td class='argumentname'>bounds<td class='argumentdesc'>
<p>the size of the plot window.<tr><td class='argumentname'>minval<td class='argumentdesc'>
<p>the minimum value in the plot. Defaults to the lowest value in the data.<tr><td class='argumentname'>maxval<td class='argumentdesc'>
<p>the maximum value in the plot. Defaults to the highest value in the data.<tr><td class='argumentname'>name<td class='argumentdesc'>
<p>the plot window's label name. If nil, a name will be created for you.</table></div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asSignal' href='./../Overviews/Methods.html#asSignal'>asSignal</a>(<span class='argstr'>length: 400</span>)</h3>
<div class='method'>
<p>Returns a <a href="./../Classes/Signal.html">Signal</a> of size <strong>length</strong> created by sampling this Env at <strong>length</strong> number of intervals. If the envelope has multiple channels (see <a href="#Multichannel%20expansion">Multichannel expansion</a>), this method returns an array of signals.</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asArray' href='./../Overviews/Methods.html#asArray'>asArray</a></h3>
<div class='method'>
<p>Converts the Env to an <a href="./../Classes/Array.html">Array</a> in a specially ordered format. This allows for Env parameters to be settable arguments in a SynthDef. See example under <a href="#*newClear">*newClear</a>.</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asMultichannelArray' href='./../Overviews/Methods.html#asMultichannelArray'>asMultichannelArray</a></h3>
<div class='method'>
<p>Converts the Env to an <a href="./../Classes/Array.html">Array</a> in a specially ordered format, like <a href="#-asArray">-asArray</a>, however it always returns an array of these data sets, corresponding to the number of channels of the envelope.</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-isSustained' href='./../Overviews/Methods.html#isSustained'>isSustained</a></h3>
<div class='method'>
<p>Returns true if this is a sustaining envelope, false otherwise.</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-range' href='./../Overviews/Methods.html#range'>range</a>(<span class='argstr'>lo: 0.0</span>, <span class='argstr'>hi: 1.0</span>)</h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-exprange' href='./../Overviews/Methods.html#exprange'>exprange</a>(<span class='argstr'>lo: 0.01</span>, <span class='argstr'>hi: 1.0</span>)</h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-curverange' href='./../Overviews/Methods.html#curverange'>curverange</a>(<span class='argstr'>lo: 0.0</span>, <span class='argstr'>hi: 1.0</span>, <span class='argstr'>curve: -4</span>)</h3>
<div class='method'>
<p>Returns a copy of the Env whose levels have been mapped onto the given linear, exponential or curve range.<h4>Discussion:</h4>
<textarea class='editor'>a = Env.adsr;
a.levels;
a.range(42, 45).levels;
a.exprange(42, 45).levels;
a.curverange(42, 45, -4).levels;

(
// Mapping an Env to an exponential frequency range:
{
    SinOsc.ar(EnvGen.ar(Env.perc(0.01, 0.7).exprange(40, 10000), doneAction: Done.freeSelf)) * 0.2;
}.play
)</textarea>
</div><h3><a class='anchor' name='Client-side%20Access%20and%20Stream%20Support'>Client-side Access and Stream Support</a></h3>

<p>Sustain and loop settings have no effect in the methods below.<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-at' href='./../Overviews/Methods.html#at'>at</a>(<span class='argstr'>time</span>)</h3>
<div class='method'>
<p>Returns the value of the Env at <strong>time</strong>. If the envelope has multiple channels, this method returns an array of levels.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>time<td class='argumentdesc'>
<p>A number or an array of numbers to specify a cut in the envelope. If time is an array, it returns the corresponding levels of each time value, and if the envelope has multiple channels, it returns an array of values. A combination of both returns a two-dimensional array.</table><h4>Discussion:</h4>
<textarea class='editor'>e = Env.triangle(1, 1);
e.at(0.5);
e.at([0.5, 0.7]);

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);
e.at([0.5, 1.2]);

e = Env([1, 100, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);
e.at([1, 2, 4]);</textarea>
</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-embedInStream' href='./../Overviews/Methods.html#embedInStream'>embedInStream</a>(<span class='argstr'>inval</span>)</h3>
<div class='method'>
<p>Embeds this Env within an enclosing <a href="./../Classes/Stream.html">Stream</a>. Timing is derived from <code>thisThread.beats</code>.</div><h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asStream' href='./../Overviews/Methods.html#asStream'>asStream</a></h3>
<div class='method'>
<p>Creates a Routine and embeds the Env in it. This allows the Env to function as a <a href="./../Classes/Stream.html">Stream</a>.<h4>Discussion:</h4>
<textarea class='editor'>(
{
e = Env.sine.asStream;
5.do({
    e.next.postln;
    0.25.wait;
})}.fork
)</textarea>
</div><h3><a class='anchor' name='Inherited%20instance%20methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h3><a class='anchor' name='Undocumented%20instance%20methods'>Undocumented instance methods</a></h3>
<h3 class='method-code'><span class='method-prefix'></span><a class='method-name' name='-==' href='./../Overviews/Methods.html#=='>==</a>(<span class='argstr'>that</span>)</h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-array' href='./../Overviews/Methods.html#array'>array</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asArrayForInterpolation' href='./../Overviews/Methods.html#asArrayForInterpolation'>asArrayForInterpolation</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asControlInput' href='./../Overviews/Methods.html#asControlInput'>asControlInput</a></h3>
<div class='extmethod'>From extension in <a href='file:///usr/share/SuperCollider/SCClassLibrary/Common/Control/extConvertToOSC.sc'>/usr/share/SuperCollider/SCClassLibrary/Common/Control/extConvertToOSC.sc</a></div>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asMultichannelSignal' href='./../Overviews/Methods.html#asMultichannelSignal'>asMultichannelSignal</a>(<span class='argstr'>length: 400</span>, <span class='argstr'>class</span>)</h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asOSCArgEmbeddedArray' href='./../Overviews/Methods.html#asOSCArgEmbeddedArray'>asOSCArgEmbeddedArray</a>(<span class='argstr'>array</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/share/SuperCollider/SCClassLibrary/Common/Control/extConvertToOSC.sc'>/usr/share/SuperCollider/SCClassLibrary/Common/Control/extConvertToOSC.sc</a></div>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-asPseg' href='./../Overviews/Methods.html#asPseg'>asPseg</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-curveValue' href='./../Overviews/Methods.html#curveValue'>curveValue</a>(<span class='argstr'>curve</span>)</h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-curves' href='./../Overviews/Methods.html#curves'>curves</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-curves' href='./../Overviews/Methods.html#curves'>curves</a> = <span class='argstr'>z</span></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-discretize' href='./../Overviews/Methods.html#discretize'>discretize</a>(<span class='argstr'>n: 1024</span>)</h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-hash' href='./../Overviews/Methods.html#hash'>hash</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-levels' href='./../Overviews/Methods.html#levels'>levels</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-levels' href='./../Overviews/Methods.html#levels'>levels</a> = <span class='argstr'>z</span></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-loopNode' href='./../Overviews/Methods.html#loopNode'>loopNode</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-loopNode' href='./../Overviews/Methods.html#loopNode'>loopNode</a> = <span class='argstr'>z</span></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-offset' href='./../Overviews/Methods.html#offset'>offset</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-offset' href='./../Overviews/Methods.html#offset'>offset</a> = <span class='argstr'>z</span></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-releaseNode' href='./../Overviews/Methods.html#releaseNode'>releaseNode</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-releaseNode' href='./../Overviews/Methods.html#releaseNode'>releaseNode</a> = <span class='argstr'>z</span></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-releaseTime' href='./../Overviews/Methods.html#releaseTime'>releaseTime</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-times' href='./../Overviews/Methods.html#times'>times</a></h3>
<h3 class='method-code'><span class='method-prefix'>.</span><a class='method-name' name='-times' href='./../Overviews/Methods.html#times'>times</a> = <span class='argstr'>z</span></h3>
<h2><a class='anchor' name='examples'>Examples</a></h2>
<textarea class='editor'>s.boot;     //.test below will run a synthesis example
        // to demonstrate the envelope, so the Server must be on

// different shaped segments: .plot graphs the Env
Env.new([0,1, 0.3, 0.8, 0], [2, 3, 1, 4],'linear').test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001], [2, 3, 1, 4],'exponential').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],\sine).test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001],[2,3,1,4],\welch).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],'step').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], -2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], 2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], [0, 3, -3, -1]).test.plot;</textarea>

<p>If a release node is given, and the gate input of the EnvGen is set to zero, it outputs the nodes after the release node:<textarea class='editor'>// release node is node 1; takes 0.5 seconds to go from 0 to 1,
// sustains at level of 1, then released after three seconds
// (test causes the release after three seconds, given the argument 3),
// taking 2 seconds to finish
Env.new([0,1,0],[0.5,2],'linear',1).test(3).plot

// more complex examples
// release node is node 2; releases after 5 sec
Env.new([0.001,1,0.3,0.8,0.001],[2,3,1,4] * 0.2, 2, 2).test(5).plot;
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(5).plot;

// early release: goes straight onto the release node after 0.1 seconds
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(0.1).plot;</textarea>

<p>If a loop node is given, the EnvGen outputs the nodes between the loop node and the release node (not including the release node itself) until it is released:<textarea class='editor'>// release node is node 2, loop node is node 0: so loops around nodes 0 (lvl 1, dur 0.5)
// and 1 (lvl 0.1, dur 0.5)         //until released after 3.5 seconds
Env.new([0,1,0.1,0],[0.5,0.5,2], 'lin', 2, 0).test(3.5).plot;

// this just sustains at node 0, because there is no other node to loop around!
Env.new([0,1,0],[0.5,2], 'lin', 1, 0).test(3.5).plot;

// more complex example: release node is node 3, loop node is node 1
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.1, 'lin', 3, 1).test(3).plot;

// this is the resulting graph:
(
e = Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.001, 'lin', 3, 1);
e.plot;{ EnvGen.ar(e, Trig.ar(Impulse.ar(0), 10*0.001)) }.plot(0.02);
)</textarea>
<div class='note'><span class='notelabel'>NOTE:</span> The starting level for an envelope segment is always the level you are at right now. For example when the gate is released and you jump to the release segment, the level does not jump to the level at the beginning of the release segment, it changes from whatever the current level is to the goal level of the release segment over the specified duration of the release segment.
<p>There is an extra level at the beginning of the envelope to set the initial level. After that each node is a goal level and a duration, so node zero has duration equal to times[0] and goal level equal to levels[1].
<p>The loop jumps back to the loop node. The endpoint of that segment is the goal level for that segment and the duration of that segment will be the time over which the level changed from the current level to the goal level.</div><h3><a class='anchor' name='blend'>blend</a></h3>
<textarea class='editor'>a = Env([0, 0.2, 1, 0.2, 0.2, 0], [0.5, 0.01, 0.01, 0.3, 0.2]);
a.test.plot;

b = Env([0, 0.4, 1, 0.2, 0.5, 0], [0.05, 0.4, [0.01, 0.1], 0.1, 0.4]);
b.test.plot;

(
Task({
    f = (0, 0.2 .. 1);
    f.do { |u|
        blend(a, b, u).test.plot;
        2.wait;
        Window.allWindows.pop.close; // close last opened window
    }
}).play(AppClock);
)

// blend in a SynthDef
(
SynthDef(\help_EnvBlend, { | out, factor = 0 |
    Out.ar(out, EnvGen.kr(blend(Env.perc, Env.sine, factor), 1.0, doneAction: Done.freeSelf)
        * SinOsc.ar(440,0,0.1)
    )
}).add
);

(
{
    var factors = (0, 0.1..1);
    factors.do {|f| Synth(\help_EnvBlend, [\factor, f.postln]); 1.wait };
}.fork
);</textarea>

<p><div class='doclink'>helpfile source: <a href='file:///usr/share/SuperCollider/HelpSource/Classes/Env.schelp'>/usr/share/SuperCollider/HelpSource/Classes/Env.schelp</a><br>link::Classes/Env::<br></div></div><script src='./../editor.js' type='text/javascript'></script>
</body></html>
<html><head><title>Env</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CLASSES</div>
<div id='categories'><a href='./../Browse.html#Control'>Control</a>, <a href='./../Browse.html#Envelopes'>Envelopes</a></div>
<h1>Env</h1>
<div id='summary'>Specification for a segmented envelope</div>
</div>
<div class='subheader'>
<div id='filename'>Source: /usr/local/share/SuperCollider/SCClassLibrary/Common/Audio/<a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/Audio/Env.sc'>Env.sc</a></div><div id='superclasses'>Inherits from: <a href="../Classes/Object.html">Object</a></div>
<div id='subclasses'>Subclasses: <a href="../Classes/Penv.html">Penv</a></div>
<div id='related'>See also: <a href="./../Classes/EnvGen.html">EnvGen</a>, <a href="./../Classes/IEnvGen.html">IEnvGen</a>, <a href="./../Classes/Pseg.html">Pseg</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*new'>new</a> </li>
<li class='toc3'><a href='#*newClear'>newClear</a> </li>
<li class='toc2'><a href='#Standard Shape Envelope Creation Methods'>Standard Shape Envelope Creation Methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*linen'>linen</a> </li>
<li class='toc3'><a href='#*triangle'>triangle</a> </li>
<li class='toc3'><a href='#*sine'>sine</a> </li>
<li class='toc3'><a href='#*perc'>perc</a> </li>
<li class='toc3'><a href='#*pairs'>pairs</a> </li>
<li class='toc3'><a href='#*xyc'>xyc</a> </li>
</ul><li class='toc2'><a href='#Sustained Envelope Creation Methods'>Sustained Envelope Creation Methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*step'>step</a> </li>
<li class='toc3'><a href='#*adsr'>adsr</a> </li>
<li class='toc3'><a href='#*dadsr'>dadsr</a> </li>
<li class='toc3'><a href='#*asr'>asr</a> </li>
<li class='toc3'><a href='#*cutoff'>cutoff</a> </li>
<li class='toc3'><a href='#*circle'>circle</a> </li>
</ul><li class='toc2'><a href='#Multichannel expansion'>Multichannel expansion</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Inherited class methods'>Inherited class methods</a></li>
<li class='toc2'><a href='#Undocumented class methods'>Undocumented class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*shapeNames'>shapeNames</a> </li>
<li class='toc3'><a href='#*shapeNumber'>shapeNumber</a> </li>
</ul></ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-ar'>ar</a>  <a href='#-kr'>kr</a> </li>
<li class='toc3'><a href='#-blend'>blend</a> </li>
<li class='toc3'><a href='#-delay'>delay</a> </li>
<li class='toc3'><a href='#-duration'>duration</a> </li>
<li class='toc3'><a href='#-totalDuration'>totalDuration</a> </li>
<li class='toc3'><a href='#-circle'>circle</a> </li>
<li class='toc3'><a href='#-test'>test</a> </li>
<li class='toc3'><a href='#-plot'>plot</a> </li>
<li class='toc3'><a href='#-asSignal'>asSignal</a> </li>
<li class='toc3'><a href='#-asArray'>asArray</a> </li>
<li class='toc3'><a href='#-asMultichannelArray'>asMultichannelArray</a> </li>
<li class='toc3'><a href='#-isSustained'>isSustained</a> </li>
<li class='toc3'><a href='#-range'>range</a>  <a href='#-exprange'>exprange</a>  <a href='#-curverange'>curverange</a> </li>
<li class='toc2'><a href='#Client-side Access and Stream Support'>Client-side Access and Stream Support</a></li>
<ul class='toc'><li class='toc3'><a href='#-at'>at</a> </li>
<li class='toc3'><a href='#-embedInStream'>embedInStream</a> </li>
<li class='toc3'><a href='#-asStream'>asStream</a> </li>
</ul><li class='toc2'><a href='#Inherited instance methods'>Inherited instance methods</a></li>
<li class='toc2'><a href='#Undocumented instance methods'>Undocumented instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-=='>==</a> </li>
<li class='toc3'><a href='#-array'>array</a> </li>
<li class='toc3'><a href='#-asArrayForInterpolation'>asArrayForInterpolation</a> </li>
<li class='toc3'><a href='#-asControlInput'>asControlInput</a> </li>
<li class='toc3'><a href='#-asMultichannelSignal'>asMultichannelSignal</a> </li>
<li class='toc3'><a href='#-asOSCArgEmbeddedArray'>asOSCArgEmbeddedArray</a> </li>
<li class='toc3'><a href='#-asPseg'>asPseg</a> </li>
<li class='toc3'><a href='#-curveValue'>curveValue</a> </li>
<li class='toc3'><a href='#-curves'>curves</a> </li>
<li class='toc3'><a href='#-discretize'>discretize</a> </li>
<li class='toc3'><a href='#-hash'>hash</a> </li>
<li class='toc3'><a href='#-levels'>levels</a> </li>
<li class='toc3'><a href='#-loopNode'>loopNode</a> </li>
<li class='toc3'><a href='#-offset'>offset</a> </li>
<li class='toc3'><a href='#-releaseNode'>releaseNode</a> </li>
<li class='toc3'><a href='#-releaseTime'>releaseTime</a> </li>
<li class='toc3'><a href='#-times'>times</a> </li>
</ul></ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'><li class='toc2'><a href='#blend'>blend</a></li>
<ul class='toc'></ul></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>

<p>An Env is a specification for a segmented envelope. Envs can be used both server-side, by an <a href="./../Classes/EnvGen.html">EnvGen</a> or an <a href="./../Classes/IEnvGen.html">IEnvGen</a> within a <a href="./../Classes/SynthDef.html">SynthDef</a>, and clientside, with methods such as <a href="#-at">-at</a> and <a href="#-asStream">-asStream</a>, below.
<p>An Env can have any number of segments which can stop at a particular value or loop several segments when sustaining. It can have several shapes for its segments.<pre class='code prettyprint lang-sc'>Env.new([0, 1, 0.9, 0], [0.1, 0.5, 1],[-5, 0, -5]).plot;</pre>

<p>The envelope is conceived as a sequence of <em>nodes</em> (not to be confused with a synthesis-Node) each of which has three parameters: a target level, a time duration from the previous node, and a shape. The three parameters for each node are kept in separate arrays as explained below.<div class='note'><span class='notelabel'>NOTE:</span> In some situations we deal with control points or breakpoints. If these control points have associated x positions (say in an envelope GUI, see <a href="./../Classes/EnvelopeView.html">EnvelopeView</a>) they must be converted to time differences between points to be used as nodes in a Env object. The methods <a href="#*xyc">*xyc</a> and <a href="#*pairs">*pairs</a> can be used to specify an envelope in terms of points.</div><pre class='code prettyprint lang-sc'>// an envelope in a synth
(
{
    var env = Env([0, 1, 0.5, 1, 0], [0.01, 0.5, 0.02, 0.5]);
    SinOsc.ar(470) * EnvGen.kr(env, doneAction: 2)
}.play
)
// an envelope to control a parameter in a pattern
(
Pbind(
    \note,  Env([0, 12, 6, 13, 0], [1, 5, 2, 10]),
    \dur, 0.1
).play
)</pre>
<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*new' href='./../Overviews/Methods.html#new'>new</a> (<span class='argstr'>levels: [ 0, 1, 0 ]</span>, <span class='argstr'>times: [ 1, 1 ]</span>, <span class='argstr'>curve: 'lin'</span>, <span class='argstr'>releaseNode</span>, <span class='argstr'>loopNode</span>, <span class='argstr'>offset: 0</span>)</h3>
<div class='method'>
<p>Create a new envelope specification.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>levels<td class='argumentdesc'>
<p>an array of levels. The first level is the initial value of the envelope. When the envelope is used with an EnvGen, levels can be any UGen (new level values are updated only when the envelope has reached that point). When the array of levels contains itself an array, the envelope returns a multichannel output (for a discussion, see <a href="#multichannel expansion">multichannel expansion</a>)<tr><td class='argumentname'>times<td class='argumentdesc'>
<p>an array of durations of segments in seconds. There should be one fewer duration than there are levels, but if shorter, the array is extended by wrapping around the given values.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>a <a href="./../Classes/Symbol.html">Symbol</a>, <a href="./../Classes/Float.html">Float</a>, or an <a href="./../Classes/Array.html">Array</a> of those. Determines the shape of the envelope segments.
<p>The possible values are:<table>
<tr><td><code class='code prettyprint lang-sc'>\step</code><td><td>flat segments (immediately jumps to final value)<tr><td><code class='code prettyprint lang-sc'>\hold</code><td><td>flat segments (holds initial value, jump to final value at the end of the segment)<tr><td><code class='code prettyprint lang-sc'>\linear</code><td><code class='code prettyprint lang-sc'>\lin</code><td>linear segments, the default<tr><td><code class='code prettyprint lang-sc'>\exponential</code><td><code class='code prettyprint lang-sc'>\exp</code><td>natural exponential growth and decay. In this case, the levels must all be nonzero and have the same sign.<tr><td><code class='code prettyprint lang-sc'>\sine</code><td><code class='code prettyprint lang-sc'>\sin</code><td>sinusoidal S shaped segments.<tr><td><code class='code prettyprint lang-sc'>\welch</code><td><code class='code prettyprint lang-sc'>\wel</code><td>sinusoidal segments shaped like the sides of a Welch window.<tr><td><code class='code prettyprint lang-sc'>\squared</code><td><code class='code prettyprint lang-sc'>\sqr</code><td>squared segment<tr><td><code class='code prettyprint lang-sc'>\cubed</code><td><code class='code prettyprint lang-sc'>\cub</code><td>cubed segment<tr><td>a <a href="./../Classes/Float.html">Float</a><td><td>a curvature value for all segments. 0 means linear, positive and negative numbers curve the segment up and down.<tr><td>an <a href="./../Classes/Array.html">Array</a> of symbols or floats<td><td>curvature values for each segment.</table>
<tr><td class='argumentname'>releaseNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. The envelope will sustain at the release node until released.<tr><td class='argumentname'>loopNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. If not nil the output will loop through those nodes startign at the loop node to the node immediately preceeding the release node, before back to the loop node, and so on. Note that the envelope only transitions to the release node when released. Examples are below. The loop is escaped when a gate signal is sent, when the output transitions to the release node, as described below.<tr><td class='argumentname'>offset<td class='argumentdesc'>
<p>an offset to all time values (only applies in <a href="./../Classes/IEnvGen.html">IEnvGen</a>).</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>(
{
    var env = Env([0.0, 0.5, 0.0, 1.0, 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
    var envgen = EnvGen.ar(env, doneAction: 2);
    SinOsc.ar(
        envgen * 1000 + 440
    ) * envgen * 0.1
}.play
);</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*newClear' href='./../Overviews/Methods.html#newClear'>newClear</a> (<span class='argstr'>numSegments: 8</span>, <span class='argstr'>numChannels: 1</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification with <strong>numSegments</strong> and <strong>numChannels</strong> for filling in later.<h4>Discussion:</h4>

<p>This can be useful when passing Env parameters as args to a <a href="./../Classes/Synth.html">Synth</a>. Note that the maximum number of segments is fixed and cannot be changed once embedded in a <a href="./../Classes/SynthDef.html">SynthDef</a>. Trying to set an Env with more segments than then this may result in other args being unexpectedly set.<pre class='code prettyprint lang-sc'>(
SynthDef(\help_Env_newClear, { |out = 0, gate = 1|
    var env, envctl;
    // make an empty 4 segment envelope
    env = Env.newClear(4);
    // create a control argument array
    envctl = \env.kr(env.asArray);
    Out.ar(out, SinOsc.ar(EnvGen.kr(envctl, gate), 0) * -12.dbamp);
}).add;
)

Synth(\help_Env_newClear, [\env, Env([700,900,900,800], [1,1,1], \exp)]); // 3 segments

// reset then play again:
Synth(\help_Env_newClear, [ \env, Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)]);

// the same written as an event:
(instrument: \help_Env_newClear, env: Env({ rrand(60, 70).midicps } ! 4, [1,1,1], \exp)).play;</pre>
</div><h3><a class='anchor' name='Standard Shape Envelope Creation Methods'>Standard Shape Envelope Creation Methods</a></h3>

<p>The following class methods create some frequently used envelope shapes based on supplied durations.<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*linen' href='./../Overviews/Methods.html#linen'>linen</a> (<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>sustainTime: 1</span>, <span class='argstr'>releaseTime: 1</span>, <span class='argstr'>level: 1</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has a trapezoidal shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>sustainTime<td class='argumentdesc'>
<p>the duration of the sustain portion.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the level of the sustain portion.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.linen(0.1, 0.2, 0.1, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6).test.plot;
Env.linen(1, 2, 3, 0.6, \sine).test.plot;
Env.linen(1, 2, 3, 0.6, \welch).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, -3).test.plot;
Env.linen(1, 2, 3, 0.6, [[\sine, \welch, \lin, \exp]]).plot;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*triangle' href='./../Overviews/Methods.html#triangle'>triangle</a> (<span class='argstr'>dur: 1</span>, <span class='argstr'>level: 1</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has a triangle shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>dur<td class='argumentdesc'>
<p>the duration of the envelope.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.triangle(1, 1).test.plot;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*sine' href='./../Overviews/Methods.html#sine'>sine</a> (<span class='argstr'>dur: 1</span>, <span class='argstr'>level: 1</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has a hanning window shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>dur<td class='argumentdesc'>
<p>the duration of the envelope.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.sine(1, 1).test.plot;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*perc' href='./../Overviews/Methods.html#perc'>perc</a> (<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>releaseTime: 1</span>, <span class='argstr'>level: 1</span>, <span class='argstr'>curve: -4</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which (usually) has a percussive shape.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.perc(0.05, 1, 1, -4).test.plot;
Env.perc(0.001, 1, 1, -4).test.plot;    // sharper attack
Env.perc(0.001, 1, 1, -8).test.plot;    // change curvature
Env.perc(1, 0.01, 1, 4).test.plot;    // reverse envelope</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*pairs' href='./../Overviews/Methods.html#pairs'>pairs</a> (<span class='argstr'>pairs</span>, <span class='argstr'>curve</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification from coordinates / control points<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>pairs<td class='argumentdesc'>
<p>an array of pairs [[time, level], ...]
<p>if possible, pairs are sorted regarding their point in time<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.pairs([[0, 1], [2.1, 0.5],  [3, 1.4]], \exp).plot;
Env.pairs([[0, 1], [3, 1.4], [2.1, 0.5], [3, 4]], \exp).plot; // *if possible*, pairs are sorted according to time
Env.pairs({ { 1.0.rand } ! 2 } ! 16, \exp).plot;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*xyc' href='./../Overviews/Methods.html#xyc'>xyc</a> (<span class='argstr'>xyc</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification from coordinates / control points with curvature.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>xyc<td class='argumentdesc'>
<p>an array of triplets [[time, level, curve], ...]
<p>if possible, pairs are sorted regarding their point in time</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.xyc([[0, 1, \sin], [2.1, 0.5, \lin],  [3, 1.4, \lin]]).plot;
Env.xyc([[2.1, 0.5, \lin], [0, 1, \sin], [3, 1.4, \lin]]).plot; // *if possible*, pairs are sorted according to time
Env.xyc({ [1.0.rand, 10.0.rand, -4.rand2] } ! 16, \exp).plot;</pre>
</div><h3><a class='anchor' name='Sustained Envelope Creation Methods'>Sustained Envelope Creation Methods</a></h3>

<p>The following methods create some frequently used envelope shapes which have a sustain segment. They are typically used in SynthDefs in situations where at the time of starting the synth it is not known when it will end. Typical cases are external interfaces, midi input, or quickly varying TempoClock.<pre class='code prettyprint lang-sc'>(
SynthDef(\env_help, { |out, gate = 1, amp = 0.1, release = 0.1|
    var env = Env.adsr(0.02, release, amp);
    var gen = EnvGen.kr(env, gate, doneAction: 2);
    Out.ar(out, PinkNoise.ar(1 ! 2) * gen)
}).add
);

a = Synth(\env_help);
b = Synth(\env_help, [\release, 2]);
a.set(\gate, 0); // alternatively, you can write a.release;
b.set(\gate, 0);</pre>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*step' href='./../Overviews/Methods.html#step'>step</a> (<span class='argstr'>levels: [ 0, 1 ]</span>, <span class='argstr'>times: [ 1, 1 ]</span>, <span class='argstr'>releaseNode</span>, <span class='argstr'>loopNode</span>, <span class='argstr'>offset: 0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification where all the segments are horizontal lines. Given n values of times only n levels need to be provided, corresponding to the fixed value of each segment.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>levels<td class='argumentdesc'>
<p>an array of levels. Levels can be any UGen (new level values are updated only when the envelope has reached that point). When the array of levels contains itself an array, the envelope returns a multichannel output (for a discussion, see <a href="#multichannel expansion">multichannel expansion</a>)<tr><td class='argumentname'>times<td class='argumentdesc'>
<p>an array of durations of segments in seconds. It should be the same size as the levels array.<tr><td class='argumentname'>releaseNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. The envelope will sustain at the release node until released.<tr><td class='argumentname'>loopNode<td class='argumentdesc'>
<p>an <a href="./../Classes/Integer.html">Integer</a> or nil. If not nil the output will loop through those nodes startign at the loop node to the node immediately preceeding the release node, before back to the loop node, and so on. Note that the envelope only transitions to the release node when released. Examples are below. The loop is escaped when a gate signal is sent, when the output transitions to the release node, as described below.<tr><td class='argumentname'>offset<td class='argumentdesc'>
<p>an offset to all time values (only applies in <a href="./../Classes/IEnvGen.html">IEnvGen</a>).</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>(
{
    var env = Env.step([0, 3, 5, 2, 7, 3, 0, 3, 4, 0], [0.5, 0.1, 0.2, 1.0, 1.5, 2, 0.2, 0.1, 0.2, 0.1]);
    var envgen = EnvGen.kr(env);
    var freq = (envgen + 60).midicps;
    SinOsc.ar(freq) * 0.1
}.play
);</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*adsr' href='./../Overviews/Methods.html#adsr'>adsr</a> (<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>decayTime: 0.3</span>, <span class='argstr'>sustainLevel: 0.5</span>, <span class='argstr'>releaseTime: 1</span>, <span class='argstr'>peakLevel: 1</span>, <span class='argstr'>curve: -4</span>, <span class='argstr'>bias: 0</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which is shaped like traditional analog attack-decay-sustain-release (adsr) envelopes.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>decayTime<td class='argumentdesc'>
<p>the duration of the decay portion.<tr><td class='argumentname'>sustainLevel<td class='argumentdesc'>
<p>the level of the sustain portion as a ratio of the peak level.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>peakLevel<td class='argumentdesc'>
<p>the peak level of the envelope.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.<tr><td class='argumentname'>bias<td class='argumentdesc'>
<p>offset</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.adsr(0.02, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(2).plot;
Env.adsr(0.001, 0.2, 0.25, 1, 1, -4).test(0.45).plot;    // release after 0.45 sec</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*dadsr' href='./../Overviews/Methods.html#dadsr'>dadsr</a> (<span class='argstr'>delayTime: 0.1</span>, <span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>decayTime: 0.3</span>, <span class='argstr'>sustainLevel: 0.5</span>, <span class='argstr'>releaseTime: 1</span>, <span class='argstr'>peakLevel: 1</span>, <span class='argstr'>curve: -4</span>, <span class='argstr'>bias: 0</span>)</h3>
<div class='method'>
<p>As <a href="#*adsr">*adsr</a> above, but with its onset delayed by <strong>delayTime</strong> in seconds. The default delay is 0.1.</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*asr' href='./../Overviews/Methods.html#asr'>asr</a> (<span class='argstr'>attackTime: 0.01</span>, <span class='argstr'>sustainLevel: 1</span>, <span class='argstr'>releaseTime: 1</span>, <span class='argstr'>curve: -4</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which is shaped like traditional analog attack-sustain-release (asr) envelopes.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>attackTime<td class='argumentdesc'>
<p>the duration of the attack portion.<tr><td class='argumentname'>sustainLevel<td class='argumentdesc'>
<p>the level of the sustain portion as a ratio of the peak level.<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.asr(0.02, 0.5, 1, -4).test(2).plot;
Env.asr(0.001, 0.5, 1, -4).test(2).plot; // sharper attack
Env.asr(0.02, 0.5, 1, 'linear').test(2).plot; // linear segments</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*cutoff' href='./../Overviews/Methods.html#cutoff'>cutoff</a> (<span class='argstr'>releaseTime: 0.1</span>, <span class='argstr'>level: 1</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which has no attack segment. It simply sustains at the peak level until released. Useful if you only need a fadeout, and more versatile than <a href="./../Classes/Line.html">Line</a>.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>the duration of the release portion.<tr><td class='argumentname'>level<td class='argumentdesc'>
<p>the peak level of the envelope.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>the curvature of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>Env.cutoff(1, 1).test(2).plot;
Env.cutoff(1, 1, 4).test(2).plot;
Env.cutoff(1, 1, \sine).test(2).plot;</pre>
</div><h3 class='cmethodname'><span class='methprefix'>*</span><a name='*circle' href='./../Overviews/Methods.html#circle'>circle</a> (<span class='argstr'>levels</span>, <span class='argstr'>times</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>Creates a new envelope specification which cycles through its values. For making a given envelope cyclic, you can use the instance method <a href="#-circle">-circle</a><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>levels<td class='argumentdesc'>
<p>The levels through which the envelope passes.<tr><td class='argumentname'>times<td class='argumentdesc'>
<p>The time between subsequent points in the envelope, which may be a single value (number), or an array of them. If too short, the array is extended. In difference to the *new method, the size of the times array is the same as that of the levels, because it includes the loop time.<tr><td class='argumentname'>curve<td class='argumentdesc'>
<p>The curvature of the envelope, which may be a single value (number or symbol), or an array of them. If too short, the array is extended. In difference to the *new method, the size of the curve array is the same as that of the levels, because it includes the loop time.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0], [0.01, 0.5, 0.2])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, 2, 0, 1, 0], [0.01, 0.3])) * 440 + 200) * 0.2 }.play;
{ SinOsc.ar(EnvGen.kr(Env.circle([0, 1, 0, (2..4), 0, (1..3), 0], [0.01, 0.3])) * 440 + 200).sum * 0.2 }.play; // multichannel expanded levels</pre>
</div><h3><a class='anchor' name='Multichannel expansion'>Multichannel expansion</a></h3>

<p>If one of the values within either levels, times, or curves is itself an array, the envelope expands to multiple channels wherever appropriate. This means that when such an envelope is passed to an EnvGen, this EnvGen will expand, and when the envelope is queried via the methods <a href="#-at">-at</a> or <a href="#-asSignal">-asSignal</a>, it will return an array of values.<pre class='code prettyprint lang-sc'>(
{
    var env = Env([0.0, 0.5, 0.0, [1.0, 1.25, 1.5], 0.9, 0.0], [0.05, 0.1, 0.01, 1.0, 1.5], -4);
    var envgen = EnvGen.ar(env, doneAction: 2);
    SinOsc.ar(
        envgen * 1000 + 440
    ) * envgen * 0.1
}.play
);

(
{
    var env = Env([1, [1, 2, 3], 0.5, 0.5, [3, 2, 1], 2], [1, 1, 0.5, 1], [[\exp, \sin]]);
    env.plot;
    Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


(
{
    var levels = (1..30);
    var env = Env([1, levels, 0.5, levels / 2.5, 2], [1, 0.15, 1, 0.25, 0.1], \exp);
    Splay.ar(SinOsc.ar(EnvGen.kr(env) * 400 + 600)) * 0.1
}.play;
);


// accessing the envlope by indexing

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);

e = Env([1, 1, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);


// multichannel levels

Env([0.1, 1, 0.1], [1, [1, 2, 3]], \exp).plot;
Env([0.1, 1, 0.1], [1, [1, 2, 3]], [\lin, [\lin, \exp, \sin]]).plot;

Env([1, 1, 0.5, 3, 2], [1, 0.5, 1, 0.25], \exp).plot;
Env([0, 1, 0, 2, 0] * [[1, 2, 3]], [1, 0.5, 1, 0.25], \lin).plot;


// multichannel curves

Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [[\lin, \sqr]]).plot;

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [[\lin, \cub, \sin, \cubed, \welch, \step, \exp]]).plot(bounds: Rect(30, 100, 500, 700));

Env([0.01, 5, 1, 0.5, 0.001] + 1, [1, 0.5, 1, 0.25, 1], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));
Env([0.01, 5, 1, 0.5] + 1, [1, 0.5, 1, 0.25], [(-4..4)]).plot(bounds: Rect(30, 100, 500, 700));


Env([[0, 0.01], 1, 0], [0.5, 0.5], [[\lin, \exp], \step]).plot;
Env([[0, 0.01], 1, [0, 0.01]], [0.5, 1], [[\lin, \exp]]).plot;

// multichannel times

Env([[2, 1], 0], [[1, 2]], \lin).plot;
Env([0, 1], [1/(1..5)], [(-4..4)]).plot(bounds: Rect(30, 100, 300, 700));
Env([0, 1], [1/(1..5)], \lin).plot(bounds: Rect(30, 100, 300, 700));


// mixed expansions

Env([1, [ 1, 2, 3, 4, 5 ], 0.5, [3, 2, 1], 2], [1, 0.5, 1, 0.25], [[\exp, \lin]]).plot;
Env([1, [ 1, 2, 3, 4, 5 ], 0.5, 4, 2], [1, 0.5, 1, 0.25], \exp).plot;


// expanding control point envelopes

Env.xyc([[2, 0.5, [\lin, \exp]], [0, 1, \lin], [3, 1.4, \lin]]).plot;
Env.xyc({ [1.0.rand, 1.0.rand, {[\lin, \exp, \step].choose} ! 3] } ! 8).plot

Env.xyc([[[2.0, 2.3], 0.5, \lin], [0, 1, \lin], [3, 1.4, \lin]]).plot; // multiple times</pre>
<h3><a class='anchor' name='Inherited class methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h3><a class='anchor' name='Undocumented class methods'>Undocumented class methods</a></h3>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*shapeNames' href='./../Overviews/Methods.html#shapeNames'>shapeNames</a> </h3>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*shapeNumber' href='./../Overviews/Methods.html#shapeNumber'>shapeNumber</a> (<span class='argstr'>shapeName</span>)</h3>
<h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-ar' href='./../Overviews/Methods.html#ar'>ar</a> (<span class='argstr'>doneAction: 0</span>, <span class='argstr'>gate: 1</span>, <span class='argstr'>timeScale: 1</span>, <span class='argstr'>mul: 1</span>, <span class='argstr'>add: 0</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-kr' href='./../Overviews/Methods.html#kr'>kr</a> (<span class='argstr'>doneAction: 0</span>, <span class='argstr'>gate: 1</span>, <span class='argstr'>timeScale: 1</span>, <span class='argstr'>mul: 1</span>, <span class='argstr'>add: 0</span>)</h3>
<div class='method'>
<p>Instead of using an <a href="./../Classes/EnvGen.html">EnvGen</a> inside a UGen graph, this message does the same implicitly for convenience. Its argument order corresponds to the most common arguments.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>doneAction<td class='argumentdesc'>
<p>An integer representing an action to be executed when the env is finished playing. This can be used to free the enclosing synth, etc. See <a href="./../Reference/UGen-doneActions.html">UGen done-actions</a> for more detail.<tr><td class='argumentname'>gate<td class='argumentdesc'>
<p>This triggers the envelope and holds it open while &gt; 0. If the Env is fixed-length (e.g. Env.linen, Env.perc), the gate argument is used as a simple trigger. If it is an sustaining envelope (e.g. Env.adsr, Env.asr), the envelope is held open until the gate becomes 0, at which point is released.
<p>If <strong>gate</strong> &lt; 0, force release with time <code class='code prettyprint lang-sc'>-1.0 - gate</code>. See <a href="./../Classes/EnvGen.html#Forced release">EnvGen: Forced release</a> example.<tr><td class='argumentname'>timeScale<td class='argumentdesc'>
<p>Scales the durations of the segments.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>{ Blip.ar(50, 200, Env.perc(1, 0.1, 0.2).kr(2)) }.play;
(
{
    Blip.ar(
        Env({ exprand(3, 2000.0) } ! 18, 0.2, \exp).kr,
        200,
        Env({ rrand(0.1, 0.2) } ! 18 ++ 0, 0.2).kr(2))
    }.play;
)</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-blend' href='./../Overviews/Methods.html#blend'>blend</a> (<span class='argstr'>argAnotherEnv</span>, <span class='argstr'>argBlendFrac: 0.5</span>)</h3>
<div class='method'>
<p>Blend two envelopes. Returns a new Env. See <a href="#blend">blend</a> example below.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>argAnotherEnv<td class='argumentdesc'>
<p>an Env.<tr><td class='argumentname'>argBlendFrac<td class='argumentdesc'>
<p>a number from zero to one.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-delay' href='./../Overviews/Methods.html#delay'>delay</a> (<span class='argstr'>delay</span>)</h3>
<div class='method'>
<p>Returns a new Env based on the receiver in which the start value will be held for <strong>delay</strong> number of seconds.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>delay<td class='argumentdesc'>
<p>The amount of time to delay the start of the envelope.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>a = Env.perc(0.05, 1, 1, -4);
b = a.delay(2);
a.test.plot;
b.test.plot;

a = Env([0.5, 1, 0], [1, 1]).plot;
a.delay(1).plot;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-duration' href='./../Overviews/Methods.html#duration'>duration</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-duration' href='./../Overviews/Methods.html#duration'>duration</a> = <span class='argstr'>dur</span></h3>
<div class='method'>
<p>Set the total duration of times, by stretching them.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>e = Env([0, 1, 0], [1, 2]);
e.duration;
e.duration = 2;
e.duration;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-totalDuration' href='./../Overviews/Methods.html#totalDuration'>totalDuration</a> </h3>
<div class='method'>
<p>Get the total duration of the envelope. In multi-channel envelopes, this is the duration of the longest one.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>e = Env([0, 1, 0], [[1, 2], 2]);
e.duration;
e.totalDuration;</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-circle' href='./../Overviews/Methods.html#circle'>circle</a> (<span class='argstr'>timeFromLastToFirst: 0</span>, <span class='argstr'>curve: 'lin'</span>)</h3>
<div class='method'>
<p>circle from end to beginning over the time specified, with the curve specified. See also the class method <a href="#*circle">*circle</a><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>(
{ SinOsc.ar(
    EnvGen.kr(
        Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle.postcs)
    ) * 0.1
    + Impulse.ar(1) }.play;
)

(
{ SinOsc.ar(
    EnvGen.kr(
        Env([6000, 700, 100], [1, 1], ['exp', 'lin']).circle(1).postcs,
        MouseX.kr &gt; 0.5)
    ) * 0.1
    + Impulse.ar(1) }.play;
)</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-test' href='./../Overviews/Methods.html#test'>test</a> (<span class='argstr'>releaseTime: 3</span>)</h3>
<div class='method'>
<p>Test the envelope on the default <a href="./../Classes/Server.html">Server</a> with a <a href="./../Classes/SinOsc.html">SinOsc</a>.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>releaseTime<td class='argumentdesc'>
<p>If this is a sustaining envelope, it will be released after this much time in seconds. The default is 3 seconds.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-plot' href='./../Overviews/Methods.html#plot'>plot</a> (<span class='argstr'>size: 400</span>, <span class='argstr'>bounds</span>, <span class='argstr'>minval</span>, <span class='argstr'>maxval</span>, <span class='argstr'>name</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/GUI/PlusGUI/Math/PlotView.sc'>/usr/local/share/SuperCollider/SCClassLibrary/Common/GUI/PlusGUI/Math/PlotView.sc</a></div>
<div class='method'>
<p>Plot this envelope's shape in a window.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>size<td class='argumentdesc'>
<p>The size of the plot. The default is 400.<tr><td class='argumentname'>bounds<td class='argumentdesc'>
<p>the size of the plot window.<tr><td class='argumentname'>minval<td class='argumentdesc'>
<p>the minimum value in the plot. Defaults to the lowest value in the data.<tr><td class='argumentname'>maxval<td class='argumentdesc'>
<p>the maximum value in the plot. Defaults to the highest value in the data.<tr><td class='argumentname'>parent<td class='argumentdesc'>
<p>a window to place the plot in. If nil, one will be created for you.</table></div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-asSignal' href='./../Overviews/Methods.html#asSignal'>asSignal</a> (<span class='argstr'>length: 400</span>)</h3>
<div class='method'>
<p>Returns a <a href="./../Classes/Signal.html">Signal</a> of size <strong>length</strong> created by sampling this Env at <strong>length</strong> number of intervals. If the envelope has multiple channels (see <a href="#multichannel expansion">multichannel expansion</a>), this method returns an array of signals.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-asArray' href='./../Overviews/Methods.html#asArray'>asArray</a> </h3>
<div class='method'>
<p>Converts the Env to an <a href="./../Classes/Array.html">Array</a> in a specially ordered format. This allows for Env parameters to be settable arguments in a SynthDef. See example below under <a href="#-newClear">-newClear</a>.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-asMultichannelArray' href='./../Overviews/Methods.html#asMultichannelArray'>asMultichannelArray</a> </h3>
<div class='method'>
<p>Converts the Env to an <a href="./../Classes/Array.html">Array</a> in a specially ordered format, like <a href="#asArray">asArray</a>, however it always returns an array of these data sets, corresponding to the number of channels of the envelope.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-isSustained' href='./../Overviews/Methods.html#isSustained'>isSustained</a> </h3>
<div class='method'>
<p>Returns true if this is a sustaining envelope, false otherwise.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-range' href='./../Overviews/Methods.html#range'>range</a> (<span class='argstr'>lo: 0</span>, <span class='argstr'>hi: 1</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-exprange' href='./../Overviews/Methods.html#exprange'>exprange</a> (<span class='argstr'>lo: 0.01</span>, <span class='argstr'>hi: 1</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-curverange' href='./../Overviews/Methods.html#curverange'>curverange</a> (<span class='argstr'>lo: 0</span>, <span class='argstr'>hi: 1</span>, <span class='argstr'>curve: -4</span>)</h3>
<div class='method'>
<p>Returns a copy of the Env whose levels have been mapped onto the given linear, exponential or curve range.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>a = Env.adsr;
a.levels;
a.range(42, 45).levels;
a.exprange(42, 45).levels;
a.curverange(42, 45, -4).levels;

(
// Mapping an Env to an exponential frequency range:
{
    SinOsc.ar(EnvGen.ar(Env.perc(0.01, 0.7).exprange(40, 10000), doneAction: 2)) * 0.2;
}.play
)</pre>
</div><h3><a class='anchor' name='Client-side Access and Stream Support'>Client-side Access and Stream Support</a></h3>

<p>Sustain and loop settings have no effect in the methods below.<h3 class='imethodname'><span class='methprefix'>-</span><a name='-at' href='./../Overviews/Methods.html#at'>at</a> (<span class='argstr'>time</span>)</h3>
<div class='method'>
<p>Returns the value of the Env at <strong>time</strong>. If the envelope has multiple channels, this method returns an array of levels.<h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>time<td class='argumentdesc'>
<p>A number or an array of numbers to specify a cut in the envelope. If time is an array, it returns the corresponding levels of each time value, and if the envelope has multiple channels, it returns an array of values. A combination of both returns a two-dimensional array.</table><h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>e = Env.triangle(1, 1);
e.at(0.5);
e.at([0.5, 0.7]);

e = Env([1, [1, 2, 3], 1], [1, 1], \exp);
e.at(0.5);
e.at(1.8);
e.at(2);
e.at([0.5, 1.2]);

e = Env([1, 100, 1], [1, [1, 2, 3]], \exp);
e.at(0.5);
e.at(2);
e.at([1, 2, 4]);</pre>
</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-embedInStream' href='./../Overviews/Methods.html#embedInStream'>embedInStream</a> (<span class='argstr'>inval</span>)</h3>
<div class='method'>
<p>Embeds this Env within an enclosing <a href="./../Classes/Stream.html">Stream</a>. Timing is derived from <code class='code prettyprint lang-sc'>thisThread.beats</code>.</div><h3 class='imethodname'><span class='methprefix'>-</span><a name='-asStream' href='./../Overviews/Methods.html#asStream'>asStream</a> </h3>
<div class='method'>
<p>Creates a Routine and embeds the Env in it. This allows the Env to function as a <a href="./../Classes/Stream.html">Stream</a>.<h4>Discussion:</h4>
<pre class='code prettyprint lang-sc'>(
{
e = Env.sine.asStream;
5.do({
    e.next.postln;
    0.25.wait;
})}.fork
)</pre>
</div><h3><a class='anchor' name='Inherited instance methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h3><a class='anchor' name='Undocumented instance methods'>Undocumented instance methods</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-==' href='./../Overviews/Methods.html#=='>==</a> (<span class='argstr'>that</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-array' href='./../Overviews/Methods.html#array'>array</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asArrayForInterpolation' href='./../Overviews/Methods.html#asArrayForInterpolation'>asArrayForInterpolation</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asControlInput' href='./../Overviews/Methods.html#asControlInput'>asControlInput</a> </h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/backwards_compatibility/extMethods.sc'>/usr/local/share/SuperCollider/SCClassLibrary/backwards_compatibility/extMethods.sc</a></div>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asMultichannelSignal' href='./../Overviews/Methods.html#asMultichannelSignal'>asMultichannelSignal</a> (<span class='argstr'>length: 400</span>, <span class='argstr'>class</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asOSCArgEmbeddedArray' href='./../Overviews/Methods.html#asOSCArgEmbeddedArray'>asOSCArgEmbeddedArray</a> (<span class='argstr'>array</span>)</h3>
<div class='extmethod'>From extension in <a href='file:///usr/local/share/SuperCollider/SCClassLibrary/backwards_compatibility/extMethods.sc'>/usr/local/share/SuperCollider/SCClassLibrary/backwards_compatibility/extMethods.sc</a></div>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-asPseg' href='./../Overviews/Methods.html#asPseg'>asPseg</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-curveValue' href='./../Overviews/Methods.html#curveValue'>curveValue</a> (<span class='argstr'>curve</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-curves' href='./../Overviews/Methods.html#curves'>curves</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-curves' href='./../Overviews/Methods.html#curves'>curves</a> = <span class='argstr'>z</span></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-discretize' href='./../Overviews/Methods.html#discretize'>discretize</a> (<span class='argstr'>n: 1024</span>)</h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-hash' href='./../Overviews/Methods.html#hash'>hash</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-levels' href='./../Overviews/Methods.html#levels'>levels</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-levels' href='./../Overviews/Methods.html#levels'>levels</a> = <span class='argstr'>z</span></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-loopNode' href='./../Overviews/Methods.html#loopNode'>loopNode</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-loopNode' href='./../Overviews/Methods.html#loopNode'>loopNode</a> = <span class='argstr'>z</span></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-offset' href='./../Overviews/Methods.html#offset'>offset</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-offset' href='./../Overviews/Methods.html#offset'>offset</a> = <span class='argstr'>z</span></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-releaseNode' href='./../Overviews/Methods.html#releaseNode'>releaseNode</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-releaseNode' href='./../Overviews/Methods.html#releaseNode'>releaseNode</a> = <span class='argstr'>z</span></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-releaseTime' href='./../Overviews/Methods.html#releaseTime'>releaseTime</a> </h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-times' href='./../Overviews/Methods.html#times'>times</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-times' href='./../Overviews/Methods.html#times'>times</a> = <span class='argstr'>z</span></h3>
<h2><a class='anchor' name='examples'>Examples</a></h2>
<pre class='code prettyprint lang-sc'>s.boot;     //.test below will run a synthesis example
        // to demonstrate the envelope, so the Server must be on

// different shaped segments: .plot graphs the Env
Env.new([0,1, 0.3, 0.8, 0], [2, 3, 1, 4],'linear').test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001], [2, 3, 1, 4],'exponential').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],\sine).test.plot;
Env.new([0.001, 1, 0.3, 0.8, 0.001],[2,3,1,4],\welch).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4],'step').test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], -2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], 2).test.plot;
Env.new([0, 1, 0.3, 0.8, 0], [2, 3, 1, 4], [0, 3, -3, -1]).test.plot;</pre>

<p>If a release node is given, and the gate input of the EnvGen is set to zero, it outputs the nodes after the release node:<pre class='code prettyprint lang-sc'>// release node is node 1; takes 0.5 seconds to go from 0 to 1,
// sustains at level of 1, then released after three seconds
// (test causes the release after three seconds, given the argument 3),
// taking 2 seconds to finish
Env.new([0,1,0],[0.5,2],'linear',1).test(3).plot

// more complex examples
// release node is node 2; releases after 5 sec
Env.new([0.001,1,0.3,0.8,0.001],[2,3,1,4] * 0.2, 2, 2).test(5).plot;
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(5).plot;

// early release: goes straight onto the release node after 0.1 seconds
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,3,1,2,2,1] * 0.2, 2, 2).test(0.1).plot;</pre>

<p>If a loop node is given, the EnvGen outputs the nodes between the loop node and the release node (not including the release node itself) until it is released:<pre class='code prettyprint lang-sc'>// release node is node 2, loop node is node 0: so loops around nodes 0 (lvl 1, dur 0.5)
// and 1 (lvl 0.1, dur 0.5)         //until released after 3.5 seconds
Env.new([0,1,0.1,0],[0.5,0.5,2], 'lin', 2, 0).test(3.5).plot;

// this just sustains at node 0, because there is no other node to loop around!
Env.new([0,1,0],[0.5,2], 'lin', 1, 0).test(3.5).plot;

// more complex example: release node is node 3, loop node is node 1
Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.1, 'lin', 3, 1).test(3).plot;

// this is the resulting graph:
(
e = Env.new([0.001,1,0.3,0.8,0.5,0.8,0],[2,1,1,2,3,1] * 0.001, 'lin', 3, 1);
e.plot;{ EnvGen.ar(e, Trig.ar(Impulse.ar(0), 10*0.001)) }.plot(0.02);
)</pre>
<div class='note'><span class='notelabel'>NOTE:</span> The starting level for an envelope segment is always the level you are at right now. For example when the gate is released and you jump to the release segment, the level does not jump to the level at the beginning of the release segment, it changes from whatever the current level is to the goal level of the release segment over the specified duration of the release segment.
<p>There is an extra level at the beginning of the envelope to set the initial level. After that each node is a goal level and a duration, so node zero has duration equal to times[0] and goal level equal to levels[1].
<p>The loop jumps back to the loop node. The endpoint of that segment is the goal level for that segment and the duration of that segment will be the time over which the level changed from the current level to the goal level.</div><h3><a class='anchor' name='blend'>blend</a></h3>
<pre class='code prettyprint lang-sc'>a = Env([0, 0.2, 1, 0.2, 0.2, 0], [0.5, 0.01, 0.01, 0.3, 0.2]);
a.test.plot;

b = Env([0, 0.4, 1, 0.2, 0.5, 0], [0.05, 0.4, [0.01, 0.1], 0.1, 0.4]);
b.test.plot;

(
Task({
    f = (0, 0.2 .. 1);
    f.do { |u|
        blend(a, b, u).test.plot;
        2.wait;
        Window.allWindows.pop.close; // close last opened window
    }
}).play(AppClock);
)

// blend in a SynthDef
(
SynthDef(\help_EnvBlend, { | factor = 0 |
    Out.ar(0, EnvGen.kr(blend(Env.perc, Env.sine, factor), 1.0, doneAction: 2)
        * SinOsc.ar(440,0,0.1)
    )
}).add
);

(
{
    var factors = (0, 0.1..1);
    factors.do {|f| Synth(\help_EnvBlend, [\factor, f.postln]); 1.wait };
}.fork
);</pre>
<div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Classes/Env.schelp'>/usr/local/share/SuperCollider/HelpSource/Classes/Env.schelp</a><br>link::Classes/Env::<br>sc version: 3.8dev</div></div></body></html>
<html><head><title>PackFFT</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CLASSES</div>
<div id='categories'><a href='./../Browse.html#UGens>FFT'>UGens>FFT</a></div>
<h1>PackFFT</h1>
<div id='summary'>Pack separate demand-rate FFT bin streams into an FFT chain buffer</div>
</div>
<div class='subheader'>
<div id='filename'>Source: /usr/local/share/SuperCollider/SCClassLibrary/Common/Audio/<a href='file:///usr/local/share/SuperCollider/SCClassLibrary/Common/Audio/FFTUnpacking.sc'>FFTUnpacking.sc</a></div><div id='superclasses'>Inherits from: <a href="../Classes/PV_ChainUGen.html">PV_ChainUGen</a> : <a href="../Classes/WidthFirstUGen.html">WidthFirstUGen</a> : <a href="../Classes/UGen.html">UGen</a> : <a href="../Classes/AbstractFunction.html">AbstractFunction</a> : <a href="../Classes/Object.html">Object</a></div>
<div id='related'>See also: <a href="./../Classes/UnpackFFT.html">UnpackFFT</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*new'>new</a> </li>
<li class='toc2'><a href='#Inherited class methods'>Inherited class methods</a></li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Inherited instance methods'>Inherited instance methods</a></li>
<li class='toc2'><a href='#Undocumented instance methods'>Undocumented instance methods</a></li>
<ul class='toc'><li class='toc3'><a href='#-fftSize'>fftSize</a> </li>
</ul></ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>

<p>Takes an array of magnitudes and phases, and packs them into an FFT buffer ready for transforming back into time-domain audio using IFFT.
<p>Most people won't need to use this directly - instead, use pvcollect, pvcalc, or pvcalc2 methods from the <a href="./../Classes/PV_ChainUGen.html">PV_ChainUGen</a> base class.<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*new' href='./../Overviews/Methods.html#new'>new</a> (<span class='argstr'>chain</span>, <span class='argstr'>bufsize</span>, <span class='argstr'>magsphases</span>, <span class='argstr'>frombin: 0</span>, <span class='argstr'>tobin</span>, <span class='argstr'>zeroothers: 0</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>chain<td class='argumentdesc'>
<p>The <a href="./../Classes/FFT.html">FFT</a> chain<tr><td class='argumentname'>bufsize<td class='argumentdesc'>
<p>FFT buffer size<tr><td class='argumentname'>magsphases<td class='argumentdesc'>
<p>The input data should be a flat array containing magnitude and phase of all bins in ascending order. e.g. <code class='code prettyprint lang-sc'>[mag0, phase0, mag1, phase1, mag2, phase2, ... magN, phaseN]</code>This input is typically demand-rate.<tr><td class='argumentname'>frombin<td class='argumentdesc'>
<p>restricts the frequency band<tr><td class='argumentname'>tobin<td class='argumentdesc'>
<p>restricts the frequency band<tr><td class='argumentname'>zeroothers<td class='argumentdesc'>
<p>set to 1 to zero all the magnitudes outside the restricted frequency band</table><h4>Discussion:</h4>

<p>This is technically similar to Demand or Duty in that it calls demand-rate UGens further up the graph to process the values, eventually calling UnpackFFT. These two ends of the process must in most cases see the same chain...! Otherwise behaviour is undefined and, who knows, possibly unpleasant.
<p>Optional parameters: frombin and tobin allow you to fill the supplied data only into a subset of the FFT bins (i.e. a single delimited frequency band), and if you do this, you can also optionally set zeroothers to 1 to zero all the magnitudes outside this band (otherwise they stay intact).</div><h3><a class='anchor' name='Inherited class methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3><a class='anchor' name='Inherited instance methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h3><a class='anchor' name='Undocumented instance methods'>Undocumented instance methods</a></h3>
<h3 class='imethodname'><span class='methprefix'>-</span><a name='-fftSize' href='./../Overviews/Methods.html#fftSize'>fftSize</a> </h3>
<h2><a class='anchor' name='examples'>Examples</a></h2>

<p>Here's an unusual example which uses PackFFT without using UnpackFFT first - essentially creating our FFT data from scratch.<pre class='code prettyprint lang-sc'>// Reminder: This isn't the intended typical usage! It's OK to do this though.
(
x = {
    var mags, phases, chain, sig;
    // Create simple undulating magnitudes
    mags = {FSinOsc.kr(ExpRand(0.1, 1)).range(0, 1)}.dup(100);
    // Then give them a "rolloff" to make the sound less unpleasant
    mags = mags  * ((1, 0.99 .. 0.01).squared);
    // Let's turn the bins on and off at different rates, I'm *sure* that'll sound interesting
    mags = mags * {LFPulse.kr(2 ** IRand(-3, 5)).range(0, 1)}.dup(100);
    // Let's ignore phase for now
    phases = 0.dup(100);
    // We need to create an FFT chain to feed our data in to.
    // The easiest way is to do an FFT on some signal which we then ignore!
    chain = FFT(LocalBuf(512), FSinOsc.ar);
    // Now we can do the packing
    chain = PackFFT(chain, 512, [mags, phases].flop.flatten, 0, 99, 1);
    sig = IFFT(chain);
    Out.ar(0, sig.dup);
}.play(s);
)
x.free;</pre>
<div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/HelpSource/Classes/PackFFT.schelp'>/usr/local/share/SuperCollider/HelpSource/Classes/PackFFT.schelp</a><br>link::Classes/PackFFT::<br>sc version: 3.8dev</div></div></body></html>
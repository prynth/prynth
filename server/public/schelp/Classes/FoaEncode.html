<html><head><title>FoaEncode</title>
<link rel='stylesheet' href='./../scdoc.css' type='text/css' />
<link rel='stylesheet' href='./../frontend.css' type='text/css' />
<link rel='stylesheet' href='./../custom.css' type='text/css' />
<meta http-equiv='Content-Type' content='text/html; charset=UTF-8' />
<script src='./../scdoc.js' type='text/javascript'></script>
<script src='./../docmap.js' type='text/javascript'></script>
<script src='./../prettify.js' type='text/javascript'></script>
<script src='./../lang-sc.js' type='text/javascript'></script>
<script type='text/javascript'>var helpRoot='./..';</script>
</head>
<ul id='menubar'></ul>
<body onload='fixTOC();prettyPrint()'>
<div class='contents'>
<div class='header'>
<div id='label'>SuperCollider CLASSES (extension)</div>
<div id='categories'><a href='./../Browse.html#Libraries>Ambisonic Toolkit>FOA>Encoding'>Libraries>Ambisonic Toolkit>FOA>Encoding</a>, <a href='./../Browse.html#UGens>Multichannel>Ambisonics'>UGens>Multichannel>Ambisonics</a></div>
<h1>FoaEncode</h1>
<div id='summary'>First Order Ambisonic (FOA) encoder</div>
</div>
<div class='subheader'>
<div id='filename'>Source: /usr/local/share/SuperCollider/Extensions/SC3plugins/ATK/Classes/<a href='file:///usr/local/share/SuperCollider/Extensions/SC3plugins/ATK/Classes/ATK.sc'>ATK.sc</a></div><div id='superclasses'>Inherits from: <a href="../Classes/FoaUGen.html">FoaUGen</a> : <a href="../Classes/Object.html">Object</a></div>
<div id='related'>See also: <a href="./../Classes/FoaEncoderMatrix.html">FoaEncoderMatrix</a>, <a href="./../Classes/FoaEncoderKernel.html">FoaEncoderKernel</a></div>
</div>
<div id='toc'>
<ul class='toc'><li class='toc1'><a href='#description'>Description</a></li>
<ul class='toc'></ul><li class='toc1'><a href='#classmethods'>Class methods</a></li>
<ul class='toc'><li class='toc3'><a href='#*ar'>ar</a> </li>
<li class='toc2'><a href='#Inherited class methods'>Inherited class methods</a></li>
</ul><li class='toc1'><a href='#instancemethods'>Instance methods</a></li>
<ul class='toc'><li class='toc2'><a href='#Inherited instance methods'>Inherited instance methods</a></li>
</ul><li class='toc1'><a href='#examples'>Examples</a></li>
<ul class='toc'><li class='toc2'><a href='#Choose a decoder'>Choose a decoder</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Omnidirectional encoder'>Omnidirectional encoder</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Frequency spreading encoder'>Frequency spreading encoder</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Frequency diffusion encoder'>Frequency diffusion encoder</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#A to B encoder'>A to B encoder</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#A to B encoder (soundfile)'>A to B encoder (soundfile)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Stereophonic encoder'>Stereophonic encoder</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Stereophonic encoder (soundfile)'>Stereophonic encoder (soundfile)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Super Stereo encoder (soundfile)'>Super Stereo encoder (soundfile)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Ambisonic UHJ stereo encoder (soundfile)'>Ambisonic UHJ stereo encoder (soundfile)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#ZoomH2 encoder (soundfile)'>ZoomH2 encoder (soundfile)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#ZoomH2 encoder, reversed (soundfile)'>ZoomH2 encoder, reversed (soundfile)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Pantophonic encoder (soundfile)'>Pantophonic encoder (soundfile)</a></li>
<ul class='toc'></ul><li class='toc2'><a href='#Directions encoder (soundfile)'>Directions encoder (soundfile)</a></li>
<ul class='toc'></ul></ul></ul></div><h2><a class='anchor' name='description'>Description</a></h2>

<p>Encodes signals in a variety of configurations to a first order ambisonic signal (B-format). <a href="./../Classes/PanB.html">PanB</a> is a SuperCollider inbuilt equivalent.<h2><a class='anchor' name='classmethods'>Class Methods</a></h2>
<h3 class='cmethodname'><span class='methprefix'>*</span><a name='*ar' href='./../Overviews/Methods.html#ar'>ar</a> (<span class='argstr'>in</span>, <span class='argstr'>encoder</span>, <span class='argstr'>mul: 1</span>, <span class='argstr'>add: 0</span>)</h3>
<div class='method'>
<p><h4>Arguments:</h4>
<table class='arguments'>
<tr><td class='argumentname'>in<td class='argumentdesc'>
<p>The input signal, an array: [in0, in1, ... inN]<tr><td class='argumentname'>encoder<td class='argumentdesc'>
<p><a href="./../Classes/FoaEncoderMatrix.html">FoaEncoderMatrix</a> or <a href="./../Classes/FoaEncoderKernel.html">FoaEncoderKernel</a> instance.<tr><td class='argumentname'>mul<td class='argumentdesc'>
<p>Output will be multiplied by this value.<tr><td class='argumentname'>add<td class='argumentdesc'>
<p>This value will be added to the output.</table><h4>Returns:</h4>
<div class='returnvalue'>
<p>A B-format signal as an array of channels: [w, x, y, z]</div></div><h3><a class='anchor' name='Inherited class methods'>Inherited class methods</a></h3>
<div id='inheritedclassmets'></div><h2><a class='anchor' name='instancemethods'>Instance Methods</a></h2>
<h3><a class='anchor' name='Inherited instance methods'>Inherited instance methods</a></h3>
<div id='inheritedinstmets'></div><h2><a class='anchor' name='examples'>Examples</a></h2>

<p>The examples below are intended to briefly illustrate some of the first order encoding options made available in the Ambisonic Toolkit. The user is encouraged to carefully review the features of <a href="./../Classes/FoaEncoderMatrix.html">FoaEncoderMatrix</a> and <a href="./../Classes/FoaEncoderKernel.html">FoaEncoderKernel</a> to gain a deeper understanding of the flexibility of these tools.
<p>Available encoders include monophonic (as an omnidirectional soundfield, planewave or frequency spreading), stereophonic and varieties of pantophonic (2D surround) and periphonic (3D surround). Additionally, microphone array encoding is also supported.
<p>As the Ambisonic technique is a hierarchal system, numerous options for playback are possible. These include two channel stereo, two channel binaural, pantophonic and full 3D periphonic. With the examples below, we'll take advantage of this by first choosing a suitable decoder with with to audition.<h3><a class='anchor' name='Choose a decoder'>Choose a decoder</a></h3>

<p>Choose a decoder suitable for your system, as illustrated <a href="./../Guides/Intro-to-the-ATK.html#choose_a_decoder">here</a>. You'll end up definining <code class='code prettyprint lang-sc'>~decoder</code> and <code class='code prettyprint lang-sc'>~renderDecode</code> .<div class='note'><span class='notelabel'>NOTE:</span> If you choose a kernel decoder, <a href="./../Classes/FoaDecoderKernel.html">FoaDecoderKernel</a>, be sure to free the kernel after use.</div><h3><a class='anchor' name='Omnidirectional encoder'>Omnidirectional encoder</a></h3>

<p>Encoded as an omnidirectional soundfield, <a href="./../Classes/PinkNoise.html">PinkNoise</a> is used as the example sound source. In a well aligned, dampend studio environment, this usually sounds "in the head". <a href="./../Classes/FoaPush.html">FoaPush</a> is used to "push" the omnidirectional soundfield so that it becomes a planewave (infinite distance, in an anechoic environment) arriving from some direction.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the incident azimuth angle (pi to -pi; left to right of display) and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaPush.html">FoaPush</a> angle (0 to pi/2; bottom to top of display). With the mouse at the bottom of the display, the soundfield remains omnidirectional. Placed at the top of the display, the soundfield becomes directional, and varying left/right position will vary the incident azimuth of the resulting planewave.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newOmni">FoaEncoderMatrix: *newOmni</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// omni encoder
// mono pink noise source


// define encoder matrix
~encoder = FoaEncoderMatrix.newOmni

// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels

(
{
    var sig;                            // audio signal
    var angle, azim;                    // angle and azimuth control


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // angle ---&gt; top           = push to plane wave
    //            bottom        = omni-directional
    angle = MouseY.kr(pi/2, 0);

    // azimuth -&gt; hard left     = back
    //            centre        = centre
    //            hard right    = back
    azim = MouseX.kr(pi, -pi);

    // ------------------------------------------------------------
    // test sig
    sig = PinkNoise.ar;                         // mono pink noise


    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, 'push', angle, azim);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------</pre>
<h3><a class='anchor' name='Frequency spreading encoder'>Frequency spreading encoder</a></h3>

<p>Encoded as a frequency spread soundfield, <a href="./../Classes/PinkNoise.html">PinkNoise</a> is used as the example sound source. This sounds as spread across the soundfield, with the various frequency components appearing in various places. <a href="./../Classes/FoaPush.html">FoaPush</a> is used to "push" the omnidirectional soundfield so that it becomes a planewave (infinite distance, in an anechoic environment) arriving from some direction.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the incident azimuth angle (pi to -pi; left to right of display) and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaPush.html">FoaPush</a> angle (0 to pi/2; bottom to top of display). With the mouse at the bottom of the display, the soundfield remains spread. Placed at the top of the display, the soundfield becomes directional, and varying left/right position will vary the incident azimuth of the resulting planewave.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A kernel type encoder, see <a href="./../Classes/FoaEncoderKernel.html#*newSpread">FoaEncoderKernel: *newSpread</a> for further details.</div><div class='warning'><span class='warninglabel'>WARNING:</span> Kernel encoders require special care. Allow the kernel time to load before attempting to use. Additionally, the kernel buffer should be freed through the use of <a href="./../Classes/FoaEncoderKernel.html#-free">FoaEncoderKernel: -free</a> after use.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// frequency spreading encoder
// mono pink noise source


// define encoder kernel
~encoder = FoaEncoderKernel.newSpread

// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels

(
{
    var sig;                            // audio signal
    var angle, azim;                    // angle and azimuth control


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // angle ---&gt; top           = push to plane wave
    //            bottom        = omni-directional
    angle = MouseY.kr(pi/2, 0);

    // azimuth -&gt; hard left     = back
    //            centre        = centre
    //            hard right    = back
    azim = MouseX.kr(pi, -pi);

    // ------------------------------------------------------------
    // test sig
    sig = PinkNoise.ar;                         // mono pink noise


    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, 'push', angle, azim);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------

// free kernel
~encoder.free</pre>
<h3><a class='anchor' name='Frequency diffusion encoder'>Frequency diffusion encoder</a></h3>

<p>Encoded as a frequency diffused soundfield, <a href="./../Classes/PinkNoise.html">PinkNoise</a> is used as the example sound source. This sounds as diffused across the soundfield, with the various frequency components appearing in various places, with various phases. <a href="./../Classes/FoaPush.html">FoaPush</a> is used to "push" the omnidirectional soundfield so that it becomes a planewave (infinite distance, in an anechoic environment) arriving from some direction.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the incident azimuth angle (pi to -pi; left to right of display) and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaPush.html">FoaPush</a> angle (0 to pi/2; bottom to top of display). With the mouse at the bottom of the display, the soundfield remains spread. Placed at the top of the display, the soundfield becomes directional, and varying left/right position will vary the incident azimuth of the resulting planewave.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A kernel type encoder, see <a href="./../Classes/FoaEncoderKernel.html#*newDiffuse">FoaEncoderKernel: *newDiffuse</a> for further details.</div><div class='warning'><span class='warninglabel'>WARNING:</span> Kernel encoders require special care. Allow the kernel time to load before attempting to use. Additionally, the kernel buffer should be freed through the use of <a href="./../Classes/FoaEncoderKernel.html#-free">FoaEncoderKernel: -free</a> after use.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// frequency diffusion encoder
// mono pink noise source


// define encoder kernel
~encoder = FoaEncoderKernel.newDiffuse

// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels

(
{
    var sig;                            // audio signal
    var angle, azim;                    // angle and azimuth control


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // angle ---&gt; top           = push to plane wave
    //            bottom        = omni-directional
    angle = MouseY.kr(pi/2, 0);

    // azimuth -&gt; hard left     = back
    //            centre        = centre
    //            hard right    = back
    azim = MouseX.kr(pi, -pi);

    // ------------------------------------------------------------
    // test sig
    sig = PinkNoise.ar;                         // mono pink noise


    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, 'push', angle, azim);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------

// free kernel
~encoder.free</pre>
<h3><a class='anchor' name='A to B encoder'>A to B encoder</a></h3>

<p>Here we encode four channels of decorrelated <a href="./../Classes/PinkNoise.html">PinkNoise</a> as a decorrelated soundfield, resulting in a maximally diffuse soundfield. <a href="./../Classes/FoaPush.html">FoaPush</a> is used to "push" the soundfield so that it becomes a planewave (infinite distance, in an anechoic environment) arriving from some direction. This technique gives the opportunity to continuously modulate between a directional and a diffuse soundfield.
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the incident azimuth angle (pi to -pi; left to right of display) and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaPush.html">FoaPush</a> angle (0 to pi/2; bottom to top of display). With the mouse at the bottom of the display, the soundfield remains omnidirectional. Placed at the top of the display, the soundfield becomes directional, and varying left/right position will vary the incident azimuth of the resulting planewave.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newAtoB">FoaEncoderMatrix: *newAtoB</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// A to B encoder
// decorrelated pink noise source


// define encoder matrix
~encoder = FoaEncoderMatrix.newAtoB

// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels

(
{
    var sig;                // audio signal
    var angle, azim;            // angle and azimuth control


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // angle ---&gt; top         = push to plane wave
    //          bottom    = omni-directional
    angle = MouseY.kr(pi/2, 0);

    // azimuth -&gt; hard left     = back
    //          centre     = centre
    //          hard right     = back
    azim = MouseX.kr(pi, -pi);

    // ------------------------------------------------------------
    // test sig
    sig = -3.dbamp * PinkNoise.ar([1, 1, 1, 1]); // 4 channels decorrelated pink noise


    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, 'push', angle, azim);



    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)
// ------------------------------------------------------------</pre>
<h3><a class='anchor' name='A to B encoder (soundfile)'>A to B encoder (soundfile)</a></h3>

<p>This example is somewhat unconvential as regards the literature. Four microphones (omnis) are place around the performer in a tetrahedron. This is then matrixed into B-format.
<p>As the performer rotates and moves about, the image shifts through the sound-scene. In a compositional context, <a href="./../Classes/FoaPush.html">FoaPush</a> could be used to control the soundfield.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newAtoB">FoaEncoderMatrix: *newAtoB</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// A to B encoder
// A-format soundfile read from disk

// define encoder matrix
~encoder = FoaEncoderMatrix.newAtoB('flrd')   // for Thomas
~encoder = FoaEncoderMatrix.newAtoB('flr')    // for Cross


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/a-format/Thomas_Mackay.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/a-format/Cross_Tenor_Sax.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>Niall Thomas, "Rob Mackay: flute improvisations," [unpublished recording]<li>David Cross, "Tenor saxophone improvisations," [unpublished recording]</ul>
</div><h3><a class='anchor' name='Stereophonic encoder'>Stereophonic encoder</a></h3>

<p>In this example we first encode a single channel of <a href="./../Classes/PinkNoise.html">PinkNoise</a> into a stereophonic signal with <a href="./../Classes/Pan2.html">Pan2</a>. <a href="./../Classes/FoaZoom.html">FoaZoom</a> is then used to balance the soundfield across the x-axis (front/back).
<p>The soundfield is controlled by <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a>, where <a href="./../Classes/MouseX.html">MouseX</a> specifies the left to right position of the stereo panned source and <a href="./../Classes/MouseY.html">MouseY</a> the <a href="./../Classes/FoaZoom.html">FoaZoom</a> front to back position (distortion angle). Moving the mouse in a circular motion results in a circular motion of the sound.<a class='footnote anchor' name='footnote_org_1' href='#footnote_1'><sup>1</sup></a> 
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newStereo">FoaEncoderMatrix: *newStereo</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// stereo encoder
// stereo panned mono pink noise source


// define encoder matrix
~encoder = FoaEncoderMatrix.newStereo


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi

(
{
    var sig;                            // audio signal
    var angle, azim;                    // angle and azimuth control


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // angle ---&gt; top           = zoom to plane wave at front
    //            bottom        = zoom to plane wave at back
    angle = MouseY.kr(pi/2, pi.neg/2);

    // azimuth -&gt; hard left     = back
    //            centre        = centre
    //            hard right    = back
    azim = MouseX.kr(pi, -pi);

    // ------------------------------------------------------------
    // test sig
    sig = PinkNoise.ar;                                 // mono pink noise

    // ------------------------------------------------------------
    // pan (encode) to stereo
    sig = Pan2.ar(sig, azim.neg/pi);

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);

    // ------------------------------------------------------------
    // transform
    sig = FoaTransform.ar(sig, 'zoom', angle);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free kernel
~encoder.free

// ------------------------------------------------------------</pre>
<h3><a class='anchor' name='Stereophonic encoder (soundfile)'>Stereophonic encoder (soundfile)</a></h3>

<p>For this example we'll look at encoding stereo soundfiles.
<p>The stereo encoder places the left channel at +pi/4 and the right at -pi/4. Compare to the <a href="./../Classes/FoaEncoderKernel.html#*newSuper">Super Stereo</a> encoder <a href="#super_stereo_encoder_(soundfile)">below</a>.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newStereo">FoaEncoderMatrix: *newStereo</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// stereo encoder
// stereo soundfile read from disk


// define encoder matrix
~encoder = FoaEncoderMatrix.newStereo(pi/4)


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/The_City_Waites-The_Downfall.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/The_City_Waites-An_Old.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/Aurora_Surgit-Lux_Aeterna.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/Aurora_Surgit-Dies_Irae.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>The City Waites, "The Downfall of Dancing," Penny Merriments, NAXOS 8.557672<li>The City Waites, "An Old Song on the Spanish Armada," Penny Merriments, NAXOS 8.557672<li>Aurora Surgit, "Lux aeterna," Ego sum Resurrectio, NAXOS 8.557672<li>Aurora Surgit, "Dies irae," Ego sum Resurrectio, NAXOS 8.557672</ul>
</div><h3><a class='anchor' name='Super Stereo encoder (soundfile)'>Super Stereo encoder (soundfile)</a></h3>

<p>Super Stereo<a class='footnote anchor' name='footnote_org_2' href='#footnote_2'><sup>2</sup></a>  is the classic Ambisonic method to encode stereophonic files, and is considered to be optimal for frontal stereo encoding.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A kernel type encoder, see <a href="./../Classes/FoaEncoderKernel.html#*newSuper">FoaEncoderKernel: *newSuper</a> for further details.</div><div class='warning'><span class='warninglabel'>WARNING:</span> Kernel encoders require special care. Allow the kernel time to load before attempting to use. Additionally, the kernel buffer should be freed through the use of <a href="./../Classes/FoaEncoderKernel.html#-free">FoaEncoderKernel: -free</a> after use.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// super stereo encoder
// stereo soundfile read from disk


// define encoder matrix
~encoder = FoaEncoderKernel.newSuper


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/The_City_Waites-The_Downfall.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/The_City_Waites-An_Old.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/Aurora_Surgit-Lux_Aeterna.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/stereo/Aurora_Surgit-Dies_Irae.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free kernel &amp; buffer
~encoder.free
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>The City Waites, "The Downfall of Dancing," Penny Merriments, NAXOS 8.557672<li>The City Waites, "An Old Song on the Spanish Armada," Penny Merriments, NAXOS 8.557672<li>Aurora Surgit, "Lux aeterna," Ego sum Resurrectio, NAXOS 8.557672<li>Aurora Surgit, "Dies irae," Ego sum Resurrectio, NAXOS 8.557672</ul>
</div><h3><a class='anchor' name='Ambisonic UHJ stereo encoder (soundfile)'>Ambisonic UHJ stereo encoder (soundfile)</a></h3>

<p><a href="http://en.wikipedia.org/wiki/Ambisonic_UHJ_format">Ambisonic UHJ</a> is the stereo format for Ambisonics.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A kernel type encoder, see <a href="./../Classes/FoaEncoderKernel.html#*newUHJ">FoaEncoderKernel: *newUHJ</a> for further details.</div><div class='warning'><span class='warninglabel'>WARNING:</span> Kernel encoders require special care. Allow the kernel time to load before attempting to use. Additionally, the kernel buffer should be freed through the use of <a href="./../Classes/FoaEncoderKernel.html#-free">FoaEncoderKernel: -free</a> after use.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// ambisonic uhj stereo encoder
// stereo soundfile read from disk


// define encoder matrix
~encoder = FoaEncoderKernel.newUHJ


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/uhj/Palestrina-O_Bone.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/uhj/Gabrieli-Canzon_Duodecimi.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/uhj/Cante_Flamenco-Alegrias.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/uhj/Waldteufel-The_Skaters.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free kernel &amp; buffer
~encoder.free
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>Christ Church Cathedral Choir, "Palestrina: O Bone Jesu, exaudi me," Ambisonic Sampler, NI 1417<li>The Wallace Collection, "Gabrieli: Canzon Duodecimi Toni a 10 (No 2)," Ambisonic Sampler, NI 1417<li>C. Lobato, J. del Gastor, &amp; P. del Gastor, "Alegrias," Ambisonic Sampler, NI 1417<li>The Gulbenkian Orchestra, "Waldteufel: The Skaters' Waltz," Ambisonic Sampler, NI 1417</ul>
</div><h3><a class='anchor' name='ZoomH2 encoder (soundfile)'>ZoomH2 encoder (soundfile)</a></h3>

<p>The <a href="http://www.zoom.co.jp/english/products/h2/">ZoomH2</a> is a convenient, portable handheld recorder. The device only records horizontal surround (pantophonic), so we don't get height.
<p>As a relatively inexpensive piece of equipment, the imaging of the <a href="http://www.zoom.co.jp/english/products/h2/">ZoomH2</a> isn't always as consistent as we'd prefer. To remedy, the Y gain is tweaked to widen the image, and <a href="./../Classes/FoaXformerMatrix.html#*newDominateX">dominance</a> is applied to stabilise the front.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newZoomH2">FoaEncoderMatrix: *newZoomH2</a> and <a href="./../Classes/FoaXformerMatrix.html#*newDominateX">FoaXformerMatrix: *newDominateX</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// zoomH2 encoder
// zoomH2 soundfile read from disk


// define encoder and xform matricies
~encoder = FoaEncoderMatrix.newZoomH2(k: 1.7378)
~xformer = FoaXformerMatrix.newDominateX(3.0)

// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/zoomh2/Anderson-Waltz.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/zoomh2/Anderson-Steam.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/zoomh2/Anderson-Stape_Silver.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/zoomh2/Anderson-St_Peter_&amp;_St_Paul.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // xform
    sig = FoaXform.ar(sig, ~xformer);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>Joseph Anderson, "Pickering Steam Fair: Waltz," [unpublished recording]<li>Joseph Anderson, "Pickering Steam Fair: Engine," [unpublished recording]<li>Joseph Anderson, "Stape Silver Band: March," [unpublished recording]<li>Joseph Anderson, "St Peter &amp; St Paul," [unpublished recording]</ul>
</div><h3><a class='anchor' name='ZoomH2 encoder, reversed (soundfile)'>ZoomH2 encoder, reversed (soundfile)</a></h3>

<p>As described <a href="./../Classes/FoaEncoderMatrix.html#*newZoomH2">here</a>, the <a href="http://www.zoom.co.jp/english/products/h2/">ZoomH2</a> encoder reverses the labels for front and back of the <a href="http://www.zoom.co.jp/english/products/h2/">ZoomH2</a>. This is done to favour the use of the decoder as a roving, hand-held device, with the display facing the operator.
<p>If one wishes to respect the labelled orientation of the device as does <a href="http://www.radio.uqam.ca/ambisonic/comparative_recording.html">Courville</a> in the example below, we'll need to either adjust the <strong>angles</strong> argument or apply <a href="./../Classes/FoaXform.html#*newMirrorX">FoaXform: *newMirrorX</a>. For this example, we'll set <strong>angles</strong> = <code class='code prettyprint lang-sc'>[3/4*pi, pi/3]</code>, which are those specified in the <a href="http://www.zoom.co.jp/downloads/h2/manual/">ZoomH2 documentation</a>.
<p>As a relatively inexpensive piece of equipment, the imaging of the <a href="http://www.zoom.co.jp/english/products/h2/">ZoomH2</a> isn't always as consistent as we'd prefer. To remedy, the Y gain is tweaked to widen the image.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newZoomH2">FoaEncoderMatrix: *newZoomH2</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// zoomH2 encoder
// zoomH2 soundfile read from disk


// define encoder matrix
~encoder = FoaEncoderMatrix.newZoomH2([3/4*pi, pi/3], 1.7378)

// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/zoomh2/Courville-Dialogue.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>D. Courville, "Comparative Surround Recording," Ambisonic Studio | Comparative Surround Recording, 2007. [Online]. Available: <a href="http://www.radio.uqam.ca/ambisonic/comparative_recording.html">http://www.radio.uqam.ca/ambisonic/comparative_recording.html</a> [Accessed: 26-Jul-2011].</ul>
</div><h3><a class='anchor' name='Pantophonic encoder (soundfile)'>Pantophonic encoder (soundfile)</a></h3>

<p>The pantophonic encoder may be used to transcode from one format to another. This example transcodes an octophonic recording to the decoder you've chosen.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newPanto">FoaEncoderMatrix: *newPanto</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// pantophonic (8-channel) encoder
// pantophonic (8-channel) soundfile read from disk


// define encoder matrix
~encoder = FoaEncoderMatrix.newPanto(8, 'flat')   // choose for Mackay
~encoder = FoaEncoderMatrix.newPanto(8, 'point')  // choose for Young


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/multichannel/Mackay-Augustines_Message.wav")
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/multichannel/Young-Allting_Runt.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>Robert Mackay, "Augustine's Message," [unpublished recording]<li>John Young, "Allting Runt Omkring," [unpublished recording]</ul>
</div><h3><a class='anchor' name='Directions encoder (soundfile)'>Directions encoder (soundfile)</a></h3>

<p>The directions encoder may be used to transcode from one format to another. This example transcodes a periphonic 12-channel recording to the decoder you've chosen.
<p>If you haven't already choosen a <code class='code prettyprint lang-sc'>~decoder</code> and defined <code class='code prettyprint lang-sc'>~renderDecode</code>, do so <a href="#choose_a_decoder">now</a>.<div class='note'><span class='notelabel'>NOTE:</span> A matrix type encoder, see <a href="./../Classes/FoaEncoderMatrix.html#*newPanto">FoaEncoderMatrix: *newPanto</a> for further details.</div><pre class='code prettyprint lang-sc'>// ------------------------------------------------------------
// periphonic (12-channel) encoder


// define encoder matrix
~directions = pi / 180 * [ [ 22.5, 0 ], [ -22.5, 0 ], [ 67.5, 0 ], [ -67.5, 0 ], [ 112.5, 0 ], [ -112.5, 0 ], [ 157.5, 0 ], [ -157.5, 0 ], [ 45, 45 ], [ -45, 45 ], [ -135, 45 ], [ 135, 45 ] ]
~encoder = FoaEncoderMatrix.newDirections(~directions)


// inspect
~encoder.kind
~encoder.numChannels
~encoder.dirChannels * 180/pi


// read a whole sound into memory
// remember to free the buffer later!
// (boot the server, if you haven't!)
~sndbuf = Buffer.read(s, Atk.userSoundsDir ++ "/multichannel/Wilson-Bose.wav")


(
{
    var sig;                            // audio signal


    // display encoder and decoder
    "Ambisonic encoding via % encoder".format(~encoder.kind).postln;
    "Ambisonic decoding via % decoder".format(~decoder.kind).postln;

    // ------------------------------------------------------------
    // test sig
    sig = PlayBuf.ar(~sndbuf.numChannels, ~sndbuf, doneAction:2);   // soundfile

    // ------------------------------------------------------------
    // encode
    sig = FoaEncode.ar(sig, ~encoder);


    // ------------------------------------------------------------
    // decode (via ~renderDecode)
    ~renderDecode.value(sig, ~decoder)

}.scope;
)

// free buffer
~sndbuf.free
// ------------------------------------------------------------</pre>
<div class='note'><span class='notelabel'>NOTE:</span> <strong>Soundfile Credits</strong><ul>
<li>Scott Wilson, "BÃ¶se," [unpublished recording]</ul>
</div>
<p><div class='footnotes'>
<a class='anchor' name='footnote_1'/><div class='footnote'>[<a href='#footnote_org_1'>1</a>] - We don't advise using this approach for encoding monophonic sources. The technique illustrated <a href="#omnidirectional_encoder">here</a> is the idiomatic method. If one desires a similar use of the mouse, <a href="./../Classes/MouseX.html">MouseX</a> and <a href="./../Classes/MouseY.html">MouseY</a> can be mapped appropriately to <a href="./../Classes/FoaPush.html">FoaPush</a>'s <strong>angle</strong>, <strong>theta</strong>, and <strong>phi</strong> parameters.</div><a class='anchor' name='footnote_2'/><div class='footnote'>[<a href='#footnote_org_2'>2</a>] - See: <a href="http://en.wikipedia.org/wiki/Ambisonics#Super_stereo">http://en.wikipedia.org/wiki/Ambisonics#Super_stereo</a></div></div><div class='doclink'>source: <a href='file:///usr/local/share/SuperCollider/Extensions/SC3plugins/ATK/HelpSource/Classes/FoaEncode.schelp'>/usr/local/share/SuperCollider/Extensions/SC3plugins/ATK/HelpSource/Classes/FoaEncode.schelp</a><br>link::Classes/FoaEncode::<br>sc version: 3.8dev</div></div></body></html>
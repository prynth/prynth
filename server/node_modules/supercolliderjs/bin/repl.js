#!/usr/bin/env node
/* eslint no-console: 0 */
var help = [
  'Run sclang (the supercollider language interpreter) using the configuration defined in the nearest .supercollider.yaml searching up from the current working directory.',
  '',
  'By default evaluates STDIN and posts to STDOUT. This is a simple command line repl without multi-line support.',
  '',
  'Examples:',
  '',
  'supercollider',
  'supercollider run-this-file.scd',
  'supercollider --config=/path/to/a/custom/config.yaml',
  'supercollider --stdin=false --echo=false --sclang=/path/to/sclang',
  ''
];

var
    join = require('path').join,
    pkg = require(join(__dirname, '../package.json')),
      lib = join(__dirname, '../lib/js/'),
    program = require('commander'),
    sclang = require(lib + 'sclang'),
    options = {},

    repl = require('repl');

function truthy(input) {
  return (input + '') !== 'false';
}

program.version(pkg.version)
  .option('--config <path>', 'Configuration file eg. .supercollider.yaml')
  .option('--sclang <path>', 'Path to sclang executable')
  .option('--langPort <port>', 'UDP port for the interpreter to listen on')
  .option('--stdin <bool>', 'Interpret STDIN (default: true)', truthy, false)
  .option('--echo <bool>', 'Echo STDIN to STDOUT (default: true)', truthy, false)
  .option('-v, --verbose', 'Post debugging messages (default: false)',
    truthy, false);

program.on('--help', function() {
  help.forEach(function(line) {
    console.info('    ' + line);
  });
});

program.parse(process.argv);

['config', 'sclang', 'langPort', 'stdin', 'echo', 'verbose'].forEach(
  function(k) {
    if (k in program) {
      options[k] = program[k];
    }
  });

// pass a filename for sclang to execute
if (program.args.length) {
  options.executeFile = program.args[0];
}


function startRepl(sc) {

  function interpret(cmd, context, filename, callback) {
    sc.interpret(cmd)
      .then(function(result) {
        // everything is a string
        callback(null, result);
      }, function(error) {
        callback(null, error);
        // console.log(error);
      });
  }


  // var readline = require('readline'),
  //     rl = readline.createInterface(process.stdin, process.stdout);
  //
  // rl.setPrompt('OHAI> ');
  // rl.prompt();
  //
  // rl.on('line', function(line) {
  //   switch(line.trim()) {
  //     case 'hello':
  //       console.log('world!');
  //       break;
  //     default:
  //       console.log('Say what? I might have heard `' + line.trim() + '`');
  //       break;
  //   }
  //   rl.prompt();
  // }).on('close', function() {
  //   console.log('Have a great day!');
  //   process.exit(0);
  // });

  repl.start({
    // prompt: "> ",
    input: process.stdin,
    output: process.stdout,
    eval: interpret
  });

  // http://nodejs.org/api/net.html#net_net_createserver_options_connectionlistener
  // net.createServer(function (socket) {
  //   connections += 1;
  //   repl.start({
  //     prompt: "supercollider via Unix socket> ",
  //     input: socket,
  //     output: socket
  //   }).on('exit', function() {
  //     socket.end();
  //   });
  // }).listen("/tmp/node-repl-sock");
  //
  // net.createServer(function (socket) {
  //   connections += 1;
  //   repl.start({
  //     prompt: "supercollider via TCP socket> ",
  //     input: socket,
  //     output: socket
  //   }).on('exit', function() {
  //     socket.end();
  //   });
  // }).listen(5001);
  // return a destructor
}

sclang.boot(options)
  .then(function(l) {
    startRepl(l);
    l.on('exit', function() {
      console.warn('sclang exited');
      console.info(options);
      process.exit(1);
    });
    l.on('stdout', function(out) {
      console.log(out);
    });
  });

'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _Errors = require('./Errors');

var _Errors2 = _interopRequireDefault(_Errors);

var _logger = require('./utils/logger');

var _logger2 = _interopRequireDefault(_logger);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/* jslint node: true */

var events = require('events'),
    dgram = require('dgram'),
    osc = require('osc-min'),
    cuid = require('cuid'),
    _ = require('lodash'),
    Promise = require('bluebird');

/*
 *
 *  Communicates via OSC with the SuperCollider API quark
 *
 *  The 'API' quark implements a two-way communication protocol.
 *  This nodejs code implements the other end of that communcation.
 *
 *  It connects with an sclang process using UDP OSC
 *  and then sends OSC messages to '/API/call'
 *
 *  Sent messages return a promise,
 *  the responses are received here from sclang
 *  and the promises are resolved
 *  (or rejected if there was an error).
 *
 *  Start SuperCollider
 *  Install the API quark ( > 2.0 )
 *  Activate the OSC responders in supercollider:
 *    API.mountDuplexOSC
 *
 *  See examples/call-api-from-node.js
*/
var SCAPI = function (_events$EventEmitter) {
  _inherits(SCAPI, _events$EventEmitter);

  function SCAPI(schost, scport) {
    _classCallCheck(this, SCAPI);

    var _this = _possibleConstructorReturn(this, (SCAPI.__proto__ || Object.getPrototypeOf(SCAPI)).call(this));

    _this.schost = schost ? schost : 'localhost';
    _this.scport = scport ? scport : 57120;
    _this.requests = {};
    _this.log = new _logger2.default(true, false);
    return _this;
  }

  _createClass(SCAPI, [{
    key: 'connect',
    value: function connect() {
      var self = this;
      this.udp = dgram.createSocket('udp4');

      this.udp.on('message', function (msgbuf) {
        var msg = osc.fromBuffer(msgbuf);
        if (msg.address === '/API/reply') {
          return self.receive('reply', msg);
        }
        return self.receive('scapi_error', msg);
      });

      this.udp.on('error', function (e) {
        self.emit('error', e);
        this.log.err('ERROR:' + e);
      });
    }
  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (this.udp) {
        this.udp.close();
        delete this.udp;
      }
    }
  }, {
    key: 'call',
    value: function call(requestId, oscpath, args, ok, err) {
      var _this2 = this;

      var promise = new Promise(function (resolve, reject) {
        var clientId = 0,
            // no longer needed
        clumps,
            self = _this2;

        requestId = _.isUndefined(requestId) ? cuid() : requestId;
        args = args ? args : [];
        if (!_.isString(oscpath)) {
          self.log.err('Bad oscpath' + oscpath);
          throw 'Bad oscpath' + oscpath;
        }

        function sender(rid, oscArgs) {
          var buf = osc.toBuffer({
            address: '/API/call',
            args: [clientId, rid, oscpath].concat(oscArgs)
          });
          self.udp.send(buf, 0, buf.length, self.scport, self.schost, function (err2) {
            // this will get DNS errors
            // but not packet-too-big errors
            if (err2) {
              self.log.err(err2);
            }
          });
        }

        _this2.requests[requestId] = { resolve: resolve, reject: reject };

        function isNotOsc(a) {
          // if any arg is an object or array
          // or a large string then pass the args as JSON
          // in multiple calls
          return _.isObject(a) || _.isArray(a) || _.isString(a) && a.length > 7168;
        }

        if (_.some(args, isNotOsc)) {
          clumps = JSON.stringify(args).match(/.{1,7168}/g);
          _.each(clumps, function (clump, i) {
            var rid = '' + (i + 1) + ',' + clumps.length + ':' + requestId;
            sender(rid, [clump]);
          });
        } else {
          sender(requestId, args);
        }
      });
      if (ok) {
        return promise.then(ok, err);
      } else {
        return promise;
      }
    }
  }, {
    key: 'receive',
    value: function receive(signal, msg) {
      var // clientId = msg.args[0].value,
      requestId = msg.args[1].value,
          result = msg.args[2].value,
          request = this.requests[requestId];
      if (!request) {
        this.emit('error', 'Unknown request ' + requestId);
        this.log.err('Unknown request ' + requestId);
        return;
      }

      // reply or scapi_error
      if (signal === 'reply') {
        try {
          result = JSON.parse(result);
          result = result.result;
        } catch (e) {
          result = 'MALFORMED JSON RESPONSE:' + result;
          this.log.err(result);
          signal = 'scapi_error';
        }
      }

      var response = {
        signal: signal,
        request_id: requestId,
        result: result
      };

      if (signal === 'reply') {
        request.resolve(response);
      } else {
        request.reject(new _Errors2.default('API Error response', response));
      }
      delete this.requests[requestId];
    }
  }]);

  return SCAPI;
}(events.EventEmitter);

exports.default = SCAPI;
//# sourceMappingURL=scapi.js.map
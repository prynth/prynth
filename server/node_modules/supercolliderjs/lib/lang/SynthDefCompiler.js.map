{"version":3,"sources":["../../src/lang/SynthDefCompiler.js"],"names":["SynthDefCompiler","lang","store","Map","then","Promise","resolve","defs","defsList","toPairs","all","map","defName","spec","_compileOne","defsMap","fromPairs","compiledDefs","result","name","server","compile","commands","sendCommand","callAndResponse","cmd","data","set","get","keys","push","buffer","Buffer","bytes","source","compileSource","path","compilePath","reject","Error","JSON","stringify","sourceCode","pathName","wrappedCode","interpret","undefined","error","annotate","message","sourcePath","readFile","err","fileBuf","toString"],"mappings":"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","file":"SynthDefCompiler.js","sourcesContent":["/**\n * @flow\n */\n\nimport _ from 'lodash';\nimport path from 'path';\nimport fs from 'fs';\nimport { defRecv } from '../server/osc/msg.js';\nimport { boot } from './sclang';\nimport type { SCLangError } from '../Errors';\nimport {\n  SclangResultType,\n  SynthDefResultType,\n  SynthDefResultMapType\n} from '../Types';\nimport type Server from '../server/server';\nimport type SCLang from './sclang';\n\n/**\n * Utility class to compile SynthDefs either from source code or by loading a path.\n *\n * Stores metadata, watches path for changes and can resend on change.\n * Can write compiled synthDefs to .scsyndef\n *\n * @ member of lang\n */\nexport default class SynthDefCompiler {\n  lang: ?SCLang;\n  store: Map<string, SynthDefResultType>;\n\n  constructor(lang: ?SCLang) {\n    this.lang = lang;\n    this.store = new Map();\n  }\n\n  boot() {\n    if (!this.lang) {\n      return boot().then(lang => {\n        this.lang = lang;\n        return this.lang;\n      });\n    }\n    return Promise.resolve(this.lang);\n  }\n\n  /**\n   * Returns an object with each compiled synthdef\n   * as a SynthDefResultType.\n   */\n  compile(defs: Object): Promise<SynthDefResultMapType> {\n    let defsList = _.toPairs(defs);\n    return Promise.all(\n      _.map(defsList, ([defName: string, spec: Object]) =>\n        this._compileOne(defName, spec))\n    ).then(compiledDefs => {\n      let defsMap = _.fromPairs(\n        _.map(compiledDefs, result => [result.name, result])\n      );\n      return defsMap;\n    });\n  }\n\n  /**\n   * Compile SynthDefs and send them to the server.\n   *\n   * @returns a Promise for {defName: SynthDefResult, ...}\n   */\n  compileAndSend(defs: Object, server: Server): Promise<SynthDefResultMapType> {\n    return this.compile(defs).then(compiledDefs => {\n      let commands = _.map(compiledDefs, ({ name }) => this.sendCommand(name));\n      return Promise.all(commands.map(cmd => server.callAndResponse(cmd))).then(\n        () => compiledDefs\n      );\n    });\n  }\n\n  set(defName: string, data: SynthDefResultType) {\n    this.store.set(defName, data);\n    return data;\n  }\n\n  get(defName: string): SynthDefResultType {\n    return this.store.get(defName);\n  }\n\n  allSendCommands() {\n    let commands = [];\n    for (let defName of this.store.keys()) {\n      commands.push(this.sendCommand(defName));\n    }\n    return commands;\n  }\n\n  sendCommand(defName: string) {\n    let data = this.get(defName);\n    let buffer = new Buffer(data.bytes);\n    return defRecv(buffer);\n  }\n\n  // sendAll(server) {\n  //   return Promise.all(\n  //     this.store.keys().map((defName) => this.send(defName, server))\n  //   );\n  // }\n  //\n  // send(defName:string, server:Server) {\n  //   let data = this.get(defName);\n  //   let buffer = new Buffer(data.bytes);\n  //   let promises = [\n  //     context.scserver.callAndResponse(defRecv(buffer))\n  //   ];\n  //\n  // }\n\n  _compileOne(defName: string, spec: Object): Promise<SynthDefResultType> {\n    // path or source\n    if (spec.source) {\n      return this.compileSource(\n        spec.source\n      ).then((result: SclangResultType) => {\n        this.set(defName, result);\n        return result;\n      });\n    }\n\n    // if watch then add a watcher\n\n    if (spec.path) {\n      return this.compilePath(spec.path).then((result: SclangResultType) => {\n        this.set(result.name, result);\n        return result;\n      });\n    }\n\n    return Promise.reject(\n      new Error(\n        `Spec to SynthDefCompiler not recognized ${defName} ${JSON.stringify(spec)}`\n      )\n    );\n  }\n\n  /**\n   * Returns a Promise for a SynthDef result object: name, bytes, synthDesc\n   */\n  compileSource(\n    sourceCode: string,\n    pathName: ?string\n  ): Promise<SynthDefResultType> {\n    const wrappedCode = `{\n      var def = { ${sourceCode} }.value.asSynthDef;\n      (\n        name: def.name,\n        synthDesc: def.asSynthDesc.asJSON(),\n        bytes: def.asBytes()\n      )\n    }.value;`;\n    if (this.lang) {\n      return this.lang\n        .interpret(wrappedCode, undefined, false, false, true)\n        .then(\n          (result: SynthDefResultType) => {\n            return result;\n          },\n          (error: SCLangError) => {\n            error.annotate(\n              `Failed to compile SynthDef  ${error.message} ${pathName || ''}`,\n              {\n                sourceCode\n              }\n            );\n            return Promise.reject(error);\n          }\n        );\n    }\n    return Promise.reject(new Error('SC intpreter is not booted'));\n  }\n\n  /**\n   * Returns a Promise for a SynthDef result object: name, bytes, synthDesc\n   */\n  compilePath(sourcePath: string): Promise<SynthDefResultType> {\n    return new Promise((resolve, reject) => {\n      fs.readFile(path.resolve(sourcePath), (err, fileBuf) => {\n        if (err) {\n          reject(err);\n        } else {\n          // is it really just ascii ?\n          this.compileSource(fileBuf.toString('ascii'), sourcePath).then(\n            resolve,\n            reject\n          );\n        }\n      });\n    });\n  }\n}\n"]}
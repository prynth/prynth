'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SclangIO = exports.STATES = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _Errors = require('../../Errors');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

// Array<string|number>;
// import { SclangResultType } from '../../Types';

var STATES = exports.STATES = {
  NULL: null,
  BOOTING: 'booting',
  COMPILED: 'compiled',
  COMPILING: 'compiling',
  COMPILE_ERROR: 'compileError',
  READY: 'ready'
};

/**
 * This parses the stdout of sclang and detects changes of the
 * interpreter state and converts compilation errors into js objects.
 *
 * Also detects runtime errors and results posted when sc code
 * is evaluated from supercollider.js
 *
 * Convert errors and responses into JavaScript objects
 *
 * Emit events when state changes
 *
 * @private
 */

var SclangIO = exports.SclangIO = function (_EventEmitter) {
  _inherits(SclangIO, _EventEmitter);

  function SclangIO() {
    _classCallCheck(this, SclangIO);

    var _this = _possibleConstructorReturn(this, (SclangIO.__proto__ || Object.getPrototypeOf(SclangIO)).call(this));

    _this.states = _this.makeStates();
    _this.reset();
    return _this;
  }

  _createClass(SclangIO, [{
    key: 'reset',
    value: function reset() {
      this.responseCollectors = {};
      this.capturing = {};
      this.calls = {};
      this.state = null;
      // these are stored on the object
      // and are sent with compile error/success event
      this.output = [];
      this.result = {};
    }

    /**
    * @param {string} input - parse the stdout of supercollider
    */

  }, {
    key: 'parse',
    value: function parse(input) {
      var _this2 = this;

      var echo = true,
          startState = this.state,
          last = 0;
      this.states[this.state].forEach(function (stf) {
        var match;
        if (_this2.state === startState) {
          while ((match = stf.re.exec(input)) !== null) {
            last = match.index + match[0].length;
            // do not post if any handler returns true
            if (stf.fn(match, input) === true) {
              echo = false;
            }

            // break if its not a /g regex with multiple results
            if (!stf.re.global) {
              break;
            }
          }
        }
      });

      if (echo) {
        this.emit('stdout', input);
      }

      // anything left over should be emitted to stdout ?
      // This might result in some content being emitted twice.
      // Currently if there is anything after SUPERCOLLIDERJS.interpret
      // it is emitted.
      // if (last < input.length  && (startState === this.state)) {
      //   console.log('leftovers:', input.substr(last));
      //   // this.parse(input.substr(last));
      // }

      // state has changed and there is still text to parse
      if (last < input.length && startState !== this.state) {
        // parse remainder with new state
        this.parse(input.substr(last));
      }
    }
  }, {
    key: 'setState',
    value: function setState(newState) {
      if (newState !== this.state) {
        this.state = newState;
        this.emit('state', this.state);
      }
    }
  }, {
    key: 'makeStates',
    value: function makeStates() {
      var _this3 = this;

      return {
        booting: [{
          re: /^compiling class library/m,
          fn: function fn(match, text) {
            _this3.reset();
            _this3.setState(STATES.COMPILING);
            _this3.pushOutputText(text);
          }
        }],
        compiling: [{
          re: /^compile done/m,
          fn: function fn() {
            _this3.processOutput();
            _this3.setState(STATES.COMPILED);
          }
        }, {
          re: /^Library has not been compiled successfully/m,
          fn: function fn(match, text) {
            _this3.pushOutputText(text);
            _this3.processOutput();
            _this3.setState(STATES.COMPILE_ERROR);
          }
        }, {
          re: /^ERROR: There is a discrepancy\./m,
          fn: function fn() /*match*/{
            _this3.processOutput();
            _this3.setState(STATES.COMPILE_ERROR);
          }
        }, {
          // it may go directly into initClasses without posting compile done
          re: /Welcome to SuperCollider ([0-9A-Za-z\-\.]+)\. /m,
          fn: function fn(match) {
            _this3.result.version = match[1];
            _this3.processOutput();
            _this3.setState(STATES.READY);
          }
        }, {
          // it sometimes posts this sc3> even when compile failed
          re: /^[\s]*sc3>[\s]*$/m,
          fn: function fn(match, text) {
            _this3.pushOutputText(text);
            _this3.processOutput();
            _this3.setState(STATES.COMPILE_ERROR);
          }
        }, {
          // another case of just trailing off
          re: /^error parsing/m,
          fn: function fn(match, text) {
            _this3.pushOutputText(text);
            _this3.processOutput();
            _this3.setState(STATES.COMPILE_ERROR);
          }
        }, {
          // collect all output
          re: /(.+)/m,
          fn: function fn(match, text) {
            _this3.pushOutputText(text);
          }
        }],
        compileError: [],
        compiled: [{
          re: /Welcome to SuperCollider ([0-9A-Za-z\-\.]+)\. /m,
          fn: function fn(match) {
            _this3.result.version = match[1];
            _this3.setState(STATES.READY);
          }
        }, {
          re: /^[\s]*sc3>[\s]*$/m,
          fn: function fn() /*match:RegExMatchType, text*/{
            _this3.setState(STATES.READY);
          }
        }],
        // REPL is now active
        ready: [{
          // There may be multiple SUPERCOLLIDERJS matches in a block of text.
          // ie. this is a multi-line global regex
          // This fn is called for each of them with a different match each time
          // but the same text body.
          re: /^SUPERCOLLIDERJS\:([0-9A-Za-z\-]+)\:([A-Za-z]+)\:(.*)$/mg,
          fn: function fn(match, text) {
            var guid = match[1],
                type = match[2],
                body = match[3],
                response,
                stdout,
                obj,
                lines,
                started = false,
                stopped = false;

            switch (type) {
              case 'CAPTURE':
                if (body === 'START') {
                  _this3.capturing[guid] = [];
                  lines = [];
                  // yuck
                  _lodash2.default.each(text.split('\n'), function (l) {
                    if (l.match(/SUPERCOLLIDERJS\:([0-9A-Za-z\-]+)\:CAPTURE:START/)) {
                      started = true;
                    } else if (l.match(/SUPERCOLLIDERJS\:([0-9A-Za-z\-]+)\:CAPTURE:END/)) {
                      stopped = true;
                    } else {
                      if (started && !stopped) {
                        lines.push(l);
                      }
                    }
                  });
                  _this3.capturing[guid].push(lines.join('\n'));
                }
                return true;

              case 'START':
                _this3.responseCollectors[guid] = {
                  type: body,
                  chunks: []
                };
                return true;

              case 'CHUNK':
                _this3.responseCollectors[guid].chunks.push(body);
                return true;

              case 'END':
                response = _this3.responseCollectors[guid];
                stdout = response.chunks.join('');
                obj = JSON.parse(stdout);

                if (guid in _this3.calls) {
                  if (response.type === 'Result') {
                    // anything posted during CAPTURE should be forwarded
                    // to stdout
                    stdout = _this3.capturing[guid].join('\n');
                    delete _this3.capturing[guid];
                    if (stdout) {
                      _this3.emit('stdout', stdout);
                    }
                    _this3.calls[guid].resolve(obj);
                  } else {
                    if (response.type === 'SyntaxError') {
                      stdout = _this3.capturing[guid].join('\n');
                      obj = _this3.parseSyntaxErrors(stdout);
                      delete _this3.capturing[guid];
                    }
                    _this3.calls[guid].reject(new _Errors.SCLangError('Interpret error: ' + obj.errorString, response.type, obj));
                  }
                  delete _this3.calls[guid];
                } else {
                  // I hope sc doesn't post multiple streams at the same time
                  if (guid === '0') {
                    // out of band error
                    _this3.emit('error', { type: response.type, error: obj });
                  }
                }
                delete _this3.responseCollectors[guid];
                return true;

              default:
            }
          }
        }, {
          re: /^SUPERCOLLIDERJS.interpreted$/mg,
          fn: function fn(match, text) {
            var rest = text.substr(match.index + 28);
            // remove the prompt ->
            rest = rest.replace(/-> \r?\n?/, '');
            _this3.emit('stdout', rest);
            return true;
          }
        }, {
          // user compiled programmatically eg. with Quarks.gui button
          re: /^compiling class library/m,
          fn: function fn(match, text) {
            _this3.reset();
            _this3.setState(STATES.COMPILING);
            _this3.pushOutputText(text);
          }
        }]
      };
    }

    /**
     * Register a Promise for a block of code that is being sent
     * to sclang to be interpreted.
     *
     * @param {Object} promise - a Promise or an object with reject, resolve
     */

  }, {
    key: 'registerCall',
    value: function registerCall(guid, promise) {
      this.calls[guid] = promise;
    }

    /**
      * Parse syntax error from STDOUT runtime errors.
      */

  }, {
    key: 'parseSyntaxErrors',
    value: function parseSyntaxErrors(text) {
      var msgRe = /^ERROR: syntax error, (.+)$/m,
          msgRe2 = /^ERROR: (.+)$/m,
          fileRe = /in file '(.+)'/m,
          lineRe = /line ([0-9]+) char ([0-9]+):$/m;

      var msg = msgRe.exec(text) || msgRe2.exec(text),
          line = lineRe.exec(text),
          file = fileRe.exec(text),
          code = text.split('\n').slice(4, -3).join('\n').trim();
      return {
        msg: msg && msg[1],
        file: file && file[1],
        line: line && parseInt(line[1], 10),
        charPos: line && parseInt(line[2], 10),
        code: code
      };
    }

    /**
     * Push text posted by sclang during library compilation
     * to the .output stack for later procesing
     */

  }, {
    key: 'pushOutputText',
    value: function pushOutputText(text) {
      this.output.push(text);
    }

    /**
     * Consume the compilation output stack, merging any results
     * into this.result and resetting the stack.
     */

  }, {
    key: 'processOutput',
    value: function processOutput() {
      var _this4 = this;

      var parsed = this.parseCompileOutput((this.output || []).join('\n'));

      // merge with any previously processed
      _lodash2.default.each(parsed, function (value, key) {
        if (_lodash2.default.isArray(value)) {
          _this4.result[key] = (_this4.result[key] || []).concat(value);
        }
        if (_lodash2.default.isString(value)) {
          _this4.result[key] = (_this4.result[key] || '') + value;
        }
      });

      this.output = [];
    }

    /**
      * Parse library compile errors and information
      * collected from sclang STDOUT.
      */

  }, {
    key: 'parseCompileOutput',
    value: function parseCompileOutput(text) {
      var errors = {
        stdout: text,
        errors: [],
        extensionErrors: [],
        duplicateClasses: [],
        dirs: []
      };

      // NumPrimitives = 688
      // multiple:
      // compiling dir: ''
      var dirsRe = /^[\s]+compiling dir\:[\s]+'(.+)'$/mg;
      var match = void 0;
      var end = 0;

      while (match = dirsRe.exec(text)) {
        errors.dirs.push(match[1]);
        end = match.index + match[0].length;
      }

      // the rest are the error blocks
      var rest = text.substr(end),

      // split on ---------------------
      // blocks = rest.split(/^\-+$/m),
      // message
      // in file 'path' line x char y:
      errRe = /([^\n]+)\n\s+in file '([^']+)'\n\s+line ([0-9]+) char ([0-9]+)/mg,
          nonExistentRe = /Class extension for nonexistent class '([A-Za-z0-9\_]+)[\s\S]+In file:'(.+)'/mg,
          duplicateRe = /^ERROR: duplicate Class found: '([A-Za-z0-9\_]+)'\n([^\n]+)\n([^\n]+)\n/mg,
          commonPath = /^\/Common/;

      while (match = errRe.exec(rest)) {
        var file = match[2];
        // errors in Common library are posted as '/Common/...'
        if (commonPath.exec(file)) {
          file = errors.dirs[0] + file;
        }
        errors.errors.push({
          msg: match[1],
          file: file,
          line: parseInt(match[3], 10),
          char: parseInt(match[4], 10)
        });
      }

      while (match = nonExistentRe.exec(text)) {
        errors.extensionErrors.push({
          forClass: match[1],
          file: match[2]
        });
      }

      while ((match = duplicateRe.exec(text)) !== null) {
        errors.duplicateClasses.push({
          forClass: match[1],
          files: [match[2], match[3]]
        });
      }

      return errors;
    }
  }]);

  return SclangIO;
}(_events2.default);
//# sourceMappingURL=sclang-io.js.map
{"version":3,"sources":["../../../src/lang/internals/sclang-io.js"],"names":["STATES","NULL","BOOTING","COMPILED","COMPILING","COMPILE_ERROR","READY","SclangIO","states","makeStates","reset","responseCollectors","capturing","calls","state","output","result","input","echo","startState","last","forEach","match","stf","re","exec","index","length","fn","global","emit","parse","substr","newState","booting","text","setState","pushOutputText","compiling","processOutput","version","compileError","compiled","ready","guid","type","body","response","stdout","obj","lines","started","stopped","each","split","l","push","join","chunks","JSON","resolve","parseSyntaxErrors","reject","errorString","error","rest","replace","promise","msgRe","msgRe2","fileRe","lineRe","msg","line","file","code","slice","trim","parseInt","charPos","parsed","parseCompileOutput","value","key","isArray","concat","isString","errors","extensionErrors","duplicateClasses","dirs","dirsRe","end","errRe","nonExistentRe","duplicateRe","commonPath","char","forClass","files"],"mappings":"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","file":"sclang-io.js","sourcesContent":["/**\n  * @flow\n  */\n\nimport _ from 'lodash';\nimport EventEmitter from 'events';\nimport { SCLangError } from '../../Errors';\n\ntype RegExMatchType = Object; // Array<string|number>;\n// import { SclangResultType } from '../../Types';\n\nexport const STATES = {\n  NULL: null,\n  BOOTING: 'booting',\n  COMPILED: 'compiled',\n  COMPILING: 'compiling',\n  COMPILE_ERROR: 'compileError',\n  READY: 'ready'\n};\n\n/**\n * This parses the stdout of sclang and detects changes of the\n * interpreter state and converts compilation errors into js objects.\n *\n * Also detects runtime errors and results posted when sc code\n * is evaluated from supercollider.js\n *\n * Convert errors and responses into JavaScript objects\n *\n * Emit events when state changes\n *\n * @private\n */\nexport class SclangIO extends EventEmitter {\n  states: Object;\n  responseCollectors: Object;\n  capturing: Object;\n  calls: Object;\n  state: ?string;\n  output: Array<string>;\n  result: Object;\n\n  constructor() {\n    super();\n    this.states = this.makeStates();\n    this.reset();\n  }\n\n  reset() {\n    this.responseCollectors = {};\n    this.capturing = {};\n    this.calls = {};\n    this.state = null;\n    // these are stored on the object\n    // and are sent with compile error/success event\n    this.output = [];\n    this.result = {};\n  }\n\n  /**\n  * @param {string} input - parse the stdout of supercollider\n  */\n  parse(input: string) {\n    var echo = true, startState = this.state, last = 0;\n    this.states[this.state].forEach(stf => {\n      var match;\n      if (this.state === startState) {\n        while ((match = stf.re.exec(input)) !== null) {\n          last = match.index + match[0].length;\n          // do not post if any handler returns true\n          if (stf.fn(match, input) === true) {\n            echo = false;\n          }\n\n          // break if its not a /g regex with multiple results\n          if (!stf.re.global) {\n            break;\n          }\n        }\n      }\n    });\n\n    if (echo) {\n      this.emit('stdout', input);\n    }\n\n    // anything left over should be emitted to stdout ?\n    // This might result in some content being emitted twice.\n    // Currently if there is anything after SUPERCOLLIDERJS.interpret\n    // it is emitted.\n    // if (last < input.length  && (startState === this.state)) {\n    //   console.log('leftovers:', input.substr(last));\n    //   // this.parse(input.substr(last));\n    // }\n\n    // state has changed and there is still text to parse\n    if (last < input.length && startState !== this.state) {\n      // parse remainder with new state\n      this.parse(input.substr(last));\n    }\n  }\n\n  setState(newState: ?string) {\n    if (newState !== this.state) {\n      this.state = newState;\n      this.emit('state', this.state);\n    }\n  }\n\n  makeStates(): Object {\n    return {\n      booting: [\n        {\n          re: /^compiling class library/m,\n          fn: (match: RegExMatchType, text: string) => {\n            this.reset();\n            this.setState(STATES.COMPILING);\n            this.pushOutputText(text);\n          }\n        }\n      ],\n      compiling: [\n        {\n          re: /^compile done/m,\n          fn: () => {\n            this.processOutput();\n            this.setState(STATES.COMPILED);\n          }\n        },\n        {\n          re: /^Library has not been compiled successfully/m,\n          fn: (match: RegExMatchType, text: string) => {\n            this.pushOutputText(text);\n            this.processOutput();\n            this.setState(STATES.COMPILE_ERROR);\n          }\n        },\n        {\n          re: /^ERROR: There is a discrepancy\\./m,\n          fn: (/*match*/) => {\n            this.processOutput();\n            this.setState(STATES.COMPILE_ERROR);\n          }\n        },\n        {\n          // it may go directly into initClasses without posting compile done\n          re: /Welcome to SuperCollider ([0-9A-Za-z\\-\\.]+)\\. /m,\n          fn: (match: RegExMatchType) => {\n            this.result.version = match[1];\n            this.processOutput();\n            this.setState(STATES.READY);\n          }\n        },\n        {\n          // it sometimes posts this sc3> even when compile failed\n          re: /^[\\s]*sc3>[\\s]*$/m,\n          fn: (match: RegExMatchType, text: string) => {\n            this.pushOutputText(text);\n            this.processOutput();\n            this.setState(STATES.COMPILE_ERROR);\n          }\n        },\n        {\n          // another case of just trailing off\n          re: /^error parsing/m,\n          fn: (match: RegExMatchType, text: string) => {\n            this.pushOutputText(text);\n            this.processOutput();\n            this.setState(STATES.COMPILE_ERROR);\n          }\n        },\n        {\n          // collect all output\n          re: /(.+)/m,\n          fn: (match: RegExMatchType, text: string) => {\n            this.pushOutputText(text);\n          }\n        }\n      ],\n      compileError: [],\n      compiled: [\n        {\n          re: /Welcome to SuperCollider ([0-9A-Za-z\\-\\.]+)\\. /m,\n          fn: (match: RegExMatchType) => {\n            this.result.version = match[1];\n            this.setState(STATES.READY);\n          }\n        },\n        {\n          re: /^[\\s]*sc3>[\\s]*$/m,\n          fn: (/*match:RegExMatchType, text*/) => {\n            this.setState(STATES.READY);\n          }\n        }\n      ],\n      // REPL is now active\n      ready: [\n        {\n          // There may be multiple SUPERCOLLIDERJS matches in a block of text.\n          // ie. this is a multi-line global regex\n          // This fn is called for each of them with a different match each time\n          // but the same text body.\n          re: /^SUPERCOLLIDERJS\\:([0-9A-Za-z\\-]+)\\:([A-Za-z]+)\\:(.*)$/mg,\n          fn: (match: RegExMatchType, text: string) => {\n            var guid = match[1],\n              type = match[2],\n              body = match[3],\n              response,\n              stdout,\n              obj,\n              lines,\n              started = false,\n              stopped = false;\n\n            switch (type) {\n              case 'CAPTURE':\n                if (body === 'START') {\n                  this.capturing[guid] = [];\n                  lines = [];\n                  // yuck\n                  _.each(text.split('\\n'), (l: string) => {\n                    if (\n                      l.match(\n                        /SUPERCOLLIDERJS\\:([0-9A-Za-z\\-]+)\\:CAPTURE:START/\n                      )\n                    ) {\n                      started = true;\n                    } else if (\n                      l.match(/SUPERCOLLIDERJS\\:([0-9A-Za-z\\-]+)\\:CAPTURE:END/)\n                    ) {\n                      stopped = true;\n                    } else {\n                      if (started && !stopped) {\n                        lines.push(l);\n                      }\n                    }\n                  });\n                  this.capturing[guid].push(lines.join('\\n'));\n                }\n                return true;\n\n              case 'START':\n                this.responseCollectors[guid] = {\n                  type: body,\n                  chunks: []\n                };\n                return true;\n\n              case 'CHUNK':\n                this.responseCollectors[guid].chunks.push(body);\n                return true;\n\n              case 'END':\n                response = this.responseCollectors[guid];\n                stdout = response.chunks.join('');\n                obj = JSON.parse(stdout);\n\n                if (guid in this.calls) {\n                  if (response.type === 'Result') {\n                    // anything posted during CAPTURE should be forwarded\n                    // to stdout\n                    stdout = this.capturing[guid].join('\\n');\n                    delete this.capturing[guid];\n                    if (stdout) {\n                      this.emit('stdout', stdout);\n                    }\n                    this.calls[guid].resolve(obj);\n                  } else {\n                    if (response.type === 'SyntaxError') {\n                      stdout = this.capturing[guid].join('\\n');\n                      obj = this.parseSyntaxErrors(stdout);\n                      delete this.capturing[guid];\n                    }\n                    this.calls[guid].reject(\n                      new SCLangError(\n                        `Interpret error: ${obj.errorString}`,\n                        response.type,\n                        obj\n                      )\n                    );\n                  }\n                  delete this.calls[guid];\n                } else {\n                  // I hope sc doesn't post multiple streams at the same time\n                  if (guid === '0') {\n                    // out of band error\n                    this.emit('error', { type: response.type, error: obj });\n                  }\n                }\n                delete this.responseCollectors[guid];\n                return true;\n\n              default:\n            }\n          }\n        },\n        {\n          re: /^SUPERCOLLIDERJS.interpreted$/mg,\n          fn: (match: RegExMatchType, text: string) => {\n            let rest = text.substr(match.index + 28);\n            // remove the prompt ->\n            rest = rest.replace(/-> \\r?\\n?/, '');\n            this.emit('stdout', rest);\n            return true;\n          }\n        },\n        {\n          // user compiled programmatically eg. with Quarks.gui button\n          re: /^compiling class library/m,\n          fn: (match: RegExMatchType, text: string) => {\n            this.reset();\n            this.setState(STATES.COMPILING);\n            this.pushOutputText(text);\n          }\n        }\n      ]\n    };\n  }\n\n  /**\n   * Register a Promise for a block of code that is being sent\n   * to sclang to be interpreted.\n   *\n   * @param {Object} promise - a Promise or an object with reject, resolve\n   */\n  registerCall(guid: string, promise: Promise<*> | Object) {\n    this.calls[guid] = promise;\n  }\n\n  /**\n    * Parse syntax error from STDOUT runtime errors.\n    */\n  parseSyntaxErrors(text: string): Object {\n    var msgRe = /^ERROR: syntax error, (.+)$/m,\n      msgRe2 = /^ERROR: (.+)$/m,\n      fileRe = /in file '(.+)'/m,\n      lineRe = /line ([0-9]+) char ([0-9]+):$/m;\n\n    var msg = msgRe.exec(text) || msgRe2.exec(text),\n      line = lineRe.exec(text),\n      file = fileRe.exec(text),\n      code = text.split('\\n').slice(4, -3).join('\\n').trim();\n    return {\n      msg: msg && msg[1],\n      file: file && file[1],\n      line: line && parseInt(line[1], 10),\n      charPos: line && parseInt(line[2], 10),\n      code: code\n    };\n  }\n\n  /**\n   * Push text posted by sclang during library compilation\n   * to the .output stack for later procesing\n   */\n  pushOutputText(text: string) {\n    this.output.push(text);\n  }\n\n  /**\n   * Consume the compilation output stack, merging any results\n   * into this.result and resetting the stack.\n   */\n  processOutput() {\n    let parsed = this.parseCompileOutput((this.output || []).join('\\n'));\n\n    // merge with any previously processed\n    _.each(parsed, (value, key) => {\n      if (_.isArray(value)) {\n        this.result[key] = (this.result[key] || []).concat(value);\n      }\n      if (_.isString(value)) {\n        this.result[key] = (this.result[key] || '') + value;\n      }\n    });\n\n    this.output = [];\n  }\n\n  /**\n    * Parse library compile errors and information\n    * collected from sclang STDOUT.\n    */\n  parseCompileOutput(text: string): Object {\n    let errors = {\n      stdout: text,\n      errors: [],\n      extensionErrors: [],\n      duplicateClasses: [],\n      dirs: []\n    };\n\n    // NumPrimitives = 688\n    // multiple:\n    // compiling dir: ''\n    let dirsRe = /^[\\s]+compiling dir\\:[\\s]+'(.+)'$/mg;\n    let match;\n    let end = 0;\n\n    while ((match = dirsRe.exec(text))) {\n      errors.dirs.push(match[1]);\n      end = match.index + match[0].length;\n    }\n\n    // the rest are the error blocks\n    var rest = text.substr(end),\n      // split on ---------------------\n      // blocks = rest.split(/^\\-+$/m),\n      // message\n      // in file 'path' line x char y:\n      errRe = /([^\\n]+)\\n\\s+in file '([^']+)'\\n\\s+line ([0-9]+) char ([0-9]+)/mg,\n      nonExistentRe = /Class extension for nonexistent class '([A-Za-z0-9\\_]+)[\\s\\S]+In file:'(.+)'/mg,\n      duplicateRe = /^ERROR: duplicate Class found: '([A-Za-z0-9\\_]+)'\\n([^\\n]+)\\n([^\\n]+)\\n/mg,\n      commonPath = /^\\/Common/;\n\n    while ((match = errRe.exec(rest))) {\n      var file = match[2];\n      // errors in Common library are posted as '/Common/...'\n      if (commonPath.exec(file)) {\n        file = errors.dirs[0] + file;\n      }\n      errors.errors.push({\n        msg: match[1],\n        file: file,\n        line: parseInt(match[3], 10),\n        char: parseInt(match[4], 10)\n      });\n    }\n\n    while ((match = nonExistentRe.exec(text))) {\n      errors.extensionErrors.push({\n        forClass: match[1],\n        file: match[2]\n      });\n    }\n\n    while ((match = duplicateRe.exec(text)) !== null) {\n      errors.duplicateClasses.push({\n        forClass: match[1],\n        files: [match[2], match[3]]\n      });\n    }\n\n    return errors;\n  }\n}\n"]}
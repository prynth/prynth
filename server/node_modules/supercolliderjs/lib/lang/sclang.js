'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.boot = boot;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _cuid = require('cuid');

var _cuid2 = _interopRequireDefault(_cuid);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _temp = require('temp');

var _temp2 = _interopRequireDefault(_temp);

var _untildify = require('untildify');

var _untildify2 = _interopRequireDefault(_untildify);

var _jsYaml = require('js-yaml');

var _jsYaml2 = _interopRequireDefault(_jsYaml);

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _events = require('events');

var _child_process = require('child_process');

var _bluebird = require('bluebird');

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _sclangIo = require('./internals/sclang-io');

var _resolveOptions = require('../utils/resolveOptions');

var _resolveOptions2 = _interopRequireDefault(_resolveOptions);

var _Errors = require('../Errors');

var _Types = require('../Types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; } /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                * @ -- flow  -- not quite ready
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                */

// child_process$ChildProcess;

/**
  * This class manages a supercollider language interpreter process
  * and sends messages to and from it using STDIN / STDOUT.
  *
  *  SuperCollider comes with an executable called sclang
  *  which can be communicated with via stdin/stdout
  *  or via OSC.
  *
  *
  * @ member of lang
  * @extends EventEmitter
  */


// This is a private magic built in type.
// It is now undefined, so using any until I track that down.
// 'any' just opts out of type checking
var SCLang = function (_EventEmitter) {
  _inherits(SCLang, _EventEmitter);

  /*
   * @param {object} options - sclang command line options
   */
  function SCLang() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    _classCallCheck(this, SCLang);

    var _this = _possibleConstructorReturn(this, (SCLang.__proto__ || Object.getPrototypeOf(SCLang)).call(this));

    _this.options = options || {};
    _this.process = null;
    _this.log = new _logger2.default(_this.options.debug, _this.options.echo, _this.options.log);
    _this.log.dbug(_this.options);
    _this.stateWatcher = _this.makeStateWatcher();
    return _this;
  }

  /**
   * build args for sclang
   *
   * ```
   *   -d <path>                      Set runtime directory
   *   -D                             Enter daemon mode (no input)
   *   -g <memory-growth>[km]         Set heap growth (default 256k)
   *   -h                             Display this message and exit
   *   -l <path>                      Set library configuration file
   *   -m <memory-space>[km]          Set initial heap size (default 2m)
   *   -r                             Call Main.run on startup
   *   -s                             Call Main.stop on shutdown
   *   -u <network-port-number>       Set UDP listening port (default 57120)
   *   -i <ide-name>                  Specify IDE name (for enabling IDE-specific class code, default "none")
   *   -a                             Standalone mode
   * ```
   */


  _createClass(SCLang, [{
    key: 'args',
    value: function args(options) {
      var o = [];
      o.push('-i', 'supercolliderjs');
      if (options.executeFile) {
        o.push(options.executeFile);
      }
      o.push('-u', options.langPort);
      if (options.config) {
        o.push('-l', options.config);
      }
      return o;
    }

    /**
     * makeSclangConfig
     *
     * make sclang_config.yaml as a temporary file
     * with the supplied values
     *
     * This is the config file that sclang reads, specifying
     * includePaths and excludePaths
     *
     */

  }, {
    key: 'makeSclangConfig',
    value: function makeSclangConfig(config) {
      /**
        write options as yaml to a temp file
        and return the path
      **/
      var str = _jsYaml2.default.safeDump(config, { indent: 4 });
      return new _bluebird.Promise(function (resolve, reject) {
        _temp2.default.open('sclang-config', function (err, info) {
          if (err) {
            return reject(err);
          }

          _fs2.default.write(info.fd, str, function (err2) {
            if (err2) {
              reject(err2);
            } else {
              _fs2.default.close(info.fd, function (err3) {
                if (err3) {
                  reject(err3);
                } else {
                  resolve(info.path);
                }
              });
            }
          });
        });
      });
    }
  }, {
    key: 'isReady',
    value: function isReady() {
      return this.stateWatcher.state === 'ready';
    }

    /**
     * Start sclang executable as a subprocess.
     *
     * sclang will compile it's class library, and this may result in syntax
     * or compile errors. These errors are parsed and returned in a structured format.
     *
     * Resolves with:
     *
     * ```js
     * {dirs: [compiled directories]}
     * ```
     *
     * or rejects with:
     *
     * ```js
     * {
     *   dirs: [],
     *   compileErrors: [],
     *   parseErrors: [],
     *   duplicateClasses: [],
     *   errors[],
     *   extensionErrors: [],
     *   stdout: 'compiling class library...etc.'
     * }
     * ```
     *
     * @returns {Promise}
     */

  }, {
    key: 'boot',
    value: function boot() {
      var _this2 = this;

      this.setState(_sclangIo.STATES.BOOTING);

      // merge supercollider.js options with any sclang_conf
      var config = void 0;
      try {
        config = this.sclangConfigOptions(this.options);
      } catch (e) {
        return _bluebird.Promise.reject(e);
      }

      return this.makeSclangConfig(config).then(function (configPath) {
        return _this2.spawnProcess(_this2.options.sclang, _lodash2.default.extend({}, _this2.options, { config: configPath }));
      });
    }

    /**
     * spawnProcess - starts the sclang executable
     *
     * sets this.process
     * adds state listeners
     *
     * @param {string} execPath - path to sclang
     * @param {object} commandLineOptions - options for the command line
     *                filtered with this.args so it will only include values
     *                that sclang uses.
     * @returns {Promise}
     *     resolves null on successful boot and compile
     *     rejects on failure to boot or failure to compile the class library
     */

  }, {
    key: 'spawnProcess',
    value: function spawnProcess(execPath, commandLineOptions) {
      var _this3 = this;

      return new _bluebird.Promise(function (resolve, reject) {
        var done = false;

        _this3.process = _this3._spawnProcess(execPath, _this3.args(commandLineOptions));
        if (!(_this3.process && _this3.process.pid)) {
          reject(new Error('Failed to spawn process: ' + execPath));
          return;
        }

        var bootListener = function bootListener(state) {
          if (state === _sclangIo.STATES.READY) {
            done = true;
            _this3.removeListener('state', bootListener);
            resolve(_this3.stateWatcher.result);
          } else if (state === _sclangIo.STATES.COMPILE_ERROR) {
            done = true;
            reject(new _Errors.SCError('CompileError', _this3.stateWatcher.result));
            _this3.removeListener('state', bootListener);
            // probably should remove all listeners
          }
        };

        // temporary listener until booted ready or compileError
        // that removes itself
        _this3.addListener('state', bootListener);

        setTimeout(function () {
          if (!done) {
            _this3.log.err('Timeout waiting for sclang to boot');
            // force it to finalize
            _this3.stateWatcher.processOutput();
            // bootListener above will reject the promise
            _this3.stateWatcher.setState(_sclangIo.STATES.COMPILE_ERROR);
            _this3.removeListener('state', bootListener);
          }
        }, 10000);

        // long term listeners
        if (_this3.process) {
          _this3.installListeners(_this3.process, Boolean(_this3.options.stdin));
        }
      });
    }
  }, {
    key: '_spawnProcess',
    value: function _spawnProcess(execPath, commandLineOptions) {
      return (0, _child_process.spawn)(execPath, commandLineOptions, {
        cwd: _path2.default.dirname(execPath)
      });
    }

    /**
     * sclangConfigOptions
     *
     * Builds the options that will be written to the config file that is read by sclang
     * If supercolliderjs-conf specifies a sclang_conf path
     * then this is read and any includePaths and excludePaths are merged
     *
     * throws error if config cannot be read
     *
     * @param {object} options - supercolliderJs options
     * @returns {object} - sclang_config variables
     */

  }, {
    key: 'sclangConfigOptions',
    value: function sclangConfigOptions() {
      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

      var runtimeIncludePaths = [_path2.default.resolve(__dirname, '../../lib/supercollider-js')];
      var defaultConf = {
        postInlineWarnings: false,
        includePaths: [],
        excludePaths: []
      };
      var sclang_conf = defaultConf;

      if (options.sclang_conf) {
        try {
          sclang_conf = _jsYaml2.default.safeLoad(_fs2.default.readFileSync((0, _untildify2.default)(options.sclang_conf), 'utf8'));
        } catch (e) {
          // By default allow a missing sclang_conf file
          // so that the language can create it on demand if you use Quarks or LanguageConfig.
          if (!options.failIfSclangConfIsMissing) {
            // Was the sclang_conf just in the defaults or was it explicitly set ?
            this.log.dbug(e);
            sclang_conf = defaultConf;
          } else {
            throw new Error('Cannot open or read specified sclang_conf ' + options.sclang_conf);
          }
        }
      }

      return {
        includePaths: _lodash2.default.union(sclang_conf.includePaths, options.includePaths, runtimeIncludePaths),
        excludePaths: _lodash2.default.union(sclang_conf.excludePaths, options.excludePaths),
        postInlineWarning: _lodash2.default.isUndefined(options.postInlineWarnings) ? Boolean(sclang_conf.postInlineWarnings) : Boolean(options.postInlineWarnings)
      };
    }
  }, {
    key: 'makeStateWatcher',
    value: function makeStateWatcher() {
      var _this4 = this;

      var stateWatcher = new _sclangIo.SclangIO(this);
      var _arr = ['interpreterLoaded', 'error', 'stdout', 'state'];

      var _loop = function _loop() {
        var name = _arr[_i];
        stateWatcher.on(name, function () {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          _this4.emit.apply(_this4, [name].concat(args));
        });
      };

      for (var _i = 0; _i < _arr.length; _i++) {
        _loop();
      }
      return stateWatcher;
    }

    /**
      * listen to events from process and pipe stdio to the stateWatcher
      */

  }, {
    key: 'installListeners',
    value: function installListeners(subprocess) {
      var _this5 = this;

      var listenToStdin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      if (listenToStdin) {
        // stdin of the global top level nodejs process
        process.stdin.setEncoding('utf8');
        process.stdin.on('data', function (chunk) {
          if (chunk) {
            _this5.write(chunk, null, true);
          }
        });
      }
      subprocess.stdout.on('data', function (data) {
        var ds = String(data);
        _this5.log.dbug(ds);
        _this5.stateWatcher.parse(ds);
      });
      subprocess.stderr.on('data', function (data) {
        var error = String(data);
        _this5.log.stderr(error);
        _this5.emit('stderr', error);
      });
      subprocess.on('error', function (err) {
        _this5.log.err('ERROR:' + err, 'error');
        _this5.emit('stderr', err);
      });
      subprocess.on('close', function (code, signal) {
        _this5.log.dbug('close ' + code + signal);
        _this5.emit('exit', code);
        _this5.setState(null);
      });
      subprocess.on('exit', function (code, signal) {
        _this5.log.dbug('exit ' + code + signal);
        _this5.emit('exit', code);
        _this5.setState(null);
      });
      subprocess.on('disconnect', function () {
        _this5.log.dbug('disconnect');
        _this5.emit('exit');
        _this5.setState(null);
      });
    }

    /**
     * write
     *
     * Send a raw string to sclang to be interpreted
     * callback is called after write is complete.
     */

  }, {
    key: 'write',
    value: function write(chunk, callback, noEcho) {
      if (!noEcho) {
        this.log.stdin(chunk);
      }
      this.log.dbug(chunk);
      this.process.stdin.write(chunk, 'UTF-8');
      // Send the escape character which is interpreted by sclang as:
      // "evaluate the currently accumulated command line as SC code"
      this.process.stdin.write('\x0c', null, callback);
    }

    /**
      * storeSclangConf
      *
      * Store the original configuration path
      * so that it can be accessed by the modified Quarks methods
      * to store into the correct conf file.
      */

  }, {
    key: 'storeSclangConf',
    value: function storeSclangConf() {
      var _this6 = this;

      if (this.options.sclang_conf) {
        var configPath = _path2.default.resolve((0, _untildify2.default)(this.options.sclang_conf));
        var setConfigPath = 'SuperColliderJS.sclangConf = "' + configPath + '";\n\n';
        return this.interpret(setConfigPath, null, true, true, true).then(function () {
          return _this6;
        });
      } else {
        return _bluebird.Promise.resolve(this);
      }
    }

    /**
     * Interprets code in sclang and returns a Promise.
     *
     * @param {String} code
     *        source code to evaluate
     * @param {String} nowExecutingPath
              set thisProcess.nowExecutingPath
     *        for use in a REPL to evaluate text in a file
     *        and let sclang know what file it is executing.
     * @param {Boolean} asString
     *        return result .asString for post window
     *        otherwise returns result as a JSON object
     * @param {Boolean} postErrors
     *        call error.reportError on any errors
     *        which posts call stack, receiver, args, etc
     * @param {Boolean} getBacktrace
     *        return full backtrace
     * @returns {Promise} results - which resolves with result as JSON or rejects with SCLangError.
     */

  }, {
    key: 'interpret',
    value: function interpret(code, nowExecutingPath, asString, postErrors, getBacktrace) {
      var _this7 = this;

      return new _bluebird.Promise(function (resolve, reject) {
        var escaped = code.replace(/[\n\r]/g, '__NL__').replace(/\\/g, '__SLASH__').replace(/\"/g, '\\"');
        var guid = (0, _cuid2.default)();

        var args = ['"' + guid + '"', '"' + escaped + '"', nowExecutingPath ? '"' + nowExecutingPath + '"' : 'nil', asString ? 'true' : 'false', postErrors ? 'true' : 'false', getBacktrace ? 'true' : 'false'].join(',');

        _this7.stateWatcher.registerCall(guid, { resolve: resolve, reject: reject });
        _this7.write('SuperColliderJS.interpret(' + args + ');', null, true);
      });
    }

    /**
     * executeFile
     */

  }, {
    key: 'executeFile',
    value: function executeFile(filename) {
      var _this8 = this;

      return new _bluebird.Promise(function (resolve, reject) {
        var guid = (0, _cuid2.default)();
        _this8.stateWatcher.registerCall(guid, { resolve: resolve, reject: reject });
        _this8.write('SuperColliderJS.executeFile("' + guid + '", "' + filename + '")', null, true);
      });
    }

    /**
     * @private
     */

  }, {
    key: 'setState',
    value: function setState(state) {
      this.stateWatcher.setState(state);
    }
  }, {
    key: 'compilePaths',
    value: function compilePaths() {
      return this.stateWatcher.result.dirs;
    }
  }, {
    key: 'quit',
    value: function quit() {
      var _this9 = this;

      return new _bluebird.Promise(function (resolve) {
        var cleanup = function cleanup() {
          _this9.process = null;
          _this9.setState(null);
          resolve(_this9);
        };
        if (_this9.process) {
          _this9.process.once('exit', cleanup);
          // request a polite shutdown
          _this9.process.kill('SIGINT');
          setTimeout(function () {
            // 3.6.6 doesn't fully respond to SIGINT
            // but SIGTERM causes it to crash
            if (_this9.process) {
              _this9.process.kill('SIGTERM');
              cleanup();
            }
          }, 250);
        } else {
          cleanup();
        }
      });
    }
  }]);

  return SCLang;
}(_events.EventEmitter);

/**
  * Boots an sclang interpreter, resolving options and connecting.
  *
  * @memberof lang
  *
  * @param {Object} commandLineOptions - A dict of options to be merged into the loaded config. Command line options to be supplied to sclang --sclang=/some/path/to/sclang
  * commandLineOptions.config - Explicit path to a yaml config file
  * If undefined then it will look for config files in:
  *    - .supercollider.yaml
  *    - ~/.supercollider.yaml
  */


exports.default = SCLang;
function boot() {
  var commandLineOptions = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  return (0, _resolveOptions2.default)(commandLineOptions.config, commandLineOptions).then(function (opts) {
    var sclang = new SCLang(opts);
    return sclang.boot().then(function () {
      return sclang.storeSclangConf().then(function () {
        return sclang;
      });
    });
  });
}

// deprec. will be removed in 1.0
SCLang.boot = boot;
//# sourceMappingURL=sclang.js.map
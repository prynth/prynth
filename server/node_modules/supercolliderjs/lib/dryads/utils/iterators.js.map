{"version":3,"sources":["../../../src/dryads/utils/iterators.js"],"names":["sortEvents","clipTime","eventListIterator","loopedEventListIterator","events","sort","a","b","time","start","end","filter","e","sorted","length","now","memo","event","i","delta","loopTime","iteration","Math","floor","timeBase","assign","max","lastEventTime"],"mappings":";;;;;QAOgBA,U,GAAAA,U;QAIAC,Q,GAAAA,Q;QAiBAC,iB,GAAAA,iB;QAkDAC,uB,GAAAA,uB;;AAzEhB;;;;;;AAEO,SAASH,UAAT,CAAoBI,MAApB,EAA2C;AAChD,SAAOA,OAAOC,IAAP,CAAY,UAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUD,EAAEE,IAAF,GAASD,EAAEC,IAArB;AAAA,GAAZ,CAAP;AACD,C,CATD;;;;;AAWO,SAASP,QAAT,CAAkBG,MAAlB,EAAyCK,KAAzC,EAAwDC,GAAxD,EAAqE;AAC1E,SAAON,OAAOO,MAAP,CAAc;AAAA,WAAKC,EAAEJ,IAAF,IAAUC,KAAV,IAAmBG,EAAEJ,IAAF,IAAUE,GAAlC;AAAA,GAAd,CAAP;AACD;;AAED;;;;;;;;;;;;;AAaO,SAASR,iBAAT,CAA2BE,MAA3B,EAA4D;AACjE,MAAMS,SAASb,WAAWI,MAAX,CAAf;AACA,MAAMU,SAASD,OAAOC,MAAtB;;AAEA,SAAO,UAACC,GAAD,EAAcC,IAAd,EAAyC;AAC9C,QAAIF,WAAW,CAAf,EAAkB;AAChB;AACD;;AAED,QAAIE,IAAJ,EAAU;AACR;AACA,UAAIC,QAAQJ,OAAOG,KAAKE,CAAZ,CAAZ;AACA,UAAID,KAAJ,EAAW;AACT,eAAO;AACLA,sBADK;AAELD,gBAAM,EAAEE,GAAGF,KAAKE,CAAL,GAAS,CAAd;AAFD,SAAP;AAID;AACF,KATD,MASO;AACL;AACA,WAAK,IAAIA,IAAI,CAAb,EAAgBA,IAAIJ,MAApB,EAA4BI,KAAK,CAAjC,EAAoC;AAClC,YAAID,SAAQJ,OAAOK,CAAP,CAAZ;AACA,YAAIC,QAAQF,OAAMT,IAAN,GAAaO,GAAzB;AACA,YAAII,SAAS,CAAb,EAAgB;AACd,iBAAO;AACLF,yBADK;AAELD,kBAAM,EAAEE,GAAGA,IAAI,CAAT;AAFD,WAAP;AAID;AACF;AACF;AACF,GA3BD;AA4BD;;AAED;;;;;;;;;;;;;;;;AAgBO,SAASf,uBAAT,CACLC,MADK,EAELgB,QAFK,EAGK;AACV,MAAMP,SAASZ,SAASD,WAAWI,MAAX,CAAT,EAA6B,CAA7B,EAAgCgB,QAAhC,CAAf;AACA,MAAMN,SAASD,OAAOC,MAAtB;;AAEA,SAAO,UAACC,GAAD,EAAcC,IAAd,EAAyC;AAC9C,QAAIF,WAAW,CAAf,EAAkB;AAChB;AACD;;AAED,QAAIE,IAAJ,EAAU;AACR,UAAIC,QAAQJ,OAAOG,KAAKE,CAAL,GAASJ,MAAhB,CAAZ;AACA,UAAIO,YAAYC,KAAKC,KAAL,CAAWP,KAAKE,CAAL,GAASJ,MAApB,CAAhB;AACA,UAAIU,WAAWH,YAAYD,QAA3B;;AAEA,UAAIH,KAAJ,EAAW;AACT;AACA;AACA;;AAEA,eAAO;AACLA,iBAAO,iBAAEQ,MAAF,CAAS,EAAT,EAAaR,KAAb,EAAoB,EAAET,MAAMgB,WAAWP,MAAMT,IAAzB,EAApB,CADF;AAELQ,gBAAM,EAAEE,GAAGF,KAAKE,CAAL,GAAS,CAAd;AAFD,SAAP;AAID;AACF,KAfD,MAeO;AACL;AACA,UAAIG,aAAYC,KAAKI,GAAL,CAASJ,KAAKC,KAAL,CAAWR,MAAMK,QAAjB,CAAT,EAAqC,CAArC,CAAhB;;AAEA,UAAII,YAAWH,aAAYD,QAA3B;AACA,UAAIO,gBAAgBd,OAAOC,SAAS,CAAhB,EAAmBN,IAAvC;AACA,UAAIO,MAAMS,YAAWG,aAAjB,IAAkCZ,MAAMS,YAAWJ,QAAvD,EAAiE;AAC/D;AACA;AACAI,oBAAWA,YAAWJ,QAAtB;AACD;;AAED,WAAK,IAAIF,IAAI,CAAb,EAAgBA,IAAIJ,MAApB,EAA4BI,KAAK,CAAjC,EAAoC;AAClC,YAAID,UAAQJ,OAAOK,CAAP,CAAZ;AACA,YAAIV,OAAOgB,YAAWP,QAAMT,IAA5B;AACA,YAAIW,QAAQX,OAAOO,GAAnB;;AAEA,YAAII,SAAS,CAAb,EAAgB;AACd,iBAAO;AACLF,mBAAO,iBAAEQ,MAAF,CAAS,EAAT,EAAaR,OAAb,EAAoB,EAAET,UAAF,EAApB,CADF;AAELQ,kBAAM,EAAEE,GAAGG,aAAYP,MAAZ,GAAqBI,CAArB,GAAyB,CAA9B;AAFD,WAAP;AAID;AACF;AACF;AACF,GA7CD;AA8CD","file":"iterators.js","sourcesContent":["/**\n * @flow\n * @module iterators\n * @ temp off - memberof dryads\n */\nimport _ from 'lodash';\n\nexport function sortEvents(events: Array<Object>) {\n  return events.sort((a, b) => a.time - b.time);\n}\n\nexport function clipTime(events: Array<Object>, start: number, end: number) {\n  return events.filter(e => e.time >= start && e.time <= end);\n}\n\n/**\n * eventListIterator - Creates a function for use in a getNextEvent iterator that returns events sequentially\n *\n * @param  {Array} events Events are objects with .time attribute.\n * @return {Function}      arguments:\n *                          {number} now - in seconds,\n *                          {Object} memo - used internally\n *                          If memo is not supplied then it will search for the next event\n *                          greater than or equal to 'now'\n *                          and if memo IS supplied then it iterates over the sorted event list.\n *                         returns {Object} event - Which has .event (the original event) and .memo which is\n *                              used by OSCSched the next time this function is called.\n */\nexport function eventListIterator(events: Array<Object>): Function {\n  const sorted = sortEvents(events);\n  const length = sorted.length;\n\n  return (now: number, memo: ?Object): ?Object => {\n    if (length === 0) {\n      return;\n    }\n\n    if (memo) {\n      // memo, get next event\n      let event = sorted[memo.i];\n      if (event) {\n        return {\n          event,\n          memo: { i: memo.i + 1 }\n        };\n      }\n    } else {\n      // search for first positive delta\n      for (let i = 0; i < length; i += 1) {\n        let event = sorted[i];\n        let delta = event.time - now;\n        if (delta >= 0) {\n          return {\n            event,\n            memo: { i: i + 1 }\n          };\n        }\n      }\n    }\n  };\n}\n\n/**\n * loopedEventListIterator - Creates a function for use in a getNextEvent iterator that loops over an event list\n *\n * @param  {Array} events   Events are objects with .time attribute.\n * @param  {number} loopTime The iterator will loop from 0 .. loopTime. Events past the loop are ignored (never played).\n * @return {Function}      arguments:\n *\n *   {number} now - in seconds,\n *   {Object} memo - used internally\n *   If memo is not supplied then it will search for the next event\n *   greater than or equal to 'now'\n *   and if memo *is* supplied then it iterates over the sorted event list.\n *\n *   returns {Object} item - Which has .event (the original event) and .memo which is\n *                              used by OSCSched the next time this function is called.\n */\nexport function loopedEventListIterator(\n  events: Array<Object>,\n  loopTime: number\n): Function {\n  const sorted = clipTime(sortEvents(events), 0, loopTime);\n  const length = sorted.length;\n\n  return (now: number, memo: ?Object): ?Object => {\n    if (length === 0) {\n      return;\n    }\n\n    if (memo) {\n      let event = sorted[memo.i % length];\n      let iteration = Math.floor(memo.i / length);\n      let timeBase = iteration * loopTime;\n\n      if (event) {\n        // if (now > timeBase + event.time) {\n        //   throw new Error('loopedEventListIterator and event is in the past');\n        // }\n\n        return {\n          event: _.assign({}, event, { time: timeBase + event.time }),\n          memo: { i: memo.i + 1 }\n        };\n      }\n    } else {\n      // search for first positive delta\n      let iteration = Math.max(Math.floor(now / loopTime), 0);\n\n      let timeBase = iteration * loopTime;\n      let lastEventTime = sorted[length - 1].time;\n      if (now > timeBase + lastEventTime && now < timeBase + loopTime) {\n        // play position is between lastEvent and loopTime\n        // so start search in next loop, not at start of current one\n        timeBase = timeBase + loopTime;\n      }\n\n      for (let i = 0; i < length; i += 1) {\n        let event = sorted[i];\n        let time = timeBase + event.time;\n        let delta = time - now;\n\n        if (delta >= 0) {\n          return {\n            event: _.assign({}, event, { time }),\n            memo: { i: iteration * length + i + 1 }\n          };\n        }\n      }\n    }\n  };\n}\n"]}
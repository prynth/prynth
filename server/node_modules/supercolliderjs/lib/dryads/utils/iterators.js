'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.sortEvents = sortEvents;
exports.clipTime = clipTime;
exports.eventListIterator = eventListIterator;
exports.loopedEventListIterator = loopedEventListIterator;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function sortEvents(events) {
  return events.sort(function (a, b) {
    return a.time - b.time;
  });
} /**
   * 
   * @module iterators
   * @ temp off - memberof dryads
   */
function clipTime(events, start, end) {
  return events.filter(function (e) {
    return e.time >= start && e.time <= end;
  });
}

/**
 * eventListIterator - Creates a function for use in a getNextEvent iterator that returns events sequentially
 *
 * @param  {Array} events Events are objects with .time attribute.
 * @return {Function}      arguments:
 *                          {number} now - in seconds,
 *                          {Object} memo - used internally
 *                          If memo is not supplied then it will search for the next event
 *                          greater than or equal to 'now'
 *                          and if memo IS supplied then it iterates over the sorted event list.
 *                         returns {Object} event - Which has .event (the original event) and .memo which is
 *                              used by OSCSched the next time this function is called.
 */
function eventListIterator(events) {
  var sorted = sortEvents(events);
  var length = sorted.length;

  return function (now, memo) {
    if (length === 0) {
      return;
    }

    if (memo) {
      // memo, get next event
      var event = sorted[memo.i];
      if (event) {
        return {
          event: event,
          memo: { i: memo.i + 1 }
        };
      }
    } else {
      // search for first positive delta
      for (var i = 0; i < length; i += 1) {
        var _event = sorted[i];
        var delta = _event.time - now;
        if (delta >= 0) {
          return {
            event: _event,
            memo: { i: i + 1 }
          };
        }
      }
    }
  };
}

/**
 * loopedEventListIterator - Creates a function for use in a getNextEvent iterator that loops over an event list
 *
 * @param  {Array} events   Events are objects with .time attribute.
 * @param  {number} loopTime The iterator will loop from 0 .. loopTime. Events past the loop are ignored (never played).
 * @return {Function}      arguments:
 *
 *   {number} now - in seconds,
 *   {Object} memo - used internally
 *   If memo is not supplied then it will search for the next event
 *   greater than or equal to 'now'
 *   and if memo *is* supplied then it iterates over the sorted event list.
 *
 *   returns {Object} item - Which has .event (the original event) and .memo which is
 *                              used by OSCSched the next time this function is called.
 */
function loopedEventListIterator(events, loopTime) {
  var sorted = clipTime(sortEvents(events), 0, loopTime);
  var length = sorted.length;

  return function (now, memo) {
    if (length === 0) {
      return;
    }

    if (memo) {
      var event = sorted[memo.i % length];
      var iteration = Math.floor(memo.i / length);
      var timeBase = iteration * loopTime;

      if (event) {
        // if (now > timeBase + event.time) {
        //   throw new Error('loopedEventListIterator and event is in the past');
        // }

        return {
          event: _lodash2.default.assign({}, event, { time: timeBase + event.time }),
          memo: { i: memo.i + 1 }
        };
      }
    } else {
      // search for first positive delta
      var _iteration = Math.max(Math.floor(now / loopTime), 0);

      var _timeBase = _iteration * loopTime;
      var lastEventTime = sorted[length - 1].time;
      if (now > _timeBase + lastEventTime && now < _timeBase + loopTime) {
        // play position is between lastEvent and loopTime
        // so start search in next loop, not at start of current one
        _timeBase = _timeBase + loopTime;
      }

      for (var i = 0; i < length; i += 1) {
        var _event2 = sorted[i];
        var time = _timeBase + _event2.time;
        var delta = time - now;

        if (delta >= 0) {
          return {
            event: _lodash2.default.assign({}, _event2, { time: time }),
            memo: { i: _iteration * length + i + 1 }
          };
        }
      }
    }
  };
}
//# sourceMappingURL=iterators.js.map
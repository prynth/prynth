{"version":3,"sources":["../../src/dryads/Group.js"],"names":["Group","callOrder","updateContext","context","nodeID","scserver","state","nextNodeID","group","parentGroup","msg","TAIL","run","id"],"mappings":";;;;;;;;AACA;;AACA;;AACA;;;;;;;;AAEA;;;;IAIqBA,K;;;;;;;;;;;;AACnB;;;;oCAIwB;AACtB,aAAO,UAAP;AACD;;;oCAEuB;AACtB,aAAO;AACLC,mBAAW,oBADN;AAELC,uBAAe,uBAACC,OAAD,CAAS,gBAAT,EAA8B;AAC3C,cAAMC,SAASD,QAAQE,QAAR,CAAiBC,KAAjB,CAAuBC,UAAvB,EAAf;AACA,iBAAO;AACLH,0BADK;AAEL;AACA;AACA;AACA;AACA;AACAI,mBAAOJ,MAPF;AAQL;AACAK,yBAAaN,QAAQK,KAAR,IAAiB;AATzB,WAAP;AAWD;AAfI,OAAP;AAiBD;;;0BAEa;AACZ,aAAO;AACLH,kBAAU;AACRK,eAAK,aAACP,OAAD;AAAA,mBACH,mBAASA,QAAQC,MAAjB,EAAyB,gBAAWO,IAApC,EAA0CR,QAAQM,WAAlD,CADG;AAAA;AADG,SADL;AAKLG,aAAK,aAACT,OAAD;AAAA,iBACH,6BAAWA,QAAQE,QAAnB,EAA6BF,QAAQU,EAArC,EAAyCV,QAAQC,MAAjD,CADG;AAAA;AALA,OAAP;AAQD;;;6BAEgB;AACf,aAAO;AACLC,kBAAU;AACR;AACA;AACA;AACA;AACAK,eAAK,aAACP,OAAD;AAAA,mBAAqB,mBAASA,QAAQC,MAAjB,CAArB;AAAA;AALG,SADL;AAQLQ,aAAK,aAACT,OAAD;AAAA,iBACH,8BAAYA,QAAQE,QAApB,EAA8BF,QAAQU,EAAtC,EAA0CV,QAAQC,MAAlD,CADG;AAAA;AARA,OAAP;AAWD;;;;;;kBApDkBJ,K","file":"Group.js","sourcesContent":["/* @flow */\nimport { Dryad } from 'dryadic';\nimport { nodeFree, groupNew, AddActions } from '../server/osc/msg.js';\nimport { whenNodeGo, whenNodeEnd } from '../server/node-watcher';\n\n/**\n * Creates a group on the server; sets .group in context for its children,\n * so any Synths or Groups will be spawned inside this group.\n */\nexport default class Group extends Dryad {\n  /**\n   * If there is no SCServer in the parent context,\n   * then this will wrap itself in an SCServer\n   */\n  requireParent(): string {\n    return 'SCServer';\n  }\n\n  prepareForAdd(): Object {\n    return {\n      callOrder: 'SELF_THEN_CHILDREN',\n      updateContext: (context /*, properties*/) => {\n        const nodeID = context.scserver.state.nextNodeID();\n        return {\n          nodeID,\n          // TODO: but this overwrites my own group !\n          // what if parent is a group ?\n          // I need to create this group within that group\n          // This should just be childContext,\n          // but that is only called when creating the tree.\n          group: nodeID,\n          // for now, save it to parentGroup\n          parentGroup: context.group || 0\n        };\n      }\n    };\n  }\n\n  add(): Object {\n    return {\n      scserver: {\n        msg: (context: Object) =>\n          groupNew(context.nodeID, AddActions.TAIL, context.parentGroup)\n      },\n      run: (context: Object) =>\n        whenNodeGo(context.scserver, context.id, context.nodeID)\n    };\n  }\n\n  remove(): Object {\n    return {\n      scserver: {\n        // children do not have to free their nodes\n        // as they get freed by freeing this parent\n        // so remove for children needs to communicate that somehow\n        // but buffers and busses do need to free\n        msg: (context: Object) => nodeFree(context.nodeID)\n      },\n      run: (context: Object) =>\n        whenNodeEnd(context.scserver, context.id, context.nodeID)\n    };\n  }\n}\n"]}
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dryadic = require('dryadic');

var _msg = require('../server/osc/msg.js');

var _path = require('path');

var _path2 = _interopRequireDefault(_path);

var _fs = require('fs');

var _fs2 = _interopRequireDefault(_fs);

var _Types = require('../Types');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
/* eslint no-console: 0 */


var StateKeys = {
  SYNTH_DEFS: 'SYNTH_DEFS'
};

/**
 * Compile a SynthDef from sclang source code
 * or load a precompiled .scsyndef
 *
 * If compilation is required then it will insert SCLang as a parent if necessary.
 *
 * properties:
 *  - source      - sclang source code to compile
 *  - compileFrom - path of .scd file to compile
 *  - watch  (Boolean)     - watch compileFrom file and recompile on changes
 *  - saveToDir   - path to save compiled .scsyndef to after compiling
 *  - loadFrom    - path of previously compiled .scsyndef file to load to server
 *               This can be used to load SynthDefs without needing sclang running at all.
 *
 * `synthDef` is set in the context for children Dryads to access.
 * It is an object:
 * - .name
 * - .bytes
 * - .synthDesc object with descriptive meta data
 *
 * Note that the synthDefName is not known until after the source code is compiled.
 *
 */

var SCSynthDef = function (_Dryad) {
  _inherits(SCSynthDef, _Dryad);

  function SCSynthDef() {
    _classCallCheck(this, SCSynthDef);

    return _possibleConstructorReturn(this, (SCSynthDef.__proto__ || Object.getPrototypeOf(SCSynthDef)).apply(this, arguments));
  }

  _createClass(SCSynthDef, [{
    key: 'requireParent',

    /**
     * If there is no SCLang in the parent context,
     * then this will wrap itself in an SCLang (language interpreter).
     */
    value: function requireParent() {
      if (this.properties.source || this.properties.compileFrom) {
        return 'SCLang';
      }
    }
  }, {
    key: 'prepareForAdd',
    value: function prepareForAdd() {
      var _this2 = this;

      // search context for a SynthDefCompiler, else create one with context.lang
      return {
        updateContext: function updateContext(context, properties) {
          return {
            synthDef: _this2._prepareForAdd(context, properties)
          };
        },
        callOrder: 'SELF_THEN_CHILDREN'
      };
    }
  }, {
    key: '_prepareForAdd',
    value: function _prepareForAdd(context, properties) {
      var _this3 = this;

      if (properties.source) {
        return this.compileSource(context, properties.source).then(function (result) {
          return _this3._sendSynthDef(context, properties, result);
        });
      }

      if (properties.compileFrom) {
        return this.compileFrom(context, properties.compileFrom).then(function (result) {
          return _this3._sendSynthDef(context, properties, result);
        });
      }

      var lf = properties.loadFrom;
      if (lf) {
        // TODO: this is a bad assumption
        // Should allow to read .json metadata files and/or to set the name
        var result = {
          name: _path2.default.basename(lf, _path2.default.extname(lf))
        };
        return context.scserver.callAndResponse((0, _msg.defLoad)(_path2.default.resolve(lf))).then(function () {
          return result;
        });
      }

      throw new Error('Nothing specified for SCSynthDef: source|compileFrom|loadFrom');
    }
  }, {
    key: '_sendSynthDef',
    value: function _sendSynthDef(context, properties, result) {
      // ! alters context
      // name bytes
      // synthDefName should be set for child context
      this.putSynthDef(context, result.name, result.synthDesc);
      // you need to use a setter
      context.synthDef = result;
      // context.synthDefName = result.name;
      var buffer = new Buffer(result.bytes);
      var promises = [context.scserver.callAndResponse((0, _msg.defRecv)(buffer))];
      if (properties.saveToDir) {
        promises.push(this._writeSynthDef(result.name, buffer, result.synthDesc, properties.saveToDir));
      }
      return Promise.all(promises).then(function () {
        return result;
      });
    }
  }, {
    key: '_writeSynthDef',
    value: function _writeSynthDef(name, buffer, synthDesc, saveToDir) {
      return new Promise(function (resolve, reject) {
        var dir = _path2.default.resolve(saveToDir);
        var pathname = _path2.default.join(dir, name + '.scsyndef');
        _fs2.default.writeFile(pathname, buffer, function (err) {
          if (err) {
            reject(err);
          } else {
            var descpath = _path2.default.join(dir, name + '.json');
            _fs2.default.writeFile(descpath, JSON.stringify(synthDesc, null, 2), function (err2) {
              err2 ? reject(err2) : resolve();
            });
          }
        });
      });
    }

    /**
     * Returns a Promise for a SynthDef result object: name, bytes, synthDesc
     */

  }, {
    key: 'compileSource',
    value: function compileSource(context, sourceCode, pathName) {
      var _this4 = this;

      var wrappedCode = '{\n      var def = { ' + sourceCode + ' }.value.asSynthDef;\n      (\n        name: def.name,\n        synthDesc: def.asSynthDesc.asJSON(),\n        bytes: def.asBytes()\n      )\n    }.value;';
      return context.sclang.interpret(wrappedCode, undefined, false, false, true).catch(function (error) {
        error.annotate('Failed to compile SynthDef  ' + error.message + ' ' + (pathName || ''), {
          properties: _this4.properties,
          sourceCode: sourceCode
        });
        return Promise.reject(error);
      });
    }

    /**
     * Returns a Promise for a SynthDef result object: name, bytes, synthDesc
     */

  }, {
    key: 'compileFrom',
    value: function compileFrom(context, sourcePath) {
      var _this5 = this;

      return new Promise(function (resolve, reject) {
        _fs2.default.readFile(_path2.default.resolve(sourcePath), function (err, fileBuf) {
          if (err) {
            reject(err);
          } else {
            _this5.compileSource(context, fileBuf.toString('ascii'), sourcePath).then(resolve, reject);
          }
        });
      });
    }
  }, {
    key: 'add',
    value: function add() {
      var _this6 = this;

      return {
        run: function run(context, properties) {
          if (properties.compileFrom && properties.watch) {
            // should use updater here
            context._watcher = _fs2.default.watch(_path2.default.resolve(properties.compileFrom), function () {
              _this6.compileFrom(context, properties.compileFrom).then(function (result) {
                return _this6._sendSynthDef(context, properties, result).catch(function (error) {
                  return console.error(error);
                });
              });
            });
          }
        }
      };
    }
  }, {
    key: 'remove',
    value: function remove() {
      return {
        scserver: {
          // no need to do this if server has gone away
          msg: function msg(context) {
            if (context.synthDef) {
              return (0, _msg.defFree)(context.synthDef.name);
            }
          }
        },
        run: function run(context) {
          if (context._watcher) {
            context._watcher.close();
            delete context._watcher;
          }
        }
      };
    }
  }, {
    key: 'putSynthDef',
    value: function putSynthDef(context, synthDefName, synthDesc) {
      context.scserver.state.mutate(StateKeys.SYNTH_DEFS, function (state) {
        return state.set(synthDefName, synthDesc);
      });
    }

    /**
     * Return the value of this object, which is the synthDef: {name, bytes, synthDesc}
     * for use in /s_new.
     */

  }, {
    key: 'value',
    value: function value(context) {
      if (!context.synthDef) {
        throw new Error('No synthDef in context for SCSynthDef');
      }
      return context.synthDef;
    }
  }]);

  return SCSynthDef;
}(_dryadic.Dryad);

exports.default = SCSynthDef;
//# sourceMappingURL=SCSynthDef.js.map
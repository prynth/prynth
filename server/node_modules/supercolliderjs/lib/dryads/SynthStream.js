'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _dryadic = require('dryadic');

var _Group = require('./Group');

var _Group2 = _interopRequireDefault(_Group);

var _msg = require('../server/osc/msg.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var LATENCY = 0.03;

/**
 * Given a Bacon.js stream that returns objects, this spawns a series of Synths.
 *
 * Properties:
 *  {Bacon.EventStream} stream
 *  {Object} defaultParams
 *
 * The event values should be simple JavaScript objects:
 *
 * {
 *   defName: 'synthDefName',
 *   args: {
 *     out: 0,
 *     freq: 440
 *   }
 * }
 *
 * defaultParams is a fixed object into which the event value is merged.
 */

var SynthStream = function (_Dryad) {
  _inherits(SynthStream, _Dryad);

  function SynthStream() {
    _classCallCheck(this, SynthStream);

    return _possibleConstructorReturn(this, (SynthStream.__proto__ || Object.getPrototypeOf(SynthStream)).apply(this, arguments));
  }

  _createClass(SynthStream, [{
    key: 'add',
    value: function add(player) {
      var _this2 = this;

      return {
        run: function run(context, properties) {
          var subscription = properties.stream.subscribe(function (event) {
            // This assumes a Bacon event.
            // Should validate that event.value is object
            // assumes context has not been updated and is the same event
            // use player.getContext()
            _this2.handleEvent(event.value(), context, properties, player);
          });
          player.updateContext(context, { subscription: subscription });
        }
        // initial event
        // scserver: {
        //   bundle: ()
        // }
      };
    }
  }, {
    key: 'commandsForEvent',
    value: function commandsForEvent(event, context, properties) {
      var msgs = [];
      var updateContext = void 0;
      var nodeIDs = context.nodeIDs || {};
      var key = event.key ? String(event.key) : undefined;

      switch (event.type) {
        case 'noteOff':
          {
            // if no key then there is no way to shut off notes
            var nodeID = nodeIDs[key];
            if (nodeID) {
              msgs.push((0, _msg.nodeFree)(nodeID));
              // TODO: if synthDef hasGate else just free it
              // msgs.push(nodeSet(nodeID, [event.gate || 'gate', 0]));
              // remove from nodeIDs
              updateContext = {
                nodeIDs: _lodash2.default.omit(nodeIDs, [key])
              };
            } else {
              throw new Error('NodeID was not registered for event key ' + (key || 'undefined'));
            }
            break;
          }

        default:
          {
            // noteOn
            var defaultParams = properties.defaultParams || {};
            var args = _lodash2.default.assign({ out: context.out || 0 }, defaultParams.args, event.args);
            var defName = event.defName || properties.defaultParams.defName;
            // if ev.id then create a nodeID and store it
            // otherwise it is anonymous
            var _nodeID = -1;
            if (key) {
              _nodeID = context.scserver.state.nextNodeID();
              // store the nodeID
              updateContext = {
                nodeIDs: _lodash2.default.assign({}, nodeIDs, _defineProperty({}, key, _nodeID))
              };
            }
            var synth = (0, _msg.synthNew)(defName, _nodeID, _msg.AddActions.TAIL, context.group, args);
            msgs.push(synth);
          }
      }

      return {
        scserver: {
          bundle: {
            time: LATENCY,
            packets: msgs
          }
        },
        updateContext: updateContext
      };
    }
  }, {
    key: 'handleEvent',
    value: function handleEvent(event, context, properties, player) {
      player.callCommand(context.id, this.commandsForEvent(event, context, properties));
    }
  }, {
    key: 'remove',
    value: function remove() {
      return {
        run: function run(context) {
          if (context.subscription) {
            if (_lodash2.default.isFunction(context.subscription)) {
              // baconjs style
              context.subscription();
            } else {
              // Rx style
              context.subscription.dispose();
            }
          }
        }
      };
    }
  }, {
    key: 'subgraph',
    value: function subgraph() {
      return new _Group2.default({}, [this]);
    }
  }]);

  return SynthStream;
}(_dryadic.Dryad);

exports.default = SynthStream;
//# sourceMappingURL=SynthStream.js.map
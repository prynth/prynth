'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _utils = require('../../server/osc/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Just in time osc scheduler used by scserver middleware
 * to send OSC messages.
 *
 * This is used by the scserver middleware.
 *
 * It is used by calling `.schedLoop(getNext, epoch)`
 */
var OSCSched = function () {

  /**
   * constructor -
   *
   * @param  {Function} sendFn                   Function that sends OSC bundles to the server.
   *                                             args: (time, msgs)
   * @param  {number} latency=0.05               Just-in-time latency in seconds.
   *                                             Bundles are schedule in the javascript process
   *                                             and sent to the server just before the event time.
   * @param  {Function} setTimeoutFn=setTimeout  JavaScript setTimeout (injectable for mocking tests)
   * @param  {Function} clearTimeoutFn=clearTimeout JavaScript setInterval (injectable for mocking tests)
   */
  function OSCSched(sendFn) {
    var latency = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.05;
    var setTimeoutFn = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : setTimeout;
    var clearTimeoutFn = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : clearTimeout;

    _classCallCheck(this, OSCSched);

    this.sendFn = sendFn;
    this.latency = latency;
    this.setTimeout = setTimeoutFn;
    this.clearTimeout = clearTimeoutFn;

    this.getNextFn = function () {
      return undefined;
    };
    this.epoch = _lodash2.default.now();
    this.timerId = undefined;
  }

  /**
   * schedLoop - start a loop that gets the next event and schedules it to be sent
   *
   * @param  {Function} getNextFn A function that returns the next event object to send.
   *
   *                              Args: now, memo
   *
   *                              Returns an object:
   *
   *                              {time: secondsSinceEpoch, msgs: [], memo: {}}
   *
   *                              If it does not return anything (void) then the loop will end.
   *
   *                              memo is an object that the loop function can store
   *                              state in. eg. list index for an iterator
   *
   *                              msgs may be an array of osc messages or a function
   *                              called at send time that will return an array of osc messages.
   *
   * @param  {float} epoch     Javascript timestamp (milliseconds since 1970 UTC)
   */


  _createClass(OSCSched, [{
    key: 'schedLoop',
    value: function schedLoop(getNextFn, epoch) {
      this.getNextFn = getNextFn;
      if (!this.getNextFn) {
        throw new Error('getNextFn is null');
      }

      if (epoch) {
        this.epoch = epoch;
      }

      if (!this.epoch) {
        throw new Error('Epoch not set: ' + this.epoch);
      }

      this._schedNext();
    }
  }, {
    key: '_schedNext',
    value: function _schedNext(memo, logicalNow) {
      if (this.timerId) {
        this.clearTimeout(this.timerId);
        this.timerId = undefined;
      }

      var now = (_lodash2.default.now() - this.epoch) / 1000;
      if (!logicalNow) {
        logicalNow = now;
      }

      var next = memo ? this.getNextFn(logicalNow, memo) : this.getNextFn(logicalNow);
      if (next) {
        var delta = next.event.time - now;
        if (delta <= this.latency) {
          if (delta > 0) {
            this._send(next.event);
          } else {
            /* eslint no-console: 0 */
            // TODO: throw EventPastDue and catch that, log it with context.log
            console.warn('Event is past due. Skipping.', JSON.stringify({ delta: delta, now: now, event: next.event }));
          }

          // this steps by logical time
          this._schedNext(next.memo, next.event.time);
        } else {
          this._jitSend(now, delta, next);
        }
      }
    }

    /**
     * _jitSend - schedule to send the event just before it should play on the server.
     *
     * Cancels any previously scheduled event.
     *
     * @param  {float} delta seconds to wait
     * @param  {Object} event With .msgs .time and optional .memo
     *                        to be passed to the next call to getNextFn
     */

  }, {
    key: '_jitSend',
    value: function _jitSend(now, delta, next) {
      var _this = this;

      this.timerId = this.setTimeout(function () {
        _this.timerId = null;
        _this._send(next.event);
        _this._schedNext(next.memo, next.event.time);
      }, (delta - this.latency) * 1000);
    }

    /**
     * _send - send the OSC bundle
     *
     * @param  {Object} event
     */

  }, {
    key: '_send',
    value: function _send(event) {
      this.sendFn((0, _utils.deltaTimeTag)(event.time, this.epoch), event.msgs);
    }
  }]);

  return OSCSched;
}();

exports.default = OSCSched;
//# sourceMappingURL=OSCSched.js.map
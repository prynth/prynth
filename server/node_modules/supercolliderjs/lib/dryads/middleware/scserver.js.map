{"version":3,"sources":["../../../src/dryads/middleware/scserver.js"],"names":["scserver","resolveFuncs","command","context","properties","cmds","msg","send","bundle","time","packets","schedLoop","oscSched","sendFn","epoch","callAndResponse","mapValues","_callIfFn","value","thing","isFunction"],"mappings":";;;;;kBA8EwBA,Q;QAkDRC,Y,GAAAA,Y;;AA7HhB;;;;AACA;;;;;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEe,SAASD,QAAT,CACbE,OADa,EAEbC,OAFa,EAGbC,UAHa,EAIM;AACnB,MAAIF,QAAQF,QAAZ,EAAsB;AACpB,QAAIK,OAAOJ,aAAaC,QAAQF,QAArB,EAA+BG,OAA/B,EAAwCC,UAAxC,CAAX;;AAEA;AACA,QAAIC,KAAKC,GAAT,EAAc;AACZ;AACA;AACAH,cAAQH,QAAR,CAAiBO,IAAjB,CAAsBC,MAAtB,CAA6B,IAA7B,EAAmC,CAACH,KAAKC,GAAN,CAAnC;AACD;;AAED;AACA,QAAID,KAAKG,MAAT,EAAiB;AACfL,cAAQH,QAAR,CAAiBO,IAAjB,CAAsBC,MAAtB,CAA6BH,KAAKG,MAAL,CAAYC,IAAzC,EAA+CJ,KAAKG,MAAL,CAAYE,OAA3D;AACD;;AAED;AACA,QAAIL,KAAKM,SAAT,EAAoB;AAClB;AACA,UAAI,CAACR,QAAQS,QAAb,EAAuB;AACrB,YAAMC,SAAS,SAATA,MAAS,CAACJ,IAAD,EAAOC,OAAP;AAAA,iBACbP,QAAQH,QAAR,CAAiBO,IAAjB,CAAsBC,MAAtB,CAA6BC,IAA7B,EAAmCC,OAAnC,CADa;AAAA,SAAf;AAEAP,gBAAQS,QAAR,GAAmB,uBAAaC,MAAb,CAAnB;AACD;;AAEDV,cAAQS,QAAR,CAAiBD,SAAjB,CAA2BN,KAAKM,SAAhC,EAA2CR,QAAQW,KAAnD;AACD;;AAED;AACA;AACA;AACA,QAAIT,KAAKU,eAAT,EAA0B;AACxB,aAAOZ,QAAQH,QAAR,CAAiBe,eAAjB,CAAiCV,KAAKU,eAAtC,CAAP;AACD;AACF;AACF;;AAED;;;;;;;;;AASO,SAASd,YAAT,CACLC,OADK,EAELC,OAFK,EAGLC,UAHK,EAIG;AACR,SAAO,iBAAEY,SAAF,CAAYd,OAAZ,EAAqB;AAAA,WAASe,UAAUC,KAAV,EAAiBf,OAAjB,EAA0BC,UAA1B,CAAT;AAAA,GAArB,CAAP;AACD;;AAED;;;;AAIA,SAASa,SAAT,CAAmBE,KAAnB,EAA0BhB,OAA1B,EAAmCC,UAAnC,EAA+C;AAC7C,SAAO,iBAAEgB,UAAF,CAAaD,KAAb,IAAsBA,MAAMhB,OAAN,EAAeC,UAAf,CAAtB,GAAmDe,KAA1D;AACD","file":"scserver.js","sourcesContent":["/**\n * @flow\n */\nimport _ from 'lodash';\nimport OSCSched from './OSCSched';\nimport type { MsgType } from '../../Types';\n\n/**\n * Command middlware that sends OSC to the SuperCollider server (scsynth).\n *\n * Command objects are collected from each Dryad (`add()` `remove()`) and\n * this middlware is called for each Dryad that has `scserver` commands.\n *\n * @param {Object} command\n *\n * For any of these you may supply a function that is called with context\n * and returns one of these forms.\n *\n * For example, rather than:\n *\n *     msg: ['/n_free', 1005]\n *\n * you would use the context to get the node id to free:\n *\n *     msg: (context) => nodeFree(context.nodeID)\n *\n * Command may have one of these forms:\n *\n * __msg:__ {Array} - OSC message\n *\n *     msg: ['/n_free', 1005]\n *\n * __bundle:__\n *\n *     bundle: {\n *       time: null|Number|Array|Date\n *       packets: Array of OSC messages\n *     }\n *\n * __callAndResponse:__\n *\n *  Returns a Promise. Only used in preparation, not for play / update.\n *  Call and response object creator functions can be found in `osc/msg.js`\n *\n *     callAndResponse: {\n *       call: oscMessage,\n *       response: oscMessagePattern\n *     }\n *\n * __schedLoop:__\n *\n *     schedLoop: (context) => {\n *      // construct a function that will return successive events to be sent\n *      return (now, memo={i: 0}) => {\n *        return {\n *          // time in seconds relative to the context.epoch\n *          time: 0.4,\n *          msgs: [ ],\n *          // memo will be passed into the loop each time\n *          // and can be used to store iterators and loop state.\n *          memo: {i: memo.i + 1}\n *        }\n *      }\n *     }\n *\n * schedLoop takes a function that iterates through events.\n * See `OSCSched`\n *\n * It uses a just-in-time scheduler, keeping the OSC messages in the node process\n * and only sending them to the server just before they should play. This doesn't overload\n * the server with a glut of messages and also allows cancellation and updating of the messages\n * and makes it easy to implement transport controls and looping.\n *\n *\n * @param {Object} context\n * @param {Object} properties\n * @return Promise is only returned when using .callAndResponse\n */\nexport default function scserver(\n  command: Object,\n  context: Object,\n  properties: Object\n): ?Promise<MsgType> {\n  if (command.scserver) {\n    let cmds = resolveFuncs(command.scserver, context, properties);\n\n    // send a single OSC message\n    if (cmds.msg) {\n      // TODO get default latency from context\n      // TODO: should collect all messages into one bundle, in order\n      context.scserver.send.bundle(0.05, [cmds.msg]);\n    }\n\n    // send an OSC bundle\n    if (cmds.bundle) {\n      context.scserver.send.bundle(cmds.bundle.time, cmds.bundle.packets);\n    }\n\n    // schedule events using a schedLoop function\n    if (cmds.schedLoop) {\n      // initialize the scheduler on first use\n      if (!context.oscSched) {\n        const sendFn = (time, packets) =>\n          context.scserver.send.bundle(time, packets);\n        context.oscSched = new OSCSched(sendFn);\n      }\n\n      context.oscSched.schedLoop(cmds.schedLoop, context.epoch);\n    }\n\n    // Preparation commands that get an OSC callback from the server.\n    // Only this one returns.\n    // These are used only in preparation, not for play / update.\n    if (cmds.callAndResponse) {\n      return context.scserver.callAndResponse(cmds.callAndResponse);\n    }\n  }\n}\n\n/**\n * Replace any functions in the command object's values with the result of\n * calling the function.\n *\n * eg. msg: (context) => { ... return ['/s_new', ...]; }\n * becomes msg: ['/s_new', ...]\n *\n * Non-functions are passed through.\n */\nexport function resolveFuncs(\n  command: Object,\n  context: Object,\n  properties: Object\n): Object {\n  return _.mapValues(command, value => _callIfFn(value, context, properties));\n}\n\n/**\n * If its a Function then call it with context and properties\n * @private\n */\nfunction _callIfFn(thing, context, properties) {\n  return _.isFunction(thing) ? thing(context, properties) : thing;\n}\n"]}
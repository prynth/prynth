{"version":3,"sources":["../../src/dryads/SynthEventList-0.js"],"names":[],"mappings":"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","file":"SynthEventList-0.js","sourcesContent":["\nimport {Dryad} from 'dryadic';\nimport Group from './Group';\nimport {\n  synthNew,\n  AddActions\n} from '../server/osc/msg';\nimport * as _  from 'underscore';\n\n\n/**\n * Takes a list of synth event objects with relative times and schedules them.\n *\n * ## properties\n *\n * __events:__ Array\n *\n * The event values should be simple JavaScript objects:\n *\n *     {\n *       defName: 'synthDefName',\n *       args: {\n *         out: 0,\n *         freq: 440\n *       },\n *       time: 0.3\n *     }\n *\n *  Where time is seconds relative to the epoch. The epoch is the start time of\n *  the dryadic tree, unless a parent Dryad has set a new epoch into context.\n *\n *    epoch: number|Date|undefined\n *      Optional epoch that the event times in the list are relative to.\n *      Can also be updated by the updateStream\n *      default: context.epoch or now\n *\n * __updateStream:__ Bacon stream to push updated event lists of the form:\n *\n *      {\n *        events: [{time: msgs: []}...],\n *        epoch: 123456789\n *      }\n\n *     .events Array\n *     .epoch  number|Date\n *\n * Deprecated: will be replaced with live updating and setting of\n * Any value in a dryadic document from the player or remote client.\n *\n * Pushing a new event list cancels previous events and schedules new events.\n *\n * Note that by default the epoch will be unchanged: relative times\n * are still relative to when the Dryad tree started playing or when any parent\n * Dryad set an epoch in context. This means you update the currently playing score\n * but it doesn't restart from the beginning, it keeps playing.\n *\n * Optionally you may push an .epoch with the updateStream. This can be a date or timestamp\n * slightly in the future. If you pass \"now\" then any events at `0.0` will be too late to play.\n *\n * __defaultParams:__ a fixed object into which the event value is merged.\n *\n * __loopTime:__ Play the events continuously in a loop.\n */\nexport default class SynthEventList extends Dryad {\n\n  /**\n   * @param  {DryadPlayer} player\n   * @return {Object}      Command object\n   */\n  add(player) {\n    let commands = {\n      scserver: {\n        schedLoop: (context) => {\n          // temporary: we need to know the play time of the whole document\n          const epoch = context.epoch || (_.now() + 200);\n          if (epoch !== context.epoch) {\n            context = player.updateContext(context, {epoch});\n          }\n\n          return this._makeSchedLoop(this.properties.events || [], this.properties.loopTime, epoch, context);\n        }\n      }\n    };\n\n    if (this.properties.updateStream) {\n      commands.run = (context) => {\n        let subscription = this.properties.updateStream.subscribe((streamEvent) => {\n          let ee = streamEvent.value();\n          const loopTime = _.isUndefined(ee.loopTime) ? this.properties.loopTime : ee.loopTime;\n\n          let epoch = ee.epoch || context.epoch || (_.now() + 200);\n          if (epoch !== context.epoch) {\n            context = player.updateContext(context, {\n              epoch\n            });\n          }\n\n          player.callCommand(context.id, {\n            scserver: {\n              // need to set epoch as well because OSCSched uses that for relative times\n              schedLoop: (ctx) => this._makeSchedLoop(ee.events || [], loopTime, epoch, ctx)\n            }\n          });\n        });\n\n        player.updateContext(context, {subscription});\n      };\n    }\n\n    return commands;\n  }\n\n  _makeSchedLoop(events, loopTime, epoch, context) {\n    const sorted = this._makeMsgs(events, context);\n    const length = sorted.length;\n    const lastEventTime = length > 0 ? sorted[length - 1].time : 0;\n\n    return (now, memo) => {\n      let timeBase;\n\n      if (length === 0) {\n        return;\n      }\n\n      if (!memo) {\n        memo = {i: 0};\n      }\n\n      if (loopTime) {\n        let numIterations = Math.floor(now / loopTime);\n        if (now > lastEventTime && (now < loopTime)) {\n          // play position is between lastEvent and loopTime\n          // so start search in next loop\n          numIterations = numIterations + 1;\n        }\n\n        if (numIterations <= 0) {\n          timeBase = 0;\n        } else {\n          timeBase = Math.floor(numIterations) * loopTime;\n        }\n\n      } else {\n        timeBase = 0;\n      }\n\n      const startAtIndex = memo.i >= length ? 0 : memo.i;\n\n      // search for one loop length\n      const stopAt = loopTime ? startAtIndex + length : length;\n\n      console.log('==================>');\n      console.log({\n        now,\n        memo,\n        timeBase,\n        loopTime,\n        startAtIndex,\n        stopAt\n      });\n\n      // The next event may be at the same time\n      // but you cannot play the exact same event again.\n      for (let i = startAtIndex; i < stopAt; i += 1) {\n        // if searching across the loop end then wrap around\n        // and add one loopTime to timeBase\n        let index = i;\n        let tb = timeBase;\n        if (loopTime && (i >= length)) {\n          index = i - length;\n          tb = timeBase + loopTime;\n        }\n\n        let e = sorted[index];\n        let time = tb + e.time;\n        let delta = time - now;\n\n        console.log({\n          index,\n          delta,\n          e,\n          time,\n          tb\n        });\n\n        if (delta >= 0) {\n          console.log('found', delta, tb + e.time);\n          return {\n            time: tb + e.time,\n            msgs: e.msgs,\n            memo: {i: index + 1}\n          };\n        }\n      }\n\n      console.log('no event matched');\n      // , last: index\n      // loop back to the start but not if it is the same i as memo.i\n    }\n  }\n\n  _makeMsgs(events, context) {\n    const defaultParams = this.properties.defaultParams || {};\n    return events.sort((a, b) => a.time - b.time).map((event) => {\n      // TODO: do this a jit time in the schedLoop\n      const defName = event.defName || defaultParams.defName;\n      const args = _.assign({out: context.out || 0}, defaultParams.args, event.args);\n      const msg = synthNew(defName, -1, AddActions.TAIL, context.group, args);\n      return {\n        time: event.time,\n        msgs: [msg]\n      };\n    });\n  }\n\n\n  /**\n   * @return {Object}  command object\n   */\n  remove() {\n    return {\n      run: (context) => {\n        if (context.subscription) {\n          if (_.isFunction(context.subscription)) {\n            // baconjs style\n            context.subscription();\n          } else {\n            // Rx style\n            context.subscription.dispose();\n          }\n        }\n      },\n      scserver: {\n        sched: (context) => {\n          // unschedAll\n          return this._makeSchedLoop([], context.epoch, context);\n        }\n      }\n    };\n  }\n\n\n  /**\n   * @return {Dryad}  Wraps itself in a Group so all child Synth events will be removed on removal of the Group.\n   */\n  subgraph() {\n    return new Group({}, [this]);\n  }\n}\n"]}
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _dryadic = require('dryadic');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * An internal utility class for building the subgraph of Synth.
 * If any of the Synth's arg properties is a Dryad then return
 * this wrapper with those Dryads and the Synth as a child of this.
 *
 * These Dryads are then asked for their .synthArg() which is published in
 * the context, available to the (now) child Synth.
 *
 * .synthArg() is for objects like Bus, Synth, Group that are complex things
 * with their own resources but for the Synth that they are being supplied to
 * they need to return a simple integer or float: the bus number,
 * the nodeID of the Synth or Group etc.
 *
 * This ensures that they are before Synth in order of execution and they
 * are prepared (getting busses, nodeIDs) before the Synth.
 *
 * It also means the play graph is much easier to diff and think about
 * because there are no Dryads in properties.
 * Dryads in the play graph are only in children, but you can still
 * for conviencience and readability supply Dryads as properties to the
 * Synth.
 *
 * This design pattern will probably be generalized later for other similiar situations.
 */

var SynthArgs = function (_Dryad) {
  _inherits(SynthArgs, _Dryad);

  function SynthArgs() {
    _classCallCheck(this, SynthArgs);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(SynthArgs).apply(this, arguments));
  }

  return SynthArgs;
}(_dryadic.Dryad);

exports.default = SynthArgs;
//# sourceMappingURL=SynthArgs.js.map
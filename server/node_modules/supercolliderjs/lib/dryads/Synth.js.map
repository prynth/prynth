{"version":3,"sources":["../../src/dryads/Synth.js"],"names":["Synth","updateContext","nodeID","context","scserver","state","nextNodeID","msg","properties","args","mapValues","value","key","_checkOscType","id","isUndefined","out","defName","def","name","TAIL","group","run","then","synthDef","v","Error"],"mappings":";;;;;;;;;;AACA;;AACA;;AACA;;AAKA;;;;;;;;;;;;AAEA;;;;;;;IAOqBA,K;;;;;;;;;;;;AACnB;;;;oCAIwB;AACtB,aAAO,UAAP;AACD;;;oCAEuB;AACtB,aAAO;AACLC,uBAAe;AAAA,iBAAY;AACzBC,oBAAQC,QAAQC,QAAR,CAAiBC,KAAjB,CAAuBC,UAAvB;AADiB,WAAZ;AAAA;AADV,OAAP;AAKD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;0BAEc;AAAA;;AACZ,aAAO;AACLF,kBAAU;AACRG,eAAK,aAACJ,OAAD,EAAUK,UAAV,EAAyB;AAC5B,gBAAIC,OAAO,iBAAEC,SAAF,CAAYF,WAAWC,IAAvB,EAA6B,UAACE,KAAD,EAAQC,GAAR;AAAA,qBACtC,OAAKC,aAAL,CAAmBF,KAAnB,EAA0BC,GAA1B,EAA+BT,QAAQW,EAAvC,CADsC;AAAA,aAA7B,CAAX;AAEA;AACA;AACA;AACA,gBAAI,iBAAEC,WAAF,CAAcN,KAAKO,GAAnB,KAA2B,CAAC,iBAAED,WAAF,CAAcZ,QAAQa,GAAtB,CAAhC,EAA4D;AAC1DP,mBAAKO,GAAL,GAAWb,QAAQa,GAAnB;AACD;;AAED,gBAAIC,UAAU,OAAKJ,aAAL,CACZL,WAAWU,GAAX,IAAkBV,WAAWU,GAAX,CAAeC,IADrB,EAEZ,UAFY,EAGZhB,QAAQW,EAHI,CAAd;AAKA,mBAAO,mBACLG,OADK,EAELd,QAAQD,MAFH,EAGL,gBAAWkB,IAHN,EAILjB,QAAQkB,KAJH,EAKLZ,IALK,CAAP;AAOD;AAvBO,SADL;AA0BLa,aAAK,aAACnB,OAAD,EAAUK,UAAV,EAAyB;AAC5B,iBAAO,6BACLL,QAAQC,QADH,EAELD,QAAQW,EAFH,EAGLX,QAAQD,MAHH,EAILqB,IAJK,CAIA,kBAAU;AACf;AACA,8CAAgBpB,QAAQC,QAAxB,EAAkCD,QAAQD,MAA1C,EAAkD;AAChDsB,wBAAUhB,WAAWU,GAAX,CAAeC;AADuB,aAAlD;AAGA,mBAAOjB,MAAP;AACD,WAVM,CAAP;AAWD;AAtCI,OAAP;AAwCD;;;6BAEgB;AACf,aAAO;AACLE,kBAAU;AACRG,eAAK;AAAA,mBAAW,mBAASJ,QAAQD,MAAjB,CAAX;AAAA;AADG,SADL;AAILoB,aAAK;AAAA,iBAAW,8BAAYnB,QAAQC,QAApB,EAA8BD,QAAQW,EAAtC,EAA0CX,QAAQD,MAAlD,CAAX;AAAA;AAJA,OAAP;AAMD;;;kCAEauB,C,EAAQb,G,EAAaE,E,EAAiB;AAClD,qBAAeW,CAAf,yCAAeA,CAAf;AACE,aAAK,QAAL;AACA,aAAK,QAAL;AACE;AACA,iBAAOA,CAAP;AACF;AACE,gBAAM,IAAIC,KAAJ,iCAC0Bd,GAD1B,mBAC0Ca,CAD1C,yCAC0CA,CAD1C,YACgDA,CADhD,YACwDX,EADxD,CAAN;AANJ;AAUD;;;;;;kBAzFkBd,K","file":"Synth.js","sourcesContent":["/* @flow */\nimport { Dryad } from 'dryadic';\nimport { synthNew, nodeFree, AddActions } from '../server/osc/msg';\nimport {\n  whenNodeGo,\n  whenNodeEnd,\n  updateNodeState\n} from '../server/node-watcher';\nimport _ from 'lodash';\n\n/**\n * Creates a synth on the server.\n *\n * Properties:\n * - def\n * - args\n */\nexport default class Synth extends Dryad {\n  /**\n   * If there is no SCServer in the parent context,\n   * then this will wrap itself in an SCServer\n   */\n  requireParent(): string {\n    return 'SCServer';\n  }\n\n  prepareForAdd(): Object {\n    return {\n      updateContext: context => ({\n        nodeID: context.scserver.state.nextNodeID()\n      })\n    };\n  }\n\n  // synthDefName(context:Object) : string {\n  //   // The parent SCSynthDef publishes both .synthDef (object) and .synthDefName to context\n  //   let name = _.isString(this.properties.def) ? this.properties.def : (context.synthDef && context.synthDef.name);\n  //   if (!name) {\n  //     throw new Error('No synthDefName supplied to Synth', context);\n  //   }\n  //   return name;\n  // }\n\n  add(): Object {\n    return {\n      scserver: {\n        msg: (context, properties) => {\n          let args = _.mapValues(properties.args, (value, key) =>\n            this._checkOscType(value, key, context.id));\n          // if out is not set in args and out is in synthdef\n          // then set it from context\n          // TODO: check that synthDef has an arg named out\n          if (_.isUndefined(args.out) && !_.isUndefined(context.out)) {\n            args.out = context.out;\n          }\n\n          let defName = this._checkOscType(\n            properties.def && properties.def.name,\n            'def.name',\n            context.id\n          );\n          return synthNew(\n            defName,\n            context.nodeID,\n            AddActions.TAIL,\n            context.group,\n            args\n          );\n        }\n      },\n      run: (context, properties) => {\n        return whenNodeGo(\n          context.scserver,\n          context.id,\n          context.nodeID\n        ).then(nodeID => {\n          // TODO: call a method instead so its testable\n          updateNodeState(context.scserver, context.nodeID, {\n            synthDef: properties.def.name\n          });\n          return nodeID;\n        });\n      }\n    };\n  }\n\n  remove(): Object {\n    return {\n      scserver: {\n        msg: context => nodeFree(context.nodeID)\n      },\n      run: context => whenNodeEnd(context.scserver, context.id, context.nodeID)\n    };\n  }\n\n  _checkOscType(v: any, key: string, id: string): any {\n    switch (typeof v) {\n      case 'number':\n      case 'string':\n        // case 'Buffer':\n        return v;\n      default:\n        throw new Error(\n          `Invalid OSC type for Synth ${key}: [${typeof v}: ${v}] @ ${id}`\n        );\n    }\n  }\n}\n"]}
{"version":3,"sources":["../../src/dryads/SynthEventList.js"],"names":["SynthEventList","player","commands","scserver","schedLoop","context","properties","epoch","now","updateContext","_makeSchedLoop","events","loopTime","updateStream","assign","run","subscription","subscribe","ee","streamEvent","value","isUndefined","callCommand","id","ctx","synthEvents","_makeMsgs","defaultParams","map","defName","event","args","out","msg","TAIL","group","time","msgs","isFunction","dispose","sched"],"mappings":"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","file":"SynthEventList.js","sourcesContent":["/* @flow */\nimport _ from 'lodash';\n\nimport { Dryad } from 'dryadic';\nimport Group from './Group';\nimport type { DryadPlayer } from 'dryadic';\n\nimport { synthNew, AddActions } from '../server/osc/msg';\n\nimport { loopedEventListIterator, eventListIterator } from './utils/iterators';\n\n/**\n * Takes a list of synth event objects with relative times and schedules them.\n *\n * ## properties\n *\n * __events:__ Array\n *\n * The event values should be simple JavaScript objects:\n *\n *     {\n *       defName: 'synthDefName',\n *       args: {\n *         out: 0,\n *         freq: 440\n *       },\n *       time: 0.3\n *     }\n *\n *  Where time is seconds relative to the epoch. The epoch is the start time of\n *  the dryadic tree, unless a parent Dryad has set a new epoch into context.\n *\n *    epoch: number|Date|undefined\n *      Optional epoch that the event times in the list are relative to.\n *      Can also be updated by the updateStream\n *      default: context.epoch or now\n *\n * __updateStream:__ Bacon stream to push updated event lists of the form:\n *\n *      {\n *        events: [{time: msgs: []}...],\n *        epoch: 123456789\n *      }\n\n *     .events Array\n *     .epoch  number|Date\n *\n * Deprecated: will be replaced with live updating and setting of\n * Any value in a dryadic document from the player or remote client.\n *\n * Pushing a new event list cancels previous events and schedules new events.\n *\n * Note that by default the epoch will be unchanged: relative times\n * are still relative to when the Dryad tree started playing or when any parent\n * Dryad set an epoch in context. This means you update the currently playing score\n * but it doesn't restart from the beginning, it keeps playing.\n *\n * Optionally you may push an .epoch with the updateStream. This can be a date or timestamp\n * slightly in the future. If you pass \"now\" then any events at `0.0` will be too late to play.\n *\n * __defaultParams:__ a fixed object into which the event value is merged.\n *\n * __loopTime:__ Play the events continuously in a loop.\n */\nexport default class SynthEventList extends Dryad {\n  /**\n   * @param  {DryadPlayer} player\n   * @return {Object}      Command object\n   */\n  add(player: DryadPlayer): Object {\n    let commands = {\n      scserver: {\n        schedLoop: (context, properties) => {\n          // temporary: we need to know the play time of the whole document\n          const epoch = context.epoch || _.now() + 200;\n          if (epoch !== context.epoch) {\n            context = player.updateContext(context, { epoch });\n          }\n\n          return this._makeSchedLoop(\n            properties.events || [],\n            properties.loopTime,\n            epoch,\n            context\n          );\n        }\n      }\n    };\n\n    // built-in stream support will be added to Dryadic\n    // for now it is hard to detect Bacon.Bus as being an object,\n    if (this.properties.updateStream) {\n      commands = _.assign(commands, {\n        run: (context, properties) => {\n          let subscription = properties.updateStream.subscribe(streamEvent => {\n            let ee = streamEvent.value();\n            const loopTime = _.isUndefined(ee.loopTime)\n              ? properties.loopTime\n              : ee.loopTime;\n            let epoch = ee.epoch || context.epoch || _.now() + 200;\n            if (epoch !== context.epoch) {\n              context = player.updateContext(context, {\n                epoch\n              });\n            }\n\n            player.callCommand(context.id, {\n              scserver: {\n                // need to set epoch as well because OSCSched uses that for relative times\n                schedLoop: (ctx /*, props*/) =>\n                  this._makeSchedLoop(ee.events || [], loopTime, ctx)\n              }\n            });\n          });\n\n          player.updateContext(context, { subscription });\n        }\n      });\n    }\n\n    return commands;\n  }\n\n  _makeSchedLoop(\n    events: Array<Object>,\n    loopTime: ?number,\n    context: Object\n  ): Function {\n    const synthEvents = this._makeMsgs(events, context);\n    return loopTime\n      ? loopedEventListIterator(synthEvents, loopTime)\n      : eventListIterator(synthEvents);\n  }\n\n  _makeMsgs(events: Array<Object>, context: Object): [Object] {\n    const defaultParams = this.properties.defaultParams || {};\n    return events.map(event => {\n      // TODO: do this a jit time in the schedLoop\n      const defName = event.defName || defaultParams.defName;\n      const args = _.assign(\n        { out: context.out || 0 },\n        defaultParams.args,\n        event.args\n      );\n      const msg = synthNew(defName, -1, AddActions.TAIL, context.group, args);\n      return {\n        time: event.time,\n        msgs: [msg]\n      };\n    });\n  }\n\n  /**\n   * @return {Object}  command object\n   */\n  remove(): Object {\n    return {\n      run: (context: Object) => {\n        if (context.subscription) {\n          if (_.isFunction(context.subscription)) {\n            // baconjs style\n            context.subscription();\n          } else {\n            // Rx style\n            context.subscription.dispose();\n          }\n        }\n      },\n      scserver: {\n        sched: (context: Object) => {\n          // unschedAll\n          return this._makeSchedLoop([], context.epoch, context);\n        }\n      }\n    };\n  }\n\n  /**\n   * @return {Dryad}  Wraps itself in a Group so all child Synth events will be removed on removal of the Group.\n   */\n  subgraph(): Dryad {\n    return new Group({}, [this]);\n  }\n}\n"]}
{"version":3,"sources":["../../src/dryads/SynthStream.js"],"names":["LATENCY","SynthStream","player","run","context","properties","subscription","stream","subscribe","handleEvent","event","value","updateContext","msgs","nodeIDs","key","String","undefined","type","nodeID","push","omit","Error","defaultParams","args","assign","out","defName","scserver","state","nextNodeID","synth","TAIL","group","bundle","time","packets","callCommand","id","commandsForEvent","isFunction","dispose"],"mappings":"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","file":"SynthStream.js","sourcesContent":["/* @flow */\nimport _ from 'lodash';\nimport { Dryad } from 'dryadic';\nimport type { DryadPlayer } from 'dryadic';\nimport Group from './Group';\nimport { synthNew, nodeFree, AddActions } from '../server/osc/msg.js';\n\nconst LATENCY = 0.03;\n\n/**\n * Given a Bacon.js stream that returns objects, this spawns a series of Synths.\n *\n * Properties:\n *  {Bacon.EventStream} stream\n *  {Object} defaultParams\n *\n * The event values should be simple JavaScript objects:\n *\n * {\n *   defName: 'synthDefName',\n *   args: {\n *     out: 0,\n *     freq: 440\n *   }\n * }\n *\n * defaultParams is a fixed object into which the event value is merged.\n */\nexport default class SynthStream extends Dryad {\n  add(player: DryadPlayer): Object {\n    return {\n      run: (context: Object, properties: Object) => {\n        let subscription = properties.stream.subscribe(event => {\n          // This assumes a Bacon event.\n          // Should validate that event.value is object\n          // assumes context has not been updated and is the same event\n          // use player.getContext()\n          this.handleEvent(event.value(), context, properties, player);\n        });\n        player.updateContext(context, { subscription });\n      }\n      // initial event\n      // scserver: {\n      //   bundle: ()\n      // }\n    };\n  }\n\n  commandsForEvent(event: Object, context: Object, properties: Object): Object {\n    const msgs = [];\n    let updateContext;\n    let nodeIDs = context.nodeIDs || {};\n    let key = event.key ? String(event.key) : undefined;\n\n    switch (event.type) {\n      case 'noteOff': {\n        // if no key then there is no way to shut off notes\n        // other than sending to the group\n        let nodeID: number = nodeIDs[key];\n        if (nodeID) {\n          msgs.push(nodeFree(nodeID));\n          // TODO: if synthDef hasGate else just free it\n          // msgs.push(nodeSet(nodeID, [event.gate || 'gate', 0]));\n          // remove from nodeIDs\n          updateContext = {\n            nodeIDs: _.omit(nodeIDs, [key])\n          };\n        } else {\n          throw new Error(\n            `NodeID was not registered for event key ${key || 'undefined'}`\n          );\n        }\n        break;\n      }\n\n      default: {\n        // noteOn\n        let defaultParams = properties.defaultParams || {};\n        const args = _.assign(\n          { out: context.out || 0 },\n          defaultParams.args,\n          event.args\n        );\n        const defName = event.defName || properties.defaultParams.defName;\n        // if ev.id then create a nodeID and store it\n        // otherwise it is anonymous\n        let nodeID = -1;\n        if (key) {\n          nodeID = context.scserver.state.nextNodeID();\n          // store the nodeID\n          updateContext = {\n            nodeIDs: _.assign({}, nodeIDs, {\n              [key]: nodeID\n            })\n          };\n        }\n        const synth = synthNew(\n          defName,\n          nodeID,\n          AddActions.TAIL,\n          context.group,\n          args\n        );\n        msgs.push(synth);\n      }\n    }\n\n    return {\n      scserver: {\n        bundle: {\n          time: LATENCY,\n          packets: msgs\n        }\n      },\n      updateContext\n    };\n  }\n\n  handleEvent(\n    event: Object,\n    context: Object,\n    properties: Object,\n    player: DryadPlayer\n  ) {\n    player.callCommand(\n      context.id,\n      this.commandsForEvent(event, context, properties)\n    );\n  }\n\n  remove(): Object {\n    return {\n      run: (context: Object) => {\n        if (context.subscription) {\n          if (_.isFunction(context.subscription)) {\n            // baconjs style\n            context.subscription();\n          } else {\n            // Rx style\n            context.subscription.dispose();\n          }\n        }\n      }\n    };\n  }\n\n  subgraph(): Dryad {\n    return new Group({}, [this]);\n  }\n}\n"]}
{"version":3,"sources":["../../src/dryads/CompileSynthDef.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;IAQqB;;;AAEnB,WAFmB,eAEnB,CAAY,OAAZ,EAAqB,UAArB,EAA8C;QAAb,iEAAS,kBAAI;;0BAF3B,iBAE2B;;kEAF3B,4BAGX,EAAC,gBAAD,EAAU,sBAAV,IAAuB,WADe;GAA9C;;eAFmB;;oCAMH;AACd,aAAO,QAAP,CADc;;;;oCAIA;;;AACd,UAAI,yCACc,KAAK,UAAL,CAAgB,UAAhB,iFACmD,KAAK,UAAL,CAAgB,OAAhB,+HAFjE,CADU;;AAUd,aAAO;AACL,gBAAQ,gBAAC,OAAD,EAAa;AACnB,iBAAO,QAAQ,MAAR,CAAe,SAAf,CAAyB,WAAzB,EAAsC,SAAtC,EAAiD,KAAjD,EAAwD,KAAxD,EAA+D,IAA/D,EACJ,IADI,CACC,UAAC,MAAD,EAAY;AAChB,wBAAY,OAAZ,EAAqB,OAAK,UAAL,CAAgB,OAAhB,EAAyB,OAAO,SAAP,CAA9C,CADgB;AAEhB,mBAAO,IAAI,MAAJ,CAAW,OAAO,KAAP,CAAlB,CAFgB;WAAZ,EAGH,UAAC,KAAD,EAAW;AACZ,mBAAO,QAAQ,MAAR,CAAe;AACpB,6DAA4C,OAAK,UAAL,CAAgB,OAAhB,OAA5C;AACA,qBAAO,MAAM,KAAN;AACP,0BAAY,OAAK,UAAL,CAAgB,UAAhB;aAHP,CAAP,CADY;WAAX,CAJL,CADmB;SAAb;OADV,CAVc;;;;0BA2BV;AACJ,aAAO;AACL,iBAAS;AACP,2BAAiB,yBAAC,OAAD;mBAAa,SA9C9B,QA8C8B,CAAQ,QAAQ,MAAR;WAArB;SADnB;OADF,CADI;;;;6BAQG;;;AACP,aAAO;AACL,iBAAS;;AAEP,eAAK;mBAAM,SAvDF,QAuDE,CAAQ,OAAK,UAAL,CAAgB,OAAhB;WAAd;SAFP;OADF,CADO;;;;SA7CU;WAPb;;;;;kBAOa;AAyDrB,IAAM,YAAY;AAChB,cAAY,YAAZ;CADI;;AAIN,SAAS,WAAT,CAAqB,OAArB,EAA8B,OAA9B,EAAuC,SAAvC,EAAkD;AAChD,UAAQ,OAAR,CAAgB,KAAhB,CAAsB,MAAtB,CAA6B,UAAU,UAAV,EAAsB,UAAC,KAAD,EAAW;AAC5D,WAAO,MAAM,GAAN,CAAU,OAAV,EAAmB,SAAnB,CAAP,CAD4D;GAAX,CAAnD,CADgD;CAAlD","file":"CompileSynthDef.js","sourcesContent":["\nimport {Dryad} from 'dryadic';\nimport {defRecv, defFree} from '../server/osc/msg.js';\n\n\n/**\n * Compile a SynthDef from sclang source code.\n */\nexport default class CompileSynthDef extends Dryad {\n\n  constructor(defName, sourceCode, children=[]) {\n    super({defName, sourceCode}, children);\n  }\n\n  requireParent() {\n    return 'SCLang';\n  }\n\n  prepareForAdd() {\n    var wrappedCode = `{\n      var source = ${ this.properties.sourceCode };\n      var def = if(source.isKindOf(SynthDef), { source }, { SynthDef(\"${ this.properties.defName }\", source) });\n      (\n        synthDesc: def.asSynthDesc.asJSON(),\n        bytes: def.asBytes()\n      )\n    }.value;`;\n\n    return {\n      buffer: (context) => {\n        return context.sclang.interpret(wrappedCode, undefined, false, false, true)\n          .then((result) => {\n            putSynthDef(context, this.properties.defName, result.synthDesc);\n            return new Buffer(result.bytes);\n          }, (error) => {\n            return Promise.reject({\n              description: `Failed to compile SynthDef '${this.properties.defName}'`,\n              error: error.error,\n              sourceCode: this.properties.sourceCode\n            });\n          });\n      }\n    };\n  }\n\n  add() {\n    return {\n      scsynth: {\n        callAndResponse: (context) => defRecv(context.buffer)\n      }\n    };\n  }\n\n  remove() {\n    return {\n      scsynth: {\n        // no need to do this if scsynth has gone away\n        msg: () => defFree(this.properties.defName)\n      }\n    };\n  }\n}\n\n\n// temp\nconst StateKeys = {\n  SYNTH_DEFS: 'SYNTH_DEFS'\n};\n\nfunction putSynthDef(context, defName, synthDesc) {\n  context.scsynth.state.mutate(StateKeys.SYNTH_DEFS, (state) => {\n    return state.set(defName, synthDesc);\n  });\n}\n"]}
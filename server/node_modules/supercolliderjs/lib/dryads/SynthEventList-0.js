'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _dryadic = require('dryadic');

var _Group = require('./Group');

var _Group2 = _interopRequireDefault(_Group);

var _msg = require('../server/osc/msg');

var _underscore = require('underscore');

var _ = _interopRequireWildcard(_underscore);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Takes a list of synth event objects with relative times and schedules them.
 *
 * ## properties
 *
 * __events:__ Array
 *
 * The event values should be simple JavaScript objects:
 *
 *     {
 *       defName: 'synthDefName',
 *       args: {
 *         out: 0,
 *         freq: 440
 *       },
 *       time: 0.3
 *     }
 *
 *  Where time is seconds relative to the epoch. The epoch is the start time of
 *  the dryadic tree, unless a parent Dryad has set a new epoch into context.
 *
 *    epoch: number|Date|undefined
 *      Optional epoch that the event times in the list are relative to.
 *      Can also be updated by the updateStream
 *      default: context.epoch or now
 *
 * __updateStream:__ Bacon stream to push updated event lists of the form:
 *
 *      {
 *        events: [{time: msgs: []}...],
 *        epoch: 123456789
 *      }

 *     .events Array
 *     .epoch  number|Date
 *
 * Deprecated: will be replaced with live updating and setting of
 * Any value in a dryadic document from the player or remote client.
 *
 * Pushing a new event list cancels previous events and schedules new events.
 *
 * Note that by default the epoch will be unchanged: relative times
 * are still relative to when the Dryad tree started playing or when any parent
 * Dryad set an epoch in context. This means you update the currently playing score
 * but it doesn't restart from the beginning, it keeps playing.
 *
 * Optionally you may push an .epoch with the updateStream. This can be a date or timestamp
 * slightly in the future. If you pass "now" then any events at `0.0` will be too late to play.
 *
 * __defaultParams:__ a fixed object into which the event value is merged.
 *
 * __loopTime:__ Play the events continuously in a loop.
 */

var SynthEventList = function (_Dryad) {
  _inherits(SynthEventList, _Dryad);

  function SynthEventList() {
    _classCallCheck(this, SynthEventList);

    return _possibleConstructorReturn(this, Object.getPrototypeOf(SynthEventList).apply(this, arguments));
  }

  _createClass(SynthEventList, [{
    key: 'add',


    /**
     * @param  {DryadPlayer} player
     * @return {Object}      Command object
     */
    value: function add(player) {
      var _this2 = this;

      var commands = {
        scserver: {
          schedLoop: function schedLoop(context) {
            // temporary: we need to know the play time of the whole document
            var epoch = context.epoch || _.now() + 200;
            if (epoch !== context.epoch) {
              context = player.updateContext(context, { epoch: epoch });
            }

            return _this2._makeSchedLoop(_this2.properties.events || [], _this2.properties.loopTime, epoch, context);
          }
        }
      };

      if (this.properties.updateStream) {
        commands.run = function (context) {
          var subscription = _this2.properties.updateStream.subscribe(function (streamEvent) {
            var ee = streamEvent.value();
            var loopTime = _.isUndefined(ee.loopTime) ? _this2.properties.loopTime : ee.loopTime;

            var epoch = ee.epoch || context.epoch || _.now() + 200;
            if (epoch !== context.epoch) {
              context = player.updateContext(context, {
                epoch: epoch
              });
            }

            player.callCommand(context.id, {
              scserver: {
                // need to set epoch as well because OSCSched uses that for relative times
                schedLoop: function schedLoop(ctx) {
                  return _this2._makeSchedLoop(ee.events || [], loopTime, epoch, ctx);
                }
              }
            });
          });

          player.updateContext(context, { subscription: subscription });
        };
      }

      return commands;
    }
  }, {
    key: '_makeSchedLoop',
    value: function _makeSchedLoop(events, loopTime, epoch, context) {
      var sorted = this._makeMsgs(events, context);
      var length = sorted.length;
      var lastEventTime = length > 0 ? sorted[length - 1].time : 0;

      return function (now, memo) {
        var timeBase = void 0;

        if (length === 0) {
          return;
        }

        if (!memo) {
          memo = { i: 0 };
        }

        if (loopTime) {
          var numIterations = Math.floor(now / loopTime);
          if (now > lastEventTime && now < loopTime) {
            // play position is between lastEvent and loopTime
            // so start search in next loop
            numIterations = numIterations + 1;
          }

          if (numIterations <= 0) {
            timeBase = 0;
          } else {
            timeBase = Math.floor(numIterations) * loopTime;
          }
        } else {
          timeBase = 0;
        }

        var startAtIndex = memo.i >= length ? 0 : memo.i;

        // search for one loop length
        var stopAt = loopTime ? startAtIndex + length : length;

        console.log('==================>');
        console.log({
          now: now,
          memo: memo,
          timeBase: timeBase,
          loopTime: loopTime,
          startAtIndex: startAtIndex,
          stopAt: stopAt
        });

        // The next event may be at the same time
        // but you cannot play the exact same event again.
        for (var i = startAtIndex; i < stopAt; i += 1) {
          // if searching across the loop end then wrap around
          // and add one loopTime to timeBase
          var index = i;
          var tb = timeBase;
          if (loopTime && i >= length) {
            index = i - length;
            tb = timeBase + loopTime;
          }

          var e = sorted[index];
          var time = tb + e.time;
          var delta = time - now;

          console.log({
            index: index,
            delta: delta,
            e: e,
            time: time,
            tb: tb
          });

          if (delta >= 0) {
            console.log('found', delta, tb + e.time);
            return {
              time: tb + e.time,
              msgs: e.msgs,
              memo: { i: index + 1 }
            };
          }
        }

        console.log('no event matched');
        // , last: index
        // loop back to the start but not if it is the same i as memo.i
      };
    }
  }, {
    key: '_makeMsgs',
    value: function _makeMsgs(events, context) {
      var defaultParams = this.properties.defaultParams || {};
      return events.sort(function (a, b) {
        return a.time - b.time;
      }).map(function (event) {
        // TODO: do this a jit time in the schedLoop
        var defName = event.defName || defaultParams.defName;
        var args = _.assign({ out: context.out || 0 }, defaultParams.args, event.args);
        var msg = (0, _msg.synthNew)(defName, -1, _msg.AddActions.TAIL, context.group, args);
        return {
          time: event.time,
          msgs: [msg]
        };
      });
    }

    /**
     * @return {Object}  command object
     */

  }, {
    key: 'remove',
    value: function remove() {
      var _this3 = this;

      return {
        run: function run(context) {
          if (context.subscription) {
            if (_.isFunction(context.subscription)) {
              // baconjs style
              context.subscription();
            } else {
              // Rx style
              context.subscription.dispose();
            }
          }
        },
        scserver: {
          sched: function sched(context) {
            // unschedAll
            return _this3._makeSchedLoop([], context.epoch, context);
          }
        }
      };
    }

    /**
     * @return {Dryad}  Wraps itself in a Group so all child Synth events will be removed on removal of the Group.
     */

  }, {
    key: 'subgraph',
    value: function subgraph() {
      return new _Group2.default({}, [this]);
    }
  }]);

  return SynthEventList;
}(_dryadic.Dryad);

exports.default = SynthEventList;
//# sourceMappingURL=SynthEventList-0.js.map
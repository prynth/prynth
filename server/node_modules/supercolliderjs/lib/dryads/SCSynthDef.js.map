{"version":3,"sources":["../../src/dryads/SCSynthDef.js"],"names":["StateKeys","SYNTH_DEFS","SCSynthDef","properties","source","compileFrom","updateContext","context","synthDef","_prepareForAdd","callOrder","compileSource","then","result","_sendSynthDef","lf","loadFrom","name","basename","extname","scserver","callAndResponse","resolve","Error","putSynthDef","synthDesc","buffer","Buffer","bytes","promises","saveToDir","push","_writeSynthDef","Promise","all","reject","dir","pathname","join","writeFile","err","descpath","JSON","stringify","err2","sourceCode","pathName","wrappedCode","sclang","interpret","undefined","catch","error","annotate","message","sourcePath","readFile","fileBuf","toString","run","watch","_watcher","console","msg","close","synthDefName","state","mutate","set"],"mappings":"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","file":"SCSynthDef.js","sourcesContent":["/* @flow */\n/* eslint no-console: 0 */\nimport { Dryad } from 'dryadic';\nimport { defRecv, defFree, defLoad } from '../server/osc/msg.js';\nimport path from 'path';\nimport fs from 'fs';\nimport type { SCLangError } from '../Errors';\nimport { SclangResultType } from '../Types';\n\nconst StateKeys = {\n  SYNTH_DEFS: 'SYNTH_DEFS'\n};\n\n/**\n * Compile a SynthDef from sclang source code\n * or load a precompiled .scsyndef\n *\n * If compilation is required then it will insert SCLang as a parent if necessary.\n *\n * properties:\n *  - source      - sclang source code to compile\n *  - compileFrom - path of .scd file to compile\n *  - watch  (Boolean)     - watch compileFrom file and recompile on changes\n *  - saveToDir   - path to save compiled .scsyndef to after compiling\n *  - loadFrom    - path of previously compiled .scsyndef file to load to server\n *               This can be used to load SynthDefs without needing sclang running at all.\n *\n * `synthDef` is set in the context for children Dryads to access.\n * It is an object:\n * - .name\n * - .bytes\n * - .synthDesc object with descriptive meta data\n *\n * Note that the synthDefName is not known until after the source code is compiled.\n *\n */\nexport default class SCSynthDef extends Dryad {\n  /**\n   * If there is no SCLang in the parent context,\n   * then this will wrap itself in an SCLang (language interpreter).\n   */\n  requireParent(): ?string {\n    if (this.properties.source || this.properties.compileFrom) {\n      return 'SCLang';\n    }\n  }\n\n  prepareForAdd(): Object {\n    // search context for a SynthDefCompiler, else create one with context.lang\n    return {\n      updateContext: (context, properties) => ({\n        synthDef: this._prepareForAdd(context, properties)\n      }),\n      callOrder: 'SELF_THEN_CHILDREN'\n    };\n  }\n\n  _prepareForAdd(\n    context: Object,\n    properties: Object\n  ): Promise<SclangResultType> {\n    if (properties.source) {\n      return this.compileSource(\n        context,\n        properties.source\n      ).then((result: SclangResultType) =>\n        this._sendSynthDef(context, properties, result));\n    }\n\n    if (properties.compileFrom) {\n      return this.compileFrom(\n        context,\n        properties.compileFrom\n      ).then((result: SclangResultType) =>\n        this._sendSynthDef(context, properties, result));\n    }\n\n    let lf = properties.loadFrom;\n    if (lf) {\n      // TODO: this is a bad assumption\n      // Should allow to read .json metadata files and/or to set the name\n      let result = {\n        name: path.basename(lf, path.extname(lf))\n      };\n      return context.scserver\n        .callAndResponse(defLoad(path.resolve(lf)))\n        .then(() => result);\n    }\n\n    throw new Error(\n      'Nothing specified for SCSynthDef: source|compileFrom|loadFrom'\n    );\n  }\n\n  _sendSynthDef(\n    context: Object,\n    properties: Object,\n    result: SclangResultType\n  ): Promise<SclangResultType> {\n    // ! alters context\n    // name bytes\n    // synthDefName should be set for child context\n    this.putSynthDef(context, result.name, result.synthDesc);\n    // you need to use a setter\n    context.synthDef = result;\n    // context.synthDefName = result.name;\n    let buffer = new Buffer(result.bytes);\n    let promises = [context.scserver.callAndResponse(defRecv(buffer))];\n    if (properties.saveToDir) {\n      promises.push(\n        this._writeSynthDef(\n          result.name,\n          buffer,\n          result.synthDesc,\n          properties.saveToDir\n        )\n      );\n    }\n    return Promise.all(promises).then(() => result);\n  }\n\n  _writeSynthDef(\n    name: string,\n    buffer: Buffer,\n    synthDesc: Object,\n    saveToDir: string\n  ): Promise<*> {\n    return new Promise((resolve, reject) => {\n      let dir = path.resolve(saveToDir);\n      let pathname = path.join(dir, name + '.scsyndef');\n      fs.writeFile(pathname, buffer, err => {\n        if (err) {\n          reject(err);\n        } else {\n          let descpath = path.join(dir, name + '.json');\n          fs.writeFile(descpath, JSON.stringify(synthDesc, null, 2), err2 => {\n            err2 ? reject(err2) : resolve();\n          });\n        }\n      });\n    });\n  }\n\n  /**\n   * Returns a Promise for a SynthDef result object: name, bytes, synthDesc\n   */\n  compileSource(context: Object, sourceCode: string, pathName: ?string) {\n    const wrappedCode = `{\n      var def = { ${sourceCode} }.value.asSynthDef;\n      (\n        name: def.name,\n        synthDesc: def.asSynthDesc.asJSON(),\n        bytes: def.asBytes()\n      )\n    }.value;`;\n    return context.sclang\n      .interpret(wrappedCode, undefined, false, false, true)\n      .catch((error: SCLangError) => {\n        error.annotate(\n          `Failed to compile SynthDef  ${error.message} ${pathName || ''}`,\n          {\n            properties: this.properties,\n            sourceCode\n          }\n        );\n        return Promise.reject(error);\n      });\n  }\n\n  /**\n   * Returns a Promise for a SynthDef result object: name, bytes, synthDesc\n   */\n  compileFrom(context: Object, sourcePath: string): Promise<string> {\n    return new Promise((resolve, reject) => {\n      fs.readFile(path.resolve(sourcePath), (err, fileBuf) => {\n        if (err) {\n          reject(err);\n        } else {\n          this.compileSource(\n            context,\n            fileBuf.toString('ascii'),\n            sourcePath\n          ).then(resolve, reject);\n        }\n      });\n    });\n  }\n\n  add(): Object {\n    return {\n      run: (context, properties) => {\n        if (properties.compileFrom && properties.watch) {\n          // should use updater here\n          context._watcher = fs.watch(\n            path.resolve(properties.compileFrom),\n            () => {\n              this.compileFrom(\n                context,\n                properties.compileFrom\n              ).then((result: SclangResultType) => {\n                return this._sendSynthDef(\n                  context,\n                  properties,\n                  result\n                ).catch(error => console.error(error));\n              });\n            }\n          );\n        }\n      }\n    };\n  }\n\n  remove(): Object {\n    return {\n      scserver: {\n        // no need to do this if server has gone away\n        msg: context => {\n          if (context.synthDef) {\n            return defFree(context.synthDef.name);\n          }\n        }\n      },\n      run: context => {\n        if (context._watcher) {\n          context._watcher.close();\n          delete context._watcher;\n        }\n      }\n    };\n  }\n\n  putSynthDef(context: Object, synthDefName: string, synthDesc: Object) {\n    context.scserver.state.mutate(StateKeys.SYNTH_DEFS, state => {\n      return state.set(synthDefName, synthDesc);\n    });\n  }\n\n  /**\n   * Return the value of this object, which is the synthDef: {name, bytes, synthDesc}\n   * for use in /s_new.\n   */\n  value(context: Object): string {\n    if (!context.synthDef) {\n      throw new Error('No synthDef in context for SCSynthDef');\n    }\n    return context.synthDef;\n  }\n}\n"]}
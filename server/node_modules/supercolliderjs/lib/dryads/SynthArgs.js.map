{"version":3,"sources":["../../src/dryads/SynthArgs.js"],"names":[],"mappings":";;;;;;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;IA0BqB,S;;;;;;;;;;;;kBAAA,S","file":"SynthArgs.js","sourcesContent":["\nimport {Dryad} from 'dryadic';\n\n/**\n * An internal utility class for building the subgraph of Synth.\n * If any of the Synth's arg properties is a Dryad then return\n * this wrapper with those Dryads and the Synth as a child of this.\n *\n * These Dryads are then asked for their .synthArg() which is published in\n * the context, available to the (now) child Synth.\n *\n * .synthArg() is for objects like Bus, Synth, Group that are complex things\n * with their own resources but for the Synth that they are being supplied to\n * they need to return a simple integer or float: the bus number,\n * the nodeID of the Synth or Group etc.\n *\n * This ensures that they are before Synth in order of execution and they\n * are prepared (getting busses, nodeIDs) before the Synth.\n *\n * It also means the play graph is much easier to diff and think about\n * because there are no Dryads in properties.\n * Dryads in the play graph are only in children, but you can still\n * for conviencience and readability supply Dryads as properties to the\n * Synth.\n *\n * This design pattern will probably be generalized later for other similiar situations.\n */\nexport default class SynthArgs extends Dryad {\n\n  // prepareForAdd\n  // prepare the args using my context\n}\n"]}
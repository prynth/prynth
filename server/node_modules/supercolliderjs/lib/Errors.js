'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.SCLangError = exports.SCError = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assign = require('lodash/assign');

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

// http://www.2ality.com/2011/12/subtyping-builtins.html
function copyOwnFrom(target, source) {
  Object.getOwnPropertyNames(source).forEach(function (propName) {
    Object.defineProperty(target, propName, Object.getOwnPropertyDescriptor(source, propName));
  });
  return target;
}

var ExtendableError = function ExtendableError(message) {
  _classCallCheck(this, ExtendableError);

  var superInstance = new Error(message); // Error.apply(null, [message]);
  copyOwnFrom(this, superInstance);
  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = superInstance.stack;
  }
};

/**
 * A custom error class that adds a data field for passing structured error data.
 *
 */


var SCError = exports.SCError = function (_ExtendableError) {
  _inherits(SCError, _ExtendableError);

  function SCError(message, data) {
    _classCallCheck(this, SCError);

    var _this = _possibleConstructorReturn(this, (SCError.__proto__ || Object.getPrototypeOf(SCError)).call(this, message));

    _this.data = data;
    return _this;
  }

  /**
    * Update message and data with additional information.
    * Used when passing the error along but when you want
    * to add additional contextual debugging information.
    */


  _createClass(SCError, [{
    key: 'annotate',
    value: function annotate(message, data) {
      this.message = message;
      this.data = (0, _assign2.default)(this.data, data);
    }
  }]);

  return SCError;
}(ExtendableError);

/**
 * SCLangError - syntax errors while interpreting code, interpret code execution errors, and asynchronous errors.
 *
 * @param type - SyntaxError | Error : Tells which format the error object will be in.
 * @param error - The error data object
 *               An Error will have a stack trace and all of the fields of the sclang error
 *               that it is generated from.
 *               SyntaxError is created by parsing the posted output of sclang.
 *
 * See SuperColliderJS-encodeError
 *
 * @param data - optional additional debug information supplied from supercollider.js
 */


var SCLangError = exports.SCLangError = function (_SCError) {
  _inherits(SCLangError, _SCError);

  function SCLangError(message, type, error) {
    var data = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

    _classCallCheck(this, SCLangError);

    var _this2 = _possibleConstructorReturn(this, (SCLangError.__proto__ || Object.getPrototypeOf(SCLangError)).call(this, message, data));

    _this2.type = type;
    _this2.error = error;
    _this2.data = data;
    return _this2;
  }

  return SCLangError;
}(SCError);
//# sourceMappingURL=Errors.js.map
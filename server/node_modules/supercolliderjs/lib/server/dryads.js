'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.synth = synth;
exports.group = group;
exports.compileSynthDef = compileSynthDef;
exports.putSynthDef = putSynthDef;
exports.stream = stream;
exports.synthStream = synthStream;
exports.interpreter = interpreter;
exports.requireInterpreter = requireInterpreter;
exports.server = server;
exports.requireServer = requireServer;

var _helpers = require('../dryadic/helpers');

var _msg = require('./osc/msg');

var msg = _interopRequireWildcard(_msg);

var _sideEffects = require('./internals/side-effects');

var _nodeWatcher = require('./node-watcher');

var _bluebird = require('bluebird');

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

/* eslint no-console: 0 */
/** DEPRECATED **/
var StateKeys = {
  SYNTH_DEFS: 'SYNTH_DEFS'
};

/**
 * Generates a function that will spawn a Synth when it is called
 *
 * When the function is called, it returns a Promise that will
 * -- when the Synth has succesfully started playing --
 * resolve with the Synth's nodeID.
 *
 * @param {String|Function} synthDefName - the name of the synthDef
 *     or a function that can be called and resolve to a synthDef name
 * @param {Object} args - Arguments may be int|float|string
      If an argument is a function then it will be called.
      If that returns a Promise then it will be resolved and the result of that
      is the final value passed to the Synth.
 * @returns {Function} - when evaluated returns a Promise that resolves with the Synth starts
 */
function synth(synthDefName) {
  var args = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  return function (parentContext) {
    return (0, _helpers.withContext)(parentContext, true).then(function (context) {
      return (0, _helpers.callAndResolve)(synthDefName, context, 'def').then(function (resolvedDefName) {
        var nodeID = (0, _sideEffects.nextNodeID)(context);
        context.nodeID = nodeID;

        // will need to store the children ids
        return (0, _helpers.callAndResolveValues)(args, context).then(function (resolvedArgs) {
          var oscMessage = msg.synthNew(resolvedDefName, nodeID, msg.AddActions.TAIL, context.group, resolvedArgs);
          (0, _sideEffects.sendMsg)(context, oscMessage);

          return (0, _nodeWatcher.whenNodeGo)(context.server, context.id, nodeID).then(function () {
            (0, _nodeWatcher.updateNodeState)(context.server, nodeID, { synthDef: resolvedDefName });
            return nodeID;
          });
        });
      });
    });
  };
}

function group(children) {
  return function (parentContext) {
    return (0, _helpers.withContext)(parentContext, true).then(function (context) {

      var nodeID = (0, _sideEffects.nextNodeID)(context);
      var message = msg.groupNew(nodeID, msg.AddActions.TAIL, context.group);
      (0, _sideEffects.sendMsg)(context, message);
      return (0, _nodeWatcher.whenNodeGo)(context.server, context.id, nodeID).then(function () {
        return (0, _helpers.callAndResolveAll)(children, context);
      });
    });
  };
}

/**
 * Compile a SynthDef from a snippet of supercollider source code,
 * send it to the server and stores the SynthDesc in server.state
 *
 * @param {String} defName
 * @param {String} sourceCode - Supports SynthDef, {}, Instr and anything else that responds to .asSynthDef
 */
function compileSynthDef(defName, sourceCode) {
  var compiler = (0, _helpers.dryadic)(function (context) {
    // Better to use an isolated sclang so any Quarks won't try to mess with this Server
    var fullCode = '{\n      var def = SynthDef("' + defName + '", ' + sourceCode + ');\n      (\n        synthDesc: def.asSynthDesc.asJSON(),\n        bytes: def.asBytes()\n      )\n    }.value';

    return (0, _sideEffects.interpret)(context, fullCode).then(function (result) {
      putSynthDef(context, defName, result.synthDesc);
      return context.server.callAndResponse(msg.defRecv(new Buffer(result.bytes))).then(function () {
        return defName;
      });
    }, function (error) {
      return _bluebird.Promise.reject({
        description: 'Failed to compile SynthDef \'' + defName + '\'',
        error: error.error,
        sourceCode: sourceCode
      });
    });
  });
  return requireServer(requireInterpreter(compiler));
}

/**
 * store synthDefDesc in server state.
 *
 * This marks it as having been compiled and sent to server.
 */
function putSynthDef(context, defName, synthDesc) {
  context.server.state.mutate(StateKeys.SYNTH_DEFS, function (state) {
    return state.set(defName, synthDesc);
  });
}

/**
 * Spawns each item returned by an Rx.Observable stream.
 *
 * Each item returned by the stream should be a dryad
 * like synth, group etc. It will be spawned as a child of this `stream` dryad.
 *
 * @param {Rx.Observeable} streamable - a stream that pushes dryads to be spawned
 */
function stream(streamable) {
  return (0, _helpers.dryadic)(function (context) {
    var i = 0;
    streamable.subscribe(function (dryad) {
      (0, _helpers.callAndResolve)(dryad, context, String(i));
      i += 1;
    }, function (error) {
      console.error(error);
    }, function () {
      // free self
    });
    // on getting ended early (by parent being freed)
    // dispose subscription
  });
}

/**
 * Spawns each event in an Rx.Observeable stream
 *
 * {defName: "saw", args: {freq: 440}}
 */
function synthStream(streamable) {
  var params = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  return stream(streamable.map(function (event) {
    var args = _underscore2.default.assign({}, params, event.args);
    return synth(event.defName || params.defName, args);
  }));
}

/**
 * Boots a new supercollider interpreter making it available for all children
 * as `context.lang`.
 *
 * Ignores any possibly already existing one in context.
 */
function interpreter() {
  var children = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var defaultOptions = {
    stdin: false,
    echo: true, // that will make it post OSC send/recv
    debug: false
  };
  return (0, _helpers.dryadic)(function (context) {
    return (0, _sideEffects.bootLang)(_underscore2.default.defaults(options, defaultOptions)).then(function (lang) {
      return (0, _helpers.callAndResolveAll)(children, _underscore2.default.assign({}, context, { lang: lang }));
    });
  });
}

/**
 * Boots a supercollider interpreter if none is already available
 * in the context making it available for all children
 * as `context.lang`.
 */
function requireInterpreter(child) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  return (0, _helpers.dryadic)(function (context) {
    if (!context.lang) {
      return interpreter([child], options)(context).then(function (resolved) {
        return resolved[0];
      });
    }
    return (0, _helpers.callAndResolve)(child, context);
  });
}

/**
 * Boots a new supercollider server making it available for all children making it available for all children
 * as `context.server`.
 *
 * Always boots a new one, ignoring any possibly already existing one in context.
 */
function server() {
  var children = arguments.length <= 0 || arguments[0] === undefined ? [] : arguments[0];
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  var defaultOptions = {
    stdin: false,
    echo: true, // that will make it post OSC send/recv
    debug: false
  };
  return (0, _helpers.dryadic)(function (context) {
    return (0, _sideEffects.bootServer)(_underscore2.default.defaults(options, defaultOptions), context.store).then(function (s) {
      return (0, _helpers.callAndResolveAll)(children, _underscore2.default.assign({}, context, { server: s, group: 0 }));
    });
  });
}

/**
 * Boots a supercollider server if none is already available
 * in the context making it available for all children
 * as `context.server`.
 */
function requireServer(child) {
  var options = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];

  return (0, _helpers.dryadic)(function (context) {
    if (!context.server) {
      return server([child], options)(context).then(function (resolved) {
        return resolved[0];
      });
    }
    return (0, _helpers.callAndResolve)(child, context);
  });
}

// interpret
// interpretFile
// loadSynthDef(path, defName)
// buffer(secs, numChans)
// loadBuffer(path)
// include('jsmodule', 'funcname')
// exec
// fork
// streamFile
//# sourceMappingURL=dryads.js.map
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _rx = require('rx');

var _utils = require('../osc/utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
 * Owned by the Server, this is an object that you call .msg or .bundle on
 * to send OSC.
 *
 * The Server subscribes to this and does the actual sending.
 * You may also subscribe to this for debugging, logging or entertainment purposes.
 */
var SendOSC = function (_EventEmitter) {
  _inherits(SendOSC, _EventEmitter);

  function SendOSC() {
    _classCallCheck(this, SendOSC);

    return _possibleConstructorReturn(this, (SendOSC.__proto__ || Object.getPrototypeOf(SendOSC)).apply(this, arguments));
  }

  _createClass(SendOSC, [{
    key: 'msg',
    value: function msg(message) {
      this.emit('msg', (0, _utils.makeMessage)(message));
    }

    /**
    * bundle
    *
    * Note that in SuperCollider language a number is interpreted
    * as relative seconds from 'now'; here is is interpreted as a
    * unix timestamp. See deltaTimeTag
    *
    * @param {null|Number|Array|Date} time
    *   - null: now, immediately
    *   - Number: if less than 10000 then it is interpreted
    *       as number of seconds from now.
    *       It it is larger then it is interpreted as a unix timestamp in seconds
    *   - Array: `[secondsSince1900Jan1, fractionalSeconds]`
    *   - Date
    * @param {Array} packets - osc messages as `[address, arg1, ...argN]`
    *                        or sub bundles as `[{timeTag: , packets: }, ...]`
    */

  }, {
    key: 'bundle',
    value: function bundle(time, packets) {
      if (typeof time === 'number' && time < 10000) {
        time = (0, _utils.deltaTimeTag)(time);
      }
      this.emit('bundle', (0, _utils.makeBundle)(time, packets));
    }

    /**
     * Make NTP timetag array relative to the current time.
     *
     * @example:
     *
     *    server.send.bundle(server.send.deltaTimetag(1.0), [ ... msgs ]);
     *
     * @param {Number} delta
     * @param {Date} now - optional, default new Date
     */

  }, {
    key: 'deltaTimeTag',
    value: function deltaTimeTag(delta, now) {
      return (0, _utils.deltaTimeTag)(delta, now);
    }

    /**
     * Subscribe to monitor OSC messages and bundles sent.
     *
     * Events are: `{type: msg|bundle: payload: Array}`
     *
     * @returns {Rx.Disposable} - `thing.dispose();` to unsubscribe
     */

  }, {
    key: 'subscribe',
    value: function subscribe(onNext, onError, onComplete) {
      var msgs = _rx.Observable.fromEvent(this, 'msg', function (msg) {
        return {
          type: 'msg',
          payload: msg
        };
      });
      var bundles = _rx.Observable.fromEvent(this, 'bundle', function (bundle) {
        return {
          type: 'bundle',
          payload: bundle
        };
      });
      var combo = msgs.merge(bundles);
      return combo.subscribe(onNext, onError, onComplete);
    }
  }]);

  return SendOSC;
}(_events2.default);

exports.default = SendOSC;
//# sourceMappingURL=SendOSC.js.map
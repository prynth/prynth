{"version":3,"sources":["../../../src/server/internals/allocators.js"],"names":["increment","initialBlockState","allocBlock","freeBlock","reserveBlock","freeBlockList","Immutable","state","initial","next","initialSize","fromJS","blockSize","keys","keySeq","sortBy","a","b","parseInt","ret","forEach","size","sizeKey","blocks","get","last","set","butLast","lastBlock","splitFreeBlock","Error","addr","pushFreeBlock","mergeNeighbors","removed","update","String","blks","filter","x","enc","findEnclosingFreeBlock","NOT_FOUND","list","push","sort","found","freeBlockSize","blockEncloses","fblock","encBlock","encSize","popFreeBlock","List","splitAddr","splitSize","bottomGap","topGap","endAddr","resizeFreeBlock","newAddr","newSize","blockEnd","fb"],"mappings":";;;;;QAoBgBA,S,GAAAA,S;QAcAC,iB,GAAAA,iB;QAWAC,U,GAAAA,U;QA4CAC,S,GAAAA,S;QAkBAC,Y,GAAAA,Y;QA4BAC,a,GAAAA,a;;AAlIhB;;IAAYC,S;;;;AAKZ;;;;;;;;;;;;AAHA;AAaO,SAASN,SAAT,CACLO,KADK,EAGa;AAAA,MADlBC,OACkB,uEADA,CACA;;AAClB,MAAIC,OAAO,CAACF,SAASC,OAAV,IAAqB,CAAhC;AACA,SAAO,CAACC,IAAD,EAAOA,IAAP,CAAP;AACD;;AAED;;;;;;AA5BA;;;;;AAkCO,SAASR,iBAAT,CAA2BS,WAA3B,EAA8D;AACnE,SAAOP,UAAUG,UAAUK,MAAV,CAAiB,EAAjB,CAAV,EAAgC,CAAhC,EAAmCD,WAAnC,CAAP;AACD;;AAED;;;;;;;AAOO,SAASR,UAAT,CACLK,KADK,EAELK,SAFK,EAGmB;AACxB,MAAIC,OAAON,MAAMO,MAAN,GAAeC,MAAf,CAAsB,UAACC,CAAD,EAAIC,CAAJ;AAAA,WAAUC,SAASF,CAAT,EAAY,EAAZ,IAAkBE,SAASD,CAAT,EAAY,EAAZ,CAA5B;AAAA,GAAtB,CAAX;AACA,MAAIE,GAAJ;AACAN,OAAKO,OAAL,CAAa,mBAAW;AACtB,QAAIC,OAAOH,SAASI,OAAT,EAAkB,EAAlB,CAAX;AACA,QAAID,QAAQT,SAAZ,EAAuB;AACrB,UAAIW,SAAShB,MAAMiB,GAAN,CAAUF,OAAV,CAAb;AACA,UAAIC,UAAUA,OAAOF,IAArB,EAA2B;AACzB,YAAIA,SAAST,SAAb,EAAwB;AACtB;AACAO,gBAAM,CAACI,OAAOE,IAAP,EAAD,EAAgBlB,MAAMmB,GAAN,CAAUJ,OAAV,EAAmBC,OAAOI,OAAP,EAAnB,CAAhB,CAAN;AACA,iBAAO,KAAP,CAHsB,CAGR;AACf,SAJD,MAIO;AACL;AACA,cAAIC,YAAYL,OAAOE,IAAP,EAAhB;AACAN,gBAAM,CACJS,SADI,EAEJC,eAAetB,KAAf,EAAsBqB,SAAtB,EAAiCP,IAAjC,EAAuCO,SAAvC,EAAkDhB,SAAlD,CAFI,CAAN;AAIA,iBAAO,KAAP,CAPK,CAOS;AACf;AACF;AACF;AACF,GApBD;;AAsBA,MAAI,CAACO,GAAL,EAAU;AACR,UAAM,IAAIW,KAAJ,CAAU,eAAV,CAAN;AACD;AACD,SAAOX,GAAP;AACD;;AAED;;;;;;;;;;AAUO,SAAShB,SAAT,CACLI,KADK,EAELwB,IAFK,EAGLnB,SAHK,EAIL;AACAL,UAAQyB,cAAczB,KAAd,EAAqBwB,IAArB,EAA2BnB,SAA3B,CAAR;AACA,SAAOqB,eAAe1B,KAAf,EAAsBwB,IAAtB,EAA4BnB,SAA5B,CAAP;AACD;;AAED;;;;;;;;;AASO,SAASR,YAAT,CACLG,KADK,EAELwB,IAFK,EAGLnB,SAHK,EAIS;AACd;AACA,MAAIsB,UAAU3B,MAAM4B,MAAN,CACZC,OAAOxB,SAAP,CADY,EAEZ;AAAA,WAAQyB,OAAOA,KAAKC,MAAL,CAAY;AAAA,aAAKC,MAAMR,IAAX;AAAA,KAAZ,CAAP,GAAsCM,IAA9C;AAAA,GAFY,CAAd;AAIA,MAAIH,YAAY3B,KAAhB,EAAuB;AACrB,WAAO2B,OAAP;AACD;;AAED,MAAIM,MAAMC,uBAAuBlC,KAAvB,EAA8BwB,IAA9B,EAAoCnB,SAApC,CAAV;AACA,MAAI4B,QAAQE,SAAZ,EAAuB;AACrB,UAAMZ,MAAM,4BAAN,EAAoCC,IAApC,EAA0CnB,SAA1C,EAAqDL,KAArD,CAAN;AACD;;AAED,SAAOsB,eAAetB,KAAf,EAAsBiC,IAAI,CAAJ,CAAtB,EAA8BA,IAAI,CAAJ,CAA9B,EAAsCT,IAAtC,EAA4CnB,SAA5C,CAAP;AACD;;AAED;;;;;;AAMO,SAASP,aAAT,CAAuBE,KAAvB,EAA6D;AAClE,MAAIoC,OAAO,EAAX;AACApC,QAAMa,OAAN,CAAc,UAACiB,IAAD,EAAOf,OAAP,EAAmB;AAC/Be,SAAKjB,OAAL,CAAa,gBAAQ;AACnBuB,WAAKC,IAAL,CAAU,CAACb,IAAD,EAAOb,SAASI,OAAT,EAAkB,EAAlB,CAAP,CAAV;AACD,KAFD;AAGD,GAJD;AAKA;AACAqB,OAAKE,IAAL,CAAU,UAAC7B,CAAD,EAAIC,CAAJ;AAAA,WAAUD,EAAE,CAAF,IAAOC,EAAE,CAAF,CAAjB;AAAA,GAAV;AACA,SAAO0B,IAAP;AACD;;AAED;;AAEA,IAAMD,YAAY,CAAC,CAAC,CAAF,EAAK,CAAC,CAAN,CAAlB;;AAEA;;;;;;AAMA,SAASD,sBAAT,CACElC,KADF,EAEEwB,IAFF,EAGEnB,SAHF,EAIoB;AAClB;AACA,MAAIkC,QAAQJ,SAAZ;AACAnC,QAAMa,OAAN,CAAc,UAACiB,IAAD,EAAOf,OAAP,EAAmB;AAC/B,QAAIyB,gBAAgB7B,SAASI,OAAT,EAAkB,EAAlB,CAApB;AACAe,SAAKjB,OAAL,CAAa,kBAAU;AACrB,UAAI4B,cAAcjB,IAAd,EAAoBnB,SAApB,EAA+BqC,MAA/B,EAAuCF,aAAvC,CAAJ,EAA2D;AACzDD,gBAAQ,CAACG,MAAD,EAASF,aAAT,CAAR;AACA,eAAO,KAAP,CAFyD,CAE3C;AACf;AACF,KALD;AAMA,QAAID,UAAUJ,SAAd,EAAyB;AACvB,aAAO,KAAP,CADuB,CACT;AACf;AACF,GAXD;AAYA,SAAOI,KAAP;AACD;;AAED;;;;;;;;;AASA,SAASE,aAAT,CACEjB,IADF,EAEEV,IAFF,EAGE6B,QAHF,EAIEC,OAJF,EAKW;AACT,SAAOpB,QAAQmB,QAAR,IAAoBnB,OAAOV,IAAP,IAAe6B,WAAWC,OAArD;AACD;;AAED;;;;;;AAMA,SAASC,YAAT,CACE7C,KADF,EAEEwB,IAFF,EAGEnB,SAHF,EAIgB;AACd,SAAOL,MAAM4B,MAAN,CACLC,OAAOxB,SAAP,CADK,EAEL;AAAA,WAAQyB,OAAOA,KAAKC,MAAL,CAAY;AAAA,aAAKC,MAAMR,IAAX;AAAA,KAAZ,CAAP,GAAsCM,IAA9C;AAAA,GAFK,CAAP;AAID;;AAED;;;;;;AAMA,SAASL,aAAT,CACEzB,KADF,EAEEwB,IAFF,EAGEnB,SAHF,EAIgB;AACd,SAAOL,MAAM4B,MAAN,CAAaC,OAAOxB,SAAP,CAAb,EAAgC;AAAA,WACrC,CAACyB,QAAQ/B,UAAU+C,IAAV,EAAT,EAA2BT,IAA3B,CAAgCb,IAAhC,CADqC;AAAA,GAAhC,CAAP;AAED;;AAED;;;;;;;;;;;;;;;;;AAiBA,SAASF,cAAT,CACEtB,KADF,EAEEwB,IAFF,EAGEnB,SAHF,EAIE0C,SAJF,EAKEC,SALF,EAMgB;AACd,MAAIC,YAAYF,YAAYvB,IAA5B;AACA,MAAI0B,SAASC,QAAQ3B,IAAR,EAAcnB,SAAd,IAA2B8C,QAAQJ,SAAR,EAAmBC,SAAnB,CAAxC;AACA,MAAIC,YAAY,CAAZ,IAAiBC,WAAW,CAAhC,EAAmC;AACjC,WAAOE,gBAAgBpD,KAAhB,EAAuBwB,IAAvB,EAA6BnB,SAA7B,EAAwCmB,IAAxC,EAA8CyB,SAA9C,CAAP;AACD;AACD,MAAIC,SAAS,CAAT,IAAcD,cAAc,CAAhC,EAAmC;AACjC,WAAOG,gBACLpD,KADK,EAELwB,IAFK,EAGLnB,SAHK,EAIL8C,QAAQ3B,IAAR,EAAcnB,SAAd,IAA2B6C,MAJtB,EAKLA,MALK,CAAP;AAOD;AACD,MAAIA,SAAS,CAAT,IAAcD,YAAY,CAA9B,EAAiC;AAC/BjD,YAAQ6C,aAAa7C,KAAb,EAAoBwB,IAApB,EAA0BnB,SAA1B,CAAR;AACAL,YAAQyB,cAAczB,KAAd,EAAqBwB,IAArB,EAA2ByB,SAA3B,CAAR;AACAjD,YAAQyB,cAAczB,KAAd,EAAqBmD,QAAQ3B,IAAR,EAAcnB,SAAd,IAA2B6C,MAAhD,EAAwDA,MAAxD,CAAR;AACA,WAAOlD,KAAP;AACD;AACD,SAAOA,KAAP;AACD;;AAED,SAASoD,eAAT,CACEpD,KADF,EAEEwB,IAFF,EAGEnB,SAHF,EAIEgD,OAJF,EAKEC,OALF,EAMgB;AACdtD,UAAQ6C,aAAa7C,KAAb,EAAoBwB,IAApB,EAA0BnB,SAA1B,CAAR;AACAL,UAAQyB,cAAczB,KAAd,EAAqBqD,OAArB,EAA8BC,OAA9B,CAAR;AACA,SAAOtD,KAAP;AACD;;AAED,SAASmD,OAAT,CAAiB3B,IAAjB,EAA+BnB,SAA/B,EAA0D;AACxD,SAAOmB,OAAOnB,SAAd;AACD;;AAED,SAASqB,cAAT,CACE1B,KADF,EAEEwB,IAFF,EAGEnB,SAHF,EAIgB;AACd,MAAIkD,WAAWJ,QAAQ3B,IAAR,EAAcnB,SAAd,CAAf;AACAP,gBAAcE,KAAd,EAAqBa,OAArB,CAA6B,cAAM;AACjC,QAAIsC,QAAQK,GAAG,CAAH,CAAR,EAAeA,GAAG,CAAH,CAAf,MAA0BhC,IAA9B,EAAoC;AAClC;AACAxB,cAAQ6C,aAAa7C,KAAb,EAAoBwD,GAAG,CAAH,CAApB,EAA2BA,GAAG,CAAH,CAA3B,CAAR;AACAxD,cAAQ6C,aAAa7C,KAAb,EAAoBwB,IAApB,EAA0BnB,SAA1B,CAAR;AACA;AACAmB,aAAOgC,GAAG,CAAH,CAAP;AACAnD,kBAAYmD,GAAG,CAAH,IAAQnD,SAApB;AACAL,cAAQyB,cAAczB,KAAd,EAAqBwB,IAArB,EAA2BnB,SAA3B,CAAR;AACD;AACD;AACA;AACA,QAAImD,GAAG,CAAH,MAAUD,QAAd,EAAwB;AACtB;AACAvD,cAAQ6C,aAAa7C,KAAb,EAAoBwD,GAAG,CAAH,CAApB,EAA2BA,GAAG,CAAH,CAA3B,CAAR;AACAxD,cAAQ6C,aAAa7C,KAAb,EAAoBwB,IAApB,EAA0BnB,SAA1B,CAAR;AACAA,kBAAYA,YAAYmD,GAAG,CAAH,CAAxB;AACAxD,cAAQyB,cAAczB,KAAd,EAAqBwB,IAArB,EAA2BnB,SAA3B,CAAR;AACD;AACF,GAnBD;AAoBA,SAAOL,KAAP;AACD","file":"allocators.js","sourcesContent":["/**\n * @flow\n * @module allocators\n * @ private\n */\nimport * as Immutable from 'immutable';\n\n// immutable list of numbers\ntype BlockMapType = Immutable.Map<string, *>;\n\n/**\n * A simple incrementing allocator used for nodeIds.\n *\n * The return type is designed to be consistent with the block allocator\n * and other mutating functions used by Server\n *\n * @param {int} state\n * @param {int} initial\n * @returns {Array} [next {int}, state {int}]\n */\nexport function increment(\n  state: number,\n  initial: number = 0\n): [number, number] {\n  let next = (state || initial) + 1;\n  return [next, next];\n}\n\n/**\n * Create initial state for block allocator.\n *\n * @param {int} initialSize - eg. total numChannels\n * @returns {Immutable.Map} state\n */\nexport function initialBlockState(initialSize: number): BlockMapType {\n  return freeBlock(Immutable.fromJS({}), 0, initialSize);\n}\n\n/**\n * Allocates a contigious block of numbers.\n *\n * @param {Immutable.Map} state\n * @param {int} blockSize       - number of numbers eg. numChannels\n * @returns {Array}             - [start number {int}, mutated state {Immutable.Map}]\n */\nexport function allocBlock(\n  state: BlockMapType,\n  blockSize: number\n): [number, BlockMapType] {\n  let keys = state.keySeq().sortBy((a, b) => parseInt(a, 10) > parseInt(b, 10));\n  var ret;\n  keys.forEach(sizeKey => {\n    let size = parseInt(sizeKey, 10);\n    if (size >= blockSize) {\n      let blocks = state.get(sizeKey);\n      if (blocks && blocks.size) {\n        if (size === blockSize) {\n          // pop the last free one\n          ret = [blocks.last(), state.set(sizeKey, blocks.butLast())];\n          return false; // break\n        } else {\n          // its larger, split off what you need\n          let lastBlock = blocks.last();\n          ret = [\n            lastBlock,\n            splitFreeBlock(state, lastBlock, size, lastBlock, blockSize)\n          ];\n          return false; // break\n        }\n      }\n    }\n  });\n\n  if (!ret) {\n    throw new Error('No free block');\n  }\n  return ret;\n}\n\n/**\n * Return a previously allocated block back to the free list.\n *\n * Defragments by merging with adjoining neighbors where possible\n *\n * @param {Immutable.Map} state\n * @param {int} addr\n * @param {int} blockSize\n * @returns {Immutable.Map} state\n */\nexport function freeBlock(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number\n) {\n  state = pushFreeBlock(state, addr, blockSize);\n  return mergeNeighbors(state, addr, blockSize);\n}\n\n/**\n * Reserve a block by re-writing the free list\n *\n * @param {Immutable.Map} state\n * @param {int} addr\n * @param {int} blockSize\n * @returns {Immutable.Map} state\n * @throws - Block is already allocated\n */\nexport function reserveBlock(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number\n): BlockMapType {\n  // check if exact match is on free list\n  var removed = state.update(\n    String(blockSize),\n    blks => blks ? blks.filter(x => x !== addr) : blks\n  );\n  if (removed !== state) {\n    return removed;\n  }\n\n  var enc = findEnclosingFreeBlock(state, addr, blockSize);\n  if (enc === NOT_FOUND) {\n    throw Error('Block is already allocated', addr, blockSize, state);\n  }\n\n  return splitFreeBlock(state, enc[0], enc[1], addr, blockSize);\n}\n\n/**\n * Returns a list of the free blocks and their sizes.\n *\n * @param {Immutable.Map} state\n * @returns {Array} - [[addr, size], ...]\n */\nexport function freeBlockList(state: BlockMapType): Array<[number]> {\n  var list = [];\n  state.forEach((blks, sizeKey) => {\n    blks.forEach(addr => {\n      list.push([addr, parseInt(sizeKey, 10)]);\n    });\n  });\n  // sort by addr\n  list.sort((a, b) => a[0] - b[0]);\n  return list;\n}\n\n/************ private *****************************************/\n\nconst NOT_FOUND = [-1, -1];\n\n/**\n * @param {Immutable.Map} state\n * @param {int} addr\n * @param {int} blockSize\n * @returns {Array} - [blockAddr, blockSize] or NOT_FOUND\n */\nfunction findEnclosingFreeBlock(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number\n): [number, number] {\n  // let end = addr + blockSize;\n  var found = NOT_FOUND;\n  state.forEach((blks, sizeKey) => {\n    let freeBlockSize = parseInt(sizeKey, 10);\n    blks.forEach(fblock => {\n      if (blockEncloses(addr, blockSize, fblock, freeBlockSize)) {\n        found = [fblock, freeBlockSize];\n        return false; // break\n      }\n    });\n    if (found !== NOT_FOUND) {\n      return false; // break\n    }\n  });\n  return found;\n}\n\n/**\n * Tests if a block encloses another block\n *\n * @param {int} addr      - child block\n * @param {int} size\n * @param {int} encBlock - address of the potentially enclosing block being tested\n * @param {int} encSize  - size of the potentially enclosing block being tested\n * @returns {Boolean}\n */\nfunction blockEncloses(\n  addr: number,\n  size: number,\n  encBlock: number,\n  encSize: number\n): boolean {\n  return addr >= encBlock && addr + size <= encBlock + encSize;\n}\n\n/**\n * @param {Immutable.Map} state\n * @param {int} addr\n * @param {int} blockSize\n * @returns {Immutable.Map} state\n */\nfunction popFreeBlock(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number\n): BlockMapType {\n  return state.update(\n    String(blockSize),\n    blks => blks ? blks.filter(x => x !== addr) : blks\n  );\n}\n\n/**\n * @param {Immutable.Map} state\n * @param {int} addr\n * @param {int} blockSize\n * @returns {Immutable.Map} state\n */\nfunction pushFreeBlock(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number\n): BlockMapType {\n  return state.update(String(blockSize), blks =>\n    (blks || Immutable.List()).push(addr));\n}\n\n/**\n * Split a block into two or three parts.\n *\n * addr/blockSize is the original block that is currently in state.\n * splitAddr/splitSize is being removed from it (its being allocated)\n * and the original free block will be resized\n *\n * If splitAddr/splitSize is at the top or bottom edge then you get 2 parts.\n * If in the middle then you get 3.\n *\n * @param {Immutable.Map} state\n * @param {int} addr\n * @param {int} blockSize\n * @param {int} splitAddr\n * @param {int} splitSize\n * @returns {Immutable.Map} state\n */\nfunction splitFreeBlock(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number,\n  splitAddr: number,\n  splitSize: number\n): BlockMapType {\n  var bottomGap = splitAddr - addr;\n  var topGap = endAddr(addr, blockSize) - endAddr(splitAddr, splitSize);\n  if (bottomGap > 0 && topGap === 0) {\n    return resizeFreeBlock(state, addr, blockSize, addr, bottomGap);\n  }\n  if (topGap > 0 && bottomGap === 0) {\n    return resizeFreeBlock(\n      state,\n      addr,\n      blockSize,\n      endAddr(addr, blockSize) - topGap,\n      topGap\n    );\n  }\n  if (topGap > 0 && bottomGap > 0) {\n    state = popFreeBlock(state, addr, blockSize);\n    state = pushFreeBlock(state, addr, bottomGap);\n    state = pushFreeBlock(state, endAddr(addr, blockSize) - topGap, topGap);\n    return state;\n  }\n  return state;\n}\n\nfunction resizeFreeBlock(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number,\n  newAddr: number,\n  newSize: number\n): BlockMapType {\n  state = popFreeBlock(state, addr, blockSize);\n  state = pushFreeBlock(state, newAddr, newSize);\n  return state;\n}\n\nfunction endAddr(addr: number, blockSize: number): number {\n  return addr + blockSize;\n}\n\nfunction mergeNeighbors(\n  state: BlockMapType,\n  addr: number,\n  blockSize: number\n): BlockMapType {\n  var blockEnd = endAddr(addr, blockSize);\n  freeBlockList(state).forEach(fb => {\n    if (endAddr(fb[0], fb[1]) === addr) {\n      // lower neighbor\n      state = popFreeBlock(state, fb[0], fb[1]);\n      state = popFreeBlock(state, addr, blockSize);\n      // this is the new me\n      addr = fb[0];\n      blockSize = fb[1] + blockSize;\n      state = pushFreeBlock(state, addr, blockSize);\n    }\n    // my end addr is still in the same place\n    // even if block has been merged with lower neighbor\n    if (fb[0] === blockEnd) {\n      // upper neighbor\n      state = popFreeBlock(state, fb[0], fb[1]);\n      state = popFreeBlock(state, addr, blockSize);\n      blockSize = blockSize + fb[1];\n      state = pushFreeBlock(state, addr, blockSize);\n    }\n  });\n  return state;\n}\n"]}
{"version":3,"sources":["../../../src/server/internals/SendOSC.js"],"names":["SendOSC","message","emit","time","packets","delta","now","onNext","onError","onComplete","msgs","fromEvent","type","payload","msg","bundles","bundle","combo","merge","subscribe"],"mappings":";;;;;;;;AACA;;;;AACA;;AACA;;;;;;;;;;AAIA;;;;;;;IAOqBA,O;;;;;;;;;;;wBACfC,O,EAAkB;AACpB,WAAKC,IAAL,CAAU,KAAV,EAAiB,wBAAYD,OAAZ,CAAjB;AACD;;AAED;;;;;;;;;;;;;;;;;;;;2BAiBOE,I,EAAmBC,O,EAAoB;AAC5C,UAAI,OAAOD,IAAP,KAAgB,QAAhB,IAA4BA,OAAO,KAAvC,EAA8C;AAC5CA,eAAO,yBAAaA,IAAb,CAAP;AACD;AACD,WAAKD,IAAL,CAAU,QAAV,EAAoB,uBAAWC,IAAX,EAAiBC,OAAjB,CAApB;AACD;;AAED;;;;;;;;;;;;;iCAUaC,K,EAAeC,G,EAAsB;AAChD,aAAO,yBAAaD,KAAb,EAAoBC,GAApB,CAAP;AACD;;AAED;;;;;;;;;;8BAQEC,M,EACAC,O,EACAC,U,EACY;AACZ,UAAIC,OAAO,eAAWC,SAAX,CAAqB,IAArB,EAA2B,KAA3B,EAAkC,eAAO;AAClD,eAAO;AACLC,gBAAM,KADD;AAELC,mBAASC;AAFJ,SAAP;AAID,OALU,CAAX;AAMA,UAAIC,UAAU,eAAWJ,SAAX,CAAqB,IAArB,EAA2B,QAA3B,EAAqC,kBAAU;AAC3D,eAAO;AACLC,gBAAM,QADD;AAELC,mBAASG;AAFJ,SAAP;AAID,OALa,CAAd;AAMA,UAAIC,QAAQP,KAAKQ,KAAL,CAAWH,OAAX,CAAZ;AACA,aAAOE,MAAME,SAAN,CAAgBZ,MAAhB,EAAwBC,OAAxB,EAAiCC,UAAjC,CAAP;AACD;;;;;;kBArEkBT,O","file":"SendOSC.js","sourcesContent":["/* @flow */\nimport EventEmitter from 'events';\nimport { Observable } from 'rx';\nimport { makeBundle, makeMessage, deltaTimeTag } from '../osc/utils';\nimport type { MsgType, OSCTimeType } from '../../Types';\nimport type { Disposable } from 'Rx';\n\n/**\n * Owned by the Server, this is an object that you call .msg or .bundle on\n * to send OSC.\n *\n * The Server subscribes to this and does the actual sending.\n * You may also subscribe to this for debugging, logging or entertainment purposes.\n */\nexport default class SendOSC extends EventEmitter {\n  msg(message: MsgType) {\n    this.emit('msg', makeMessage(message));\n  }\n\n  /**\n  * bundle\n  *\n  * Note that in SuperCollider language a number is interpreted\n  * as relative seconds from 'now'; here is is interpreted as a\n  * unix timestamp. See deltaTimeTag\n  *\n  * @param {null|Number|Array|Date} time\n  *   - null: now, immediately\n  *   - Number: if less than 10000 then it is interpreted\n  *       as number of seconds from now.\n  *       It it is larger then it is interpreted as a unix timestamp in seconds\n  *   - Array: `[secondsSince1900Jan1, fractionalSeconds]`\n  *   - Date\n  * @param {Array} packets - osc messages as `[address, arg1, ...argN]`\n  *                        or sub bundles as `[{timeTag: , packets: }, ...]`\n  */\n  bundle(time: OSCTimeType, packets: [MsgType]) {\n    if (typeof time === 'number' && time < 10000) {\n      time = deltaTimeTag(time);\n    }\n    this.emit('bundle', makeBundle(time, packets));\n  }\n\n  /**\n   * Make NTP timetag array relative to the current time.\n   *\n   * @example:\n   *\n   *    server.send.bundle(server.send.deltaTimetag(1.0), [ ... msgs ]);\n   *\n   * @param {Number} delta\n   * @param {Date} now - optional, default new Date\n   */\n  deltaTimeTag(delta: number, now: ?Date): [number] {\n    return deltaTimeTag(delta, now);\n  }\n\n  /**\n   * Subscribe to monitor OSC messages and bundles sent.\n   *\n   * Events are: `{type: msg|bundle: payload: Array}`\n   *\n   * @returns {Rx.Disposable} - `thing.dispose();` to unsubscribe\n   */\n  subscribe(\n    onNext: Function,\n    onError: ?Function,\n    onComplete: ?Function\n  ): Disposable {\n    var msgs = Observable.fromEvent(this, 'msg', msg => {\n      return {\n        type: 'msg',\n        payload: msg\n      };\n    });\n    var bundles = Observable.fromEvent(this, 'bundle', bundle => {\n      return {\n        type: 'bundle',\n        payload: bundle\n      };\n    });\n    var combo = msgs.merge(bundles);\n    return combo.subscribe(onNext, onError, onComplete);\n  }\n}\n"]}
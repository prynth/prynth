{"version":3,"sources":["../../src/server/ServerState.js"],"names":["Immutable","alloc","StateKeys","SERVERS","NODE_IDS","CONTROL_BUSSES","AUDIO_BUSSES","BUFFERS","ServerState","server","store","resetState","mutateState","_keys","options","numAudioChannels","numPrivateAudioBusChannels","numInputBusChannels","numOutputBusChannels","ab","initialBlockState","reserveBlock","cb","numControlBusChannels","bb","numBuffers","Map","initialNodeID","key","fn","keys","notSetValue","getIn","mutateStateAndReturn","increment","numChannels","_allocBlock","index","_freeBlock","numConsecutive","allocBlock","state","mutate","freeBlock","more","address","concat"],"mappings":"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","file":"ServerState.js","sourcesContent":["/**\n * @flow\n */\n\nimport * as Immutable from 'immutable';\nimport Store from './internals/Store';\nimport * as alloc from './internals/allocators';\nimport { watchNodeNotifications } from './node-watcher';\nimport type Server from './server';\n\nconst StateKeys = {\n  SERVERS: 'SERVERS',\n  NODE_IDS: 'nodeAllocator',\n  CONTROL_BUSSES: 'controlBusAllocator',\n  AUDIO_BUSSES: 'audioBusAllocator',\n  BUFFERS: 'bufferAllocator'\n};\n\n/**\n * Holds state for a Server such as node/bus/buffer allocators,\n * node status and SynthDefs compiled.\n *\n * Server has this has as the property: server.state\n *\n * Many of these functions are low-level accessors and allocators\n * useful for building higher-level applications that are easier\n * to use.\n *\n * Each server is stored by its unique address,\n * so multiple Servers can store state in the same\n * global Store object.\n */\nexport default class ServerState {\n  server: Server;\n  store: Store;\n\n  /**\n   * @param {Server} server\n   * @param {Store} store - optional parent Store to use.\n   */\n  constructor(server: Server, store: Store) {\n    this.server = server;\n    this.store = store ? store : new Store();\n    this.resetState();\n    watchNodeNotifications(this.server);\n  }\n\n  resetState() {\n    this.store.mutateState(this._keys([]), () => {\n      const options = this.server.options;\n      var numAudioChannels = options.numPrivateAudioBusChannels +\n        options.numInputBusChannels +\n        options.numOutputBusChannels;\n\n      var ab = alloc.initialBlockState(numAudioChannels);\n      ab = alloc.reserveBlock(\n        ab,\n        0,\n        options.numInputBusChannels + options.numOutputBusChannels\n      );\n      var cb = alloc.initialBlockState(options.numControlBusChannels);\n      var bb = alloc.initialBlockState(options.numBuffers);\n\n      return Immutable.Map({\n        [StateKeys.NODE_IDS]: options.initialNodeID - 1,\n        [StateKeys.AUDIO_BUSSES]: ab,\n        [StateKeys.CONTROL_BUSSES]: cb,\n        [StateKeys.BUFFERS]: bb\n      });\n    });\n  }\n\n  /**\n   * Mutate a value or object in the server state.\n   *\n   * @param {String} key - top level key eg. nodeAllocator, controlBufAllocator\n   * @param {Function} fn - will receive current state or an empty Map, returns the altered state.\n   */\n  mutate(key: string, fn: Function) {\n    this.store.mutateState(this._keys([key]), fn);\n  }\n\n  /**\n   * Get current state value for the server using an array of keys.\n   *\n   * @param {String} keys - list of keys eg. `['NODE_WATCHER', 'n_go', 1000]`\n   * @param {any} notSetValue - default value to return if empty\n   * @returns {any}\n   */\n  getIn(keys: [string], notSetValue: any): any {\n    return this.store.getIn(this._keys(keys), notSetValue);\n  }\n\n  /**\n   * Allocates a node ID to be used for making a synth or group\n   *\n   * @returns {int}\n   */\n  nextNodeID(): number {\n    return this.store.mutateStateAndReturn(\n      this._keys([StateKeys.NODE_IDS]),\n      alloc.increment\n    );\n  }\n\n  /**\n   * Allocate an audio bus.\n   *\n   * @returns {int} bus number\n   */\n  allocAudioBus(numChannels: number = 1): number {\n    return this._allocBlock(StateKeys.AUDIO_BUSSES, numChannels);\n  }\n\n  /**\n   * Allocate a control bus.\n   *\n   * @returns {int} bus number\n   */\n  allocControlBus(numChannels: number = 1): number {\n    return this._allocBlock(StateKeys.CONTROL_BUSSES, numChannels);\n  }\n\n  /**\n   * Free a previously allocate audio bus\n   *\n   * These require you to remember the channels and it messes it up\n   * if you free it wrong. will change to higher level storage.\n   *\n   * @param {int} index\n   * @param {int} numChannels\n   */\n  freeAudioBus(index: number, numChannels: number) {\n    this._freeBlock(StateKeys.AUDIO_BUSSES, index, numChannels);\n  }\n\n  /**\n   * Free a previously allocated control bus\n   *\n   * These require you to remember the channels and it messes it up\n   * if you free it wrong. will change to higher level storage.\n   *\n   * @param {int} index\n   * @param {int} numChannels\n   */\n  freeControlBus(index: number, numChannels: number) {\n    this._freeBlock(StateKeys.CONTROL_BUSSES, index, numChannels);\n  }\n\n  /**\n   * Allocate a buffer id.\n   *\n   * Note that numChannels is specified when creating the buffer.\n   * This allocator makes sure that the neighboring buffers are empty.\n   *\n   * @param {int} numConsecutive - consecutively numbered buffers are needed by VOsc and VOsc3.\n   * @returns {int} - buffer id\n   */\n  allocBufferID(numConsecutive: number = 1): number {\n    return this._allocBlock(StateKeys.BUFFERS, numConsecutive);\n  }\n\n  /**\n   * Free a previously allocated buffer id.\n   *\n   * Note that numChannels is specified when creating the buffer.\n   *\n   * @param {int} index\n   * @param {int} numConsecutive - consecutively numbered buffers are needed by VOsc and VOsc3.\n   */\n  freeBuffer(index: number, numConsecutive: number) {\n    this._freeBlock(StateKeys.BUFFERS, index, numConsecutive);\n  }\n\n  _allocBlock(key: string, numChannels: number): number {\n    return this.store.mutateStateAndReturn(this._keys([key]), state =>\n      alloc.allocBlock(state, numChannels));\n  }\n\n  _freeBlock(key: string, index: number, numChannels: number) {\n    this.mutate(key, state => alloc.freeBlock(state, index, numChannels));\n  }\n\n  _keys(more: Array<string> = []): [string] {\n    return [StateKeys.SERVERS, this.server.address].concat(more);\n  }\n}\n"]}
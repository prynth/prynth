'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _immutable = require('immutable');

var Immutable = _interopRequireWildcard(_immutable);

var _Store = require('./internals/Store');

var _Store2 = _interopRequireDefault(_Store);

var _allocators = require('./internals/allocators');

var alloc = _interopRequireWildcard(_allocators);

var _nodeWatcher = require('./node-watcher');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var StateKeys = {
  SERVERS: 'SERVERS',
  NODE_IDS: 'nodeAllocator',
  CONTROL_BUSSES: 'controlBusAllocator',
  AUDIO_BUSSES: 'audioBusAllocator',
  BUFFERS: 'bufferAllocator'
};

/**
 * Holds state for a Server such as node/bus/buffer allocators,
 * node status and SynthDefs compiled.
 *
 * Server has this has as the property: server.state
 *
 * Many of these functions are low-level accessors and allocators
 * useful for building higher-level applications that are easier
 * to use.
 *
 * Each server is stored by its unique address,
 * so multiple Servers can store state in the same
 * global Store object.
 */

var ServerState = function () {

  /**
   * @param {Server} server
   * @param {Store} store - optional parent Store to use.
   */
  function ServerState(server, store) {
    _classCallCheck(this, ServerState);

    this.server = server;
    this.store = store ? store : new _Store2.default();
    this.resetState();
    (0, _nodeWatcher.watchNodeNotifications)(this.server);
  }

  _createClass(ServerState, [{
    key: 'resetState',
    value: function resetState() {
      var _this = this;

      this.store.mutateState(this._keys([]), function () {
        var _Immutable$Map;

        var options = _this.server.options;
        var numAudioChannels = options.numPrivateAudioBusChannels + options.numInputBusChannels + options.numOutputBusChannels;

        var ab = alloc.initialBlockState(numAudioChannels);
        ab = alloc.reserveBlock(ab, 0, options.numInputBusChannels + options.numOutputBusChannels);
        var cb = alloc.initialBlockState(options.numControlBusChannels);
        var bb = alloc.initialBlockState(options.numBuffers);

        return Immutable.Map((_Immutable$Map = {}, _defineProperty(_Immutable$Map, StateKeys.NODE_IDS, options.initialNodeID - 1), _defineProperty(_Immutable$Map, StateKeys.AUDIO_BUSSES, ab), _defineProperty(_Immutable$Map, StateKeys.CONTROL_BUSSES, cb), _defineProperty(_Immutable$Map, StateKeys.BUFFERS, bb), _Immutable$Map));
      });
    }

    /**
     * Mutate a value or object in the server state.
     *
     * @param {String} key - top level key eg. nodeAllocator, controlBufAllocator
     * @param {Function} fn - will receive current state or an empty Map, returns the altered state.
     */

  }, {
    key: 'mutate',
    value: function mutate(key, fn) {
      this.store.mutateState(this._keys([key]), fn);
    }

    /**
     * Get current state value for the server using an array of keys.
     *
     * @param {String} keys - list of keys eg. `['NODE_WATCHER', 'n_go', 1000]`
     * @param {any} notSetValue - default value to return if empty
     * @returns {any}
     */

  }, {
    key: 'getIn',
    value: function getIn(keys, notSetValue) {
      return this.store.getIn(this._keys(keys), notSetValue);
    }

    /**
     * Allocates a node ID to be used for making a synth or group
     *
     * @returns {int}
     */

  }, {
    key: 'nextNodeID',
    value: function nextNodeID() {
      return this.store.mutateStateAndReturn(this._keys([StateKeys.NODE_IDS]), alloc.increment);
    }

    /**
     * Allocate an audio bus.
     *
     * @returns {int} bus number
     */

  }, {
    key: 'allocAudioBus',
    value: function allocAudioBus() {
      var numChannels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this._allocBlock(StateKeys.AUDIO_BUSSES, numChannels);
    }

    /**
     * Allocate a control bus.
     *
     * @returns {int} bus number
     */

  }, {
    key: 'allocControlBus',
    value: function allocControlBus() {
      var numChannels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this._allocBlock(StateKeys.CONTROL_BUSSES, numChannels);
    }

    /**
     * Free a previously allocate audio bus
     *
     * These require you to remember the channels and it messes it up
     * if you free it wrong. will change to higher level storage.
     *
     * @param {int} index
     * @param {int} numChannels
     */

  }, {
    key: 'freeAudioBus',
    value: function freeAudioBus(index, numChannels) {
      this._freeBlock(StateKeys.AUDIO_BUSSES, index, numChannels);
    }

    /**
     * Free a previously allocated control bus
     *
     * These require you to remember the channels and it messes it up
     * if you free it wrong. will change to higher level storage.
     *
     * @param {int} index
     * @param {int} numChannels
     */

  }, {
    key: 'freeControlBus',
    value: function freeControlBus(index, numChannels) {
      this._freeBlock(StateKeys.CONTROL_BUSSES, index, numChannels);
    }

    /**
     * Allocate a buffer id.
     *
     * Note that numChannels is specified when creating the buffer.
     * This allocator makes sure that the neighboring buffers are empty.
     *
     * @param {int} numConsecutive - consecutively numbered buffers are needed by VOsc and VOsc3.
     * @returns {int} - buffer id
     */

  }, {
    key: 'allocBufferID',
    value: function allocBufferID() {
      var numConsecutive = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      return this._allocBlock(StateKeys.BUFFERS, numConsecutive);
    }

    /**
     * Free a previously allocated buffer id.
     *
     * Note that numChannels is specified when creating the buffer.
     *
     * @param {int} index
     * @param {int} numConsecutive - consecutively numbered buffers are needed by VOsc and VOsc3.
     */

  }, {
    key: 'freeBuffer',
    value: function freeBuffer(index, numConsecutive) {
      this._freeBlock(StateKeys.BUFFERS, index, numConsecutive);
    }
  }, {
    key: '_allocBlock',
    value: function _allocBlock(key, numChannels) {
      return this.store.mutateStateAndReturn(this._keys([key]), function (state) {
        return alloc.allocBlock(state, numChannels);
      });
    }
  }, {
    key: '_freeBlock',
    value: function _freeBlock(key, index, numChannels) {
      this.mutate(key, function (state) {
        return alloc.freeBlock(state, index, numChannels);
      });
    }
  }, {
    key: '_keys',
    value: function _keys() {
      var more = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

      return [StateKeys.SERVERS, this.server.address].concat(more);
    }
  }]);

  return ServerState;
}();

exports.default = ServerState;
//# sourceMappingURL=ServerState.js.map
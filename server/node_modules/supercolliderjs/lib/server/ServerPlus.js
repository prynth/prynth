'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }(); /**
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * 
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * This is a sketch to make resource creation and management easier.
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      *
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      * status: ALPHA
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      */


exports.boot = boot;

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _server = require('./server');

var _server2 = _interopRequireDefault(_server);

var _msg = require('./osc/msg');

var msg = _interopRequireWildcard(_msg);

var _nodeWatcher = require('./node-watcher');

var _SynthDefCompiler = require('../lang/SynthDefCompiler');

var _SynthDefCompiler2 = _interopRequireDefault(_SynthDefCompiler);

var _resolveOptions = require('../utils/resolveOptions');

var _resolveOptions2 = _interopRequireDefault(_resolveOptions);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * scsynth Group
 *
 * See `server.group(...)`
 */
var Group = function () {
  function Group(server, id) {
    _classCallCheck(this, Group);

    this.id = id;
    this.server = server;
  }

  /**
   * Stop the Group and remove it from the play graph on the server.
   */


  _createClass(Group, [{
    key: 'free',
    value: function free() {
      this.server.send.msg(msg.nodeFree(this.id));
      return (0, _nodeWatcher.whenNodeEnd)(this.server, String(this.id), this.id);
    }

    /**
     * Update control parameters on the Synth.
     *
     * @example
     * ```js
     * synth.set({freq: 441, amp: 0.9});
     * ```
     *
     * This method works for Group and Synth.
     * For a Group it sends the set message to all children Synths
     * in the Group.
     */

  }, {
    key: 'set',
    value: function set(settings) {
      this.server.send.msg(msg.nodeSet(this.id, settings));
    }
    // moveAfter
    // moveBefore
    // onEnd
    // run
    // trace

  }]);

  return Group;
}();

/**
 * scsynth Synth
 *
 * See `server.synth(...)`
 */


var Synth = function (_Group) {
  _inherits(Synth, _Group);

  function Synth() {
    _classCallCheck(this, Synth);

    return _possibleConstructorReturn(this, (Synth.__proto__ || Object.getPrototypeOf(Synth)).apply(this, arguments));
  }

  return Synth;
}(Group);

/**
 * scsynth audio bus

 * See `server.audioBus(...)`
 *
 * These bus numbers (ids) and numChannels are allocated here in the client.
 * The server only gets bus ids for reading and writing to.
 */
var AudioBus = function () {
  function AudioBus(server, id, numChannels) {
    _classCallCheck(this, AudioBus);

    this.server = server;
    this.id = id;
    this.numChannels = numChannels;
  }

  /**
   * Deallocate the AudioBus, freeing it for resuse.
   */


  _createClass(AudioBus, [{
    key: 'free',
    value: function free() {
      this.server.state.freeAudioBus(this.id, this.numChannels);
    }
  }]);

  return AudioBus;
}();

/**
 * scsynth control bus

 * See `server.controlBus(...)`
 *
 * These bus numbers (ids) and numChannels are allocated here in the client.
 * The server only gets bus ids for reading and writing to.
 */


var ControlBus = function (_AudioBus) {
  _inherits(ControlBus, _AudioBus);

  function ControlBus() {
    _classCallCheck(this, ControlBus);

    return _possibleConstructorReturn(this, (ControlBus.__proto__ || Object.getPrototypeOf(ControlBus)).apply(this, arguments));
  }

  _createClass(ControlBus, [{
    key: 'free',

    /**
     * Deallocate the ControlBus, freeing it for resuse.
     */
    value: function free() {
      this.server.state.freeControlBus(this.id, this.numChannels);
    }
    // set
    // fill
    // get

  }]);

  return ControlBus;
}(AudioBus);

/**
 * scsynth Buffer
 *
 * See `server.buffer(...)` and `server.readBuffer(...)`
 */


var Buffer = function () {
  function Buffer(server, id, numFrames, numChannels) {
    _classCallCheck(this, Buffer);

    this.server = server;
    this.id = id;
    this.numFrames = numFrames;
    this.numChannels = numChannels;
  }

  /**
   * Deallocate the Buffer, freeing memory on the server.
   */


  _createClass(Buffer, [{
    key: 'free',
    value: function free() {
      var _this3 = this;

      return this.server.callAndResponse(msg.bufferFree(this.id)).then(function () {
        _this3.server.state.freeBuffer(_this3.id, _this3.numChannels);
      });
    }

    // read
    // write
    // zero
    // set frames
    // fill
    // gen
    // close
    // query
    // get

  }]);

  return Buffer;
}();

/**
 * scsynth SynthDef
 *
 * See `server.synthDefs(...)`
 *
 * These are currently compiled using sclang,
 * and the synthDefResult holds metadata about the compiled
 * synthdef and the raw compiled bytes.
 *
 * The SynthDef may have been compiled from a sourceCode string
 * or compiled from a file at path.
 */


var SynthDef = function SynthDef(server, defName, synthDefResult, sourceCode, path) {
  _classCallCheck(this, SynthDef);

  this.server = server;
  this.name = defName;
  this.synthDefResult = synthDefResult;
  this.sourceCode = sourceCode;
  this.path = path;
  // SynthDefCompiler will watch the path
}

// free
// setSource
// get info about def
;

/**
 * This extends Server with convienient methods for creating Synth, Group, compiling SynthDefs, creating Buses, Buffers etc.
 *
 * All methods return Promises, and all arguments accept Promises.
 * This means that async actions (like starting a sclang interpreter,
 * compiling SynthDefs and sending them to the server) are complete and their results
 * are ready to be used by whatever they have been supplied to.
 */


var ServerPlus = function (_Server) {
  _inherits(ServerPlus, _Server);

  function ServerPlus() {
    _classCallCheck(this, ServerPlus);

    return _possibleConstructorReturn(this, (ServerPlus.__proto__ || Object.getPrototypeOf(ServerPlus)).apply(this, arguments));
  }

  _createClass(ServerPlus, [{
    key: 'synth',


    /**
     * Create a Synth on the server
     */
    value: function synth(synthDef) {
      var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var _this5 = this;

      var group = arguments[2];
      var addAction = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : msg.AddActions.TAIL;

      return Promise.all([Promise.resolve(synthDef), Promise.resolve(group)]).then(function (_ref) {
        var _ref2 = _slicedToArray(_ref, 2),
            def = _ref2[0],
            g = _ref2[1];

        var nodeId = _this5.state.nextNodeID();
        var sn = msg.synthNew(def.name, nodeId, addAction, g ? g.id : 0, args);
        _this5.send.msg(sn);
        // unique string for callback registration
        return (0, _nodeWatcher.whenNodeGo)(_this5, String(nodeId), nodeId).then(function () {
          return new Synth(_this5, nodeId);
        });
      });
    }

    // grainSynth with no id

    /**
     * Create a Group on the server
     */

    /**
     * @private
     */

  }, {
    key: 'group',
    value: function group(_group) {
      var _this6 = this;

      var addAction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : msg.AddActions.TAIL;

      return Promise.resolve(_group).then(function (g) {
        var nodeId = _this6.state.nextNodeID();
        var sn = msg.groupNew(nodeId, addAction, g ? g.id : 0);
        _this6.send.msg(sn);
        // unique string for callback registration
        return (0, _nodeWatcher.whenNodeGo)(_this6, String(nodeId), nodeId).then(function () {
          return new Group(_this6, nodeId);
        });
      });
    }

    /**
     * @private
     */

  }, {
    key: 'synthDefs',


    /**
     * Compile multiple SynthDefs either from source or path.
     * If you have more than one to compile then always use this
     * as calling `server.synthDef` multiple times will start up
     * multiple supercollider interpreters. This is harmless, but
     * you do have a lot of icons bouncing in your dock.
     *
     * @param defs - An object with `{defName: spec, ...}` where spec is
     *               an object like `{source: "SynthDef('noise', { ...})"}`
     *               or `{path: "./noise.scd"}`
     * @returns An object with the synthDef names as keys and Promises as values.
     *                    Each Promise will resolve with a SynthDef.
     *                    Each Promises can be supplied directly to `server.synth()`
     */
    value: function synthDefs(defs) {
      var _this7 = this;

      var compile = this.synthDefCompiler.boot().then(function () {
        return _this7.synthDefCompiler.compileAndSend(defs, _this7);
      });

      return _lodash2.default.mapValues(defs, function (requested, name) {
        return new Promise(function (resolve, reject) {
          return compile.then(function (defsMap) {
            var result = defsMap[name];
            if (!result) {
              return reject(new Error(name + ' not found in compiled SynthDefs'));
            }
            if (result.name !== name) {
              return reject(new Error('SynthDef compiled as ' + result.name + ' but server.synthDefs was called with: ' + name));
            }
            resolve(new SynthDef(_this7, result.name, result, result.synthDesc.sourceCode, requested && requested.path));
          });
        });
      });
    }

    /**
     * @private
     */

  }, {
    key: '_compileSynthDef',
    value: function _compileSynthDef(defName, sourceCode, path) {
      var _this8 = this;

      return this.synthDefCompiler.boot().then(function () {
        return _this8.synthDefCompiler.compileAndSend(_defineProperty({}, defName, sourceCode ? { source: sourceCode } : { path: path }), _this8).then(function (defs) {
          // what if defName does not match synthDefResult.name ?
          var synthDefResult = defs[defName];
          if (!synthDefResult) {
            throw new Error('SynthDefResult not found ' + defName + ' in compile return values');
          }
          return new SynthDef(_this8, defName, synthDefResult, sourceCode, path);
        });
      });
    }

    /**
     * Load and compile a SynthDef from path and send it to the server.
     */

  }, {
    key: 'loadSynthDef',
    value: function loadSynthDef(defName, path) {
      return this._compileSynthDef(defName, null, path);
    }

    /**
     * Compile a SynthDef from supercollider source code and send it to the server.
     */

  }, {
    key: 'synthDef',
    value: function synthDef(defName, sourceCode) {
      return this._compileSynthDef(defName, sourceCode);
    }

    /**
     * Allocate a Buffer on the server.
     */

  }, {
    key: 'buffer',
    value: function buffer(numFrames) {
      var _this9 = this;

      var numChannels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;

      var id = this.state.allocBufferID(numChannels);
      return this.callAndResponse(msg.bufferAlloc(id, numFrames, numChannels)).then(function () {
        return new Buffer(_this9, id, numFrames, numChannels);
      });
    }

    /**
     * Allocate a Buffer on the server and load a sound file into it.
     *
     * Problem: scsynth uses however many channels there are in the sound file,
     * but the client (sclang or supercolliderjs) doesn't know how many there are.
     */

  }, {
    key: 'readBuffer',
    value: function readBuffer(path) {
      var numChannels = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;

      var _this10 = this;

      var startFrame = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var numFramesToRead = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : -1;

      var id = this.state.allocBufferID(numChannels);
      return this.callAndResponse(msg.bufferAllocRead(id, path, startFrame, numFramesToRead)).then(function () {
        return new Buffer(_this10, id, numFramesToRead, numChannels);
      });
    }

    /**
     * Allocate an audio bus.
     */

  }, {
    key: 'audioBus',
    value: function audioBus() {
      var numChannels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var id = this.state.allocAudioBus(numChannels);
      return new AudioBus(this, id, numChannels);
    }

    /**
     * Allocate a control bus.
     */

  }, {
    key: 'controlBus',
    value: function controlBus() {
      var numChannels = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;

      var id = this.state.allocControlBus(numChannels);
      return new ControlBus(this, id, numChannels);
    }
  }, {
    key: 'synthDefCompiler',
    get: function get() {
      if (!this._synthDefCompiler) {
        this._synthDefCompiler = new _SynthDefCompiler2.default();
      }
      return this._synthDefCompiler;
    }
  }]);

  return ServerPlus;
}(_server2.default);

/**
 * Start the scsynth server with options:
 *
 * ```js
 *   sc.server.boot({device: 'Soundflower (2ch)'}).then(server => {
 *     //
 *   });
 *
 *   sc.server.boot({serverPort: '11211'})
 * ```
 *
 * @memberof server
 *
 * @param {Object} options - Optional command line options for server
 * @param {Store} store - optional external Store to hold Server state
 * @returns {Promise} - resolves with a Server (ServerPlus actually)
 */


exports.default = ServerPlus;
function boot() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  return (0, _resolveOptions2.default)(undefined, options).then(function (opts) {
    var s = new ServerPlus(opts, store);
    return s.boot().then(function () {
      return s.connect();
    }).then(function () {
      return s;
    });
  });
}
//# sourceMappingURL=ServerPlus.js.map
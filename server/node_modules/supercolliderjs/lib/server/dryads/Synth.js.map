{"version":3,"sources":["../../../src/server/dryads/Synth.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;IAIa,KAAK,WAAL,KAAK;YAAL,KAAK;;;;;;;;;;;AAUhB,WAVW,KAAK,CAUJ,YAAY,EAAW;QAAT,IAAI,yDAAC,EAAE;;0BAVtB,KAAK;;uEAAL,KAAK;;AAYd,UAAK,UAAU,GAAG;AAChB,kBAAY,EAAE,YAAY;AAC1B,UAAI,EAAE,IAAI;KACX,CAAC;;GACH;;eAhBU,KAAK;;yCAkBK;;;;AAInB,aAAO;AACL,eAAO,EAAE,IAAI,CAAC,UAAU,CAAC,YAAY;AACrC,YAAI,EAAE,IAAI,CAAC,UAAU,CAAC,IAAI;AAAA,OAC3B,CAAC;KACH;;;0BAEK,OAAO,EAAE,QAAQ,EAAE;;;AAGvB,UAAM,MAAM,GAAG,UAAU,CAAC,OAAO,CAAC,CAAC;AACnC,aAAO,CAAC,MAAM,GAAG,MAAM,CAAC;AACxB,UAAM,UAAU,GAAG,GAAG,CAAC,QAAQ,CAAC,QAAQ,CAAC,OAAO,EAAE,MAAM,EAAE,GAAG,CAAC,UAAU,CAAC,IAAI,EAAE,OAAO,CAAC,KAAK,EAAE,QAAQ,CAAC,IAAI,CAAC,CAAC;AAC7G,aAAO,CAAC,OAAO,EAAE,UAAU,CAAC;;;AAAC,AAG7B,aAAO,UAAU,CAAC,OAAO,CAAC,MAAM,EAAE,OAAO,CAAC,EAAE,EAAE,MAAM,CAAC,CAClD,IAAI,CAAC,UAAC,MAAM,EAAK;AAChB,uBAAe,CAAC,OAAO,CAAC,MAAM,EAAE,MAAM,EAAE,EAAC,QAAQ,EAAE,eAAe,EAAC,CAAC,CAAC;AACrE,eAAO,MAAM,CAAC;OACf,CAAC,CAAC;KACN;;;;;;;SA1CU,KAAK;WAHV,KAAK","file":"Synth.js","sourcesContent":["\nimport {Dryad} from '../../dryadic/Dryad';\n\n\nexport class Synth extends Dryad {\n\n   /**\n   * @param {String|Function} synthDefName - the name of the synthDef\n   *     or a function that can be called and resolve to a synthDef name\n   * @param {Object} args - Arguments may be int|float|string\n   *     If an argument is a function then it will be called.\n   *     If that returns a Promise then it will be resolved and the result of that\n   *     is the final value passed to the Synth.\n   */\n  constructor(synthDefName, args={}) {\n    super();\n    this.properties = {\n      synthDefName: synthDefName,\n      args: args\n    };\n  }\n\n  resolve(/*context*/) {\n    // synthDef should compile to bytes, be in desc lib\n    // may fail\n    // maybe always resolve all properties\n    return {\n      defName: this.properties.synthDefName,\n      args: this.properties.args // not play, just resolve if they need to load things\n    };\n  }\n\n  spawn(context, resolved) {\n    // synthDef can build into the current bundle\n    // but it should be compiled in resolved\n    const nodeID = nextNodeID(context);\n    context.nodeID = nodeID;\n    const oscMessage = msg.synthNew(resolved.defName, nodeID, msg.AddActions.TAIL, context.group, resolved.args);\n    sendMsg(context, oscMessage);\n\n    // if bundling than this will resolve after everything is sent\n    return whenNodeGo(context.server, context.id, nodeID)\n      .then((nodeID) => {\n        updateNodeState(context.server, nodeID, {synthDef: resolvedDefName});\n        return nodeID;\n      });\n  }\n\n  // subtree might contain items in args\n  // that need to spawn first\n}\n"]}
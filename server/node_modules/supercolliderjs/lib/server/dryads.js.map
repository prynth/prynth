{"version":3,"sources":["../../src/server/dryads.js"],"names":["synth","group","compileSynthDef","putSynthDef","stream","synthStream","interpreter","requireInterpreter","server","requireServer","msg","StateKeys","SYNTH_DEFS","synthDefName","args","parentContext","then","context","resolvedDefName","nodeID","resolvedArgs","oscMessage","synthNew","AddActions","TAIL","id","synthDef","children","message","groupNew","defName","sourceCode","compiler","fullCode","result","synthDesc","callAndResponse","defRecv","Buffer","bytes","error","reject","description","state","mutate","set","streamable","i","subscribe","dryad","String","console","params","map","event","assign","options","defaultOptions","stdin","echo","debug","defaults","lang","child","resolved","store","s"],"mappings":"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","file":"dryads.js","sourcesContent":["/* eslint no-console: 0 */\n/** DEPRECATED **/\nimport {withContext, callAndResolve, callAndResolveValues, callAndResolveAll, dryadic} from '../dryadic/helpers';\nimport * as msg from './osc/msg';\nimport {bootServer, bootLang, sendMsg, nextNodeID, interpret} from './internals/side-effects';\nimport {whenNodeGo, updateNodeState} from './node-watcher';\nimport {Promise} from 'bluebird';\nimport _ from 'underscore';\n\nconst StateKeys = {\n  SYNTH_DEFS: 'SYNTH_DEFS'\n};\n\n\n/**\n * Generates a function that will spawn a Synth when it is called\n *\n * When the function is called, it returns a Promise that will\n * -- when the Synth has succesfully started playing --\n * resolve with the Synth's nodeID.\n *\n * @param {String|Function} synthDefName - the name of the synthDef\n *     or a function that can be called and resolve to a synthDef name\n * @param {Object} args - Arguments may be int|float|string\n      If an argument is a function then it will be called.\n      If that returns a Promise then it will be resolved and the result of that\n      is the final value passed to the Synth.\n * @returns {Function} - when evaluated returns a Promise that resolves with the Synth starts\n */\nexport function synth(synthDefName, args={}) {\n  return (parentContext) => {\n    return withContext(parentContext, true).then((context) => {\n      return callAndResolve(synthDefName, context, 'def').then((resolvedDefName) => {\n        const nodeID = nextNodeID(context);\n        context.nodeID = nodeID;\n\n        // will need to store the children ids\n        return callAndResolveValues(args, context).then((resolvedArgs) => {\n          const oscMessage = msg.synthNew(resolvedDefName, nodeID, msg.AddActions.TAIL, context.group, resolvedArgs);\n          sendMsg(context, oscMessage);\n\n          return whenNodeGo(context.server, context.id, nodeID)\n            .then(() => {\n              updateNodeState(context.server, nodeID, {synthDef: resolvedDefName});\n              return nodeID;\n            });\n        });\n      });\n    });\n  };\n}\n\n\nexport function group(children) {\n  return (parentContext) => {\n    return withContext(parentContext, true).then((context) => {\n\n      const nodeID = nextNodeID(context);\n      var message = msg.groupNew(nodeID, msg.AddActions.TAIL, context.group);\n      sendMsg(context, message);\n      return whenNodeGo(context.server, context.id, nodeID)\n        .then(() => {\n          return callAndResolveAll(children, context);\n        });\n    });\n  };\n}\n\n\n/**\n * Compile a SynthDef from a snippet of supercollider source code,\n * send it to the server and stores the SynthDesc in server.state\n *\n * @param {String} defName\n * @param {String} sourceCode - Supports SynthDef, {}, Instr and anything else that responds to .asSynthDef\n */\nexport function compileSynthDef(defName, sourceCode) {\n  const compiler = dryadic((context) => {\n    // Better to use an isolated sclang so any Quarks won't try to mess with this Server\n    var fullCode = `{\n      var def = SynthDef(\"${ defName }\", ${ sourceCode });\n      (\n        synthDesc: def.asSynthDesc.asJSON(),\n        bytes: def.asBytes()\n      )\n    }.value`;\n\n    return interpret(context, fullCode).then((result) => {\n      putSynthDef(context, defName, result.synthDesc);\n      return context.server.callAndResponse(msg.defRecv(new Buffer(result.bytes)))\n        .then(() => defName);\n    }, (error) => {\n      return Promise.reject({\n        description: `Failed to compile SynthDef '${defName}'`,\n        error: error.error,\n        sourceCode: sourceCode\n      });\n    });\n  });\n  return requireServer(requireInterpreter(compiler));\n}\n\n\n/**\n * store synthDefDesc in server state.\n *\n * This marks it as having been compiled and sent to server.\n */\nexport function putSynthDef(context, defName, synthDesc) {\n  context.server.state.mutate(StateKeys.SYNTH_DEFS, (state) => {\n    return state.set(defName, synthDesc);\n  });\n}\n\n\n/**\n * Spawns each item returned by an Rx.Observable stream.\n *\n * Each item returned by the stream should be a dryad\n * like synth, group etc. It will be spawned as a child of this `stream` dryad.\n *\n * @param {Rx.Observeable} streamable - a stream that pushes dryads to be spawned\n */\nexport function stream(streamable) {\n  return dryadic((context) => {\n    var i = 0;\n    streamable.subscribe((dryad) => {\n      callAndResolve(dryad, context, String(i));\n      i += 1;\n    }, (error) => {\n      console.error(error);\n    }, () => {\n      // free self\n    });\n    // on getting ended early (by parent being freed)\n    // dispose subscription\n  });\n}\n\n\n/**\n * Spawns each event in an Rx.Observeable stream\n *\n * {defName: \"saw\", args: {freq: 440}}\n */\nexport function synthStream(streamable, params={}) {\n  return stream(streamable.map((event) => {\n    const args = _.assign({}, params, event.args);\n    return synth(event.defName || params.defName, args);\n  }));\n}\n\n\n/**\n * Boots a new supercollider interpreter making it available for all children\n * as `context.lang`.\n *\n * Ignores any possibly already existing one in context.\n */\nexport function interpreter(children=[], options={}) {\n  const defaultOptions = {\n    stdin: false,\n    echo: true,  // that will make it post OSC send/recv\n    debug: false\n  };\n  return dryadic((context) => {\n    return bootLang(_.defaults(options, defaultOptions))\n      .then((lang) => {\n        return callAndResolveAll(children,\n          _.assign({}, context, {lang: lang}));\n      });\n  });\n}\n\n\n/**\n * Boots a supercollider interpreter if none is already available\n * in the context making it available for all children\n * as `context.lang`.\n */\nexport function requireInterpreter(child, options={}) {\n  return dryadic((context) => {\n    if (!context.lang) {\n      return interpreter([child], options)(context)\n        .then((resolved) => resolved[0]);\n    }\n    return callAndResolve(child, context);\n  });\n}\n\n\n/**\n * Boots a new supercollider server making it available for all children making it available for all children\n * as `context.server`.\n *\n * Always boots a new one, ignoring any possibly already existing one in context.\n */\nexport function server(children=[], options={}) {\n  const defaultOptions = {\n    stdin: false,\n    echo: true,  // that will make it post OSC send/recv\n    debug: false\n  };\n  return dryadic((context) => {\n    return bootServer(_.defaults(options, defaultOptions), context.store)\n      .then((s) => {\n        return callAndResolveAll(children,\n          _.assign({}, context, {server: s, group: 0}));\n      });\n  });\n}\n\n\n/**\n * Boots a supercollider server if none is already available\n * in the context making it available for all children\n * as `context.server`.\n */\nexport function requireServer(child, options={}) {\n  return dryadic((context) => {\n    if (!context.server) {\n      return server([child], options)(context)\n        .then((resolved) => resolved[0]);\n    }\n    return callAndResolve(child, context);\n  });\n}\n\n// interpret\n// interpretFile\n// loadSynthDef(path, defName)\n// buffer(secs, numChans)\n// loadBuffer(path)\n// include('jsmodule', 'funcname')\n// exec\n// fork\n// streamFile\n"]}
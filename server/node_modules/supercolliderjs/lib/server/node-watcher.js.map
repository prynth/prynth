{"version":3,"sources":["../../src/server/node-watcher.js"],"names":["watchNodeNotifications","onNodeGo","whenNodeGo","onNodeEnd","whenNodeEnd","updateNodeState","keys","NODE_WATCHER","NODES","CALLBACKS","ON_NODE_GO","ON_NODE_END","server","re","stream","receive","filter","msg","match","dispose","subscribe","cmd","r","_responders","slice","id","nodeID","handler","_registerHandler","resolve","nodeState","state","mutate","mergeIn","String","type","_disposeHandler","handlerId","mergeDeep","args","apply","updateIn","list","push","deleteIn","hid","_handlersFor","getIn","map","_saveNodeState","set","isGroup","parent","previous","next","head","tail","assign","_callNodeHandlers","eventType","forEach","h","isPlaying","isRunning"],"mappings":"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","file":"node-watcher.js","sourcesContent":["/**\n * Functions for watching scsynth's node lifecycle notifications.\n *\n * Node states and metadata are stored in server.state, so most\n * useful information can be retrieved from there.\n *\n * These functions here are for registering callbacks.\n *\n * @flow\n * @module node-watcher\n *\n */\nimport { Map, List } from 'immutable';\nimport _ from 'lodash';\nimport { Promise } from 'bluebird';\nimport type { Disposable } from 'Rx';\nimport type Server from './server';\nimport type { NodeStateType } from '../Types';\n\nconst keys = {\n  NODE_WATCHER: 'NODE_WATCHER',\n  NODES: 'NODES',\n  CALLBACKS: 'CALLBACKS',\n  ON_NODE_GO: 'ON_NODE_GO',\n  ON_NODE_END: 'ON_NODE_END'\n};\n\n/**\n * Watch server OSC receive for any n_XXX messages:\n *\n * - `n_go`\n * - `n_end`\n * - `n_on`\n * - `n_off`\n * - `n_move`\n * - `n_info`\n *\n * Save all of the supplied info for the node\n * and call any registered callbacks.\n *\n * Initially there is no need to unwatch unless you are\n * creating and discarding Server objects which can happen\n * during testing.\n *\n * TODO: add Server.destroy\n *\n * @param {Server} server\n * @returns {Rx.Disposable} - sub.dispose(); to turn it off.\n */\nexport function watchNodeNotifications(server: Server): Disposable {\n  // n_go\n  // n_end\n  // n_on\n  // n_off\n  // n_move\n  // n_info\n  var re = /^\\/n_(go|end|on|off|move|info)$/;\n  var stream = server.receive.filter(msg => msg[0].match(re));\n  var dispose = stream.subscribe(msg => {\n    var cmd = msg[0];\n    var r = _responders[cmd];\n    if (r) {\n      r(server, msg.slice(1));\n    }\n  });\n  return dispose;\n}\n\n/**\n * Call a function when the server sends an `/n_go` message\n * One callback allowed per id and node\n * The id is usually a context id but could be a random guid\n *\n * @param {Server} server\n * @param {String} id - unique id for this callback registration\n * @param {int} nodeID\n * @param {Function} handler\n * @returns {Function} - cancel function\n */\nexport function onNodeGo(\n  server: Server,\n  id: string,\n  nodeID: number,\n  handler: Function\n): Function {\n  return _registerHandler(keys.ON_NODE_GO, server, id, nodeID, handler);\n}\n\n/**\n * Returns a Promise that resolves when the server sends an\n * `/n_go` message.\n *\n * The id is usually a context id (dryadic) but could be any random guid.\n * It can be anything you want to supply as long as it is unique.\n *\n * @param {Server} server\n * @param {String} id - unique id for this callback registration\n * @param {int} nodeID\n * @returns {Promise} - resolves with nodeID\n */\nexport function whenNodeGo(\n  server: Server,\n  id: string,\n  nodeID: number\n): Promise<number> {\n  return new Promise(resolve => {\n    onNodeGo(server, id, nodeID, () => resolve(nodeID));\n  });\n}\n\n/**\n * Call a function when the server sends an `/n_end` message\n * One callback allowed per id and node.\n *\n * @param {Server} server\n * @param {String} id - unique id for this callback registration\n * @param {int} nodeID\n * @param {Function} handler\n * @returns {Function} - cancel function\n */\nexport function onNodeEnd(\n  server: Server,\n  id: string,\n  nodeID: number,\n  handler: Function\n): Function {\n  return _registerHandler(keys.ON_NODE_END, server, id, nodeID, handler);\n}\n\n/**\n * Returns a Promise that resolves when the server sends an `/n_end` message.\n *\n * The id is usually a context id but could be a random guid\n */\nexport function whenNodeEnd(\n  server: Server,\n  id: string,\n  nodeID: number\n): Promise<number> {\n  return new Promise(resolve => {\n    onNodeEnd(server, id, nodeID, () => resolve(nodeID));\n  });\n}\n\n// function disposeForId(server:Server, id) {\n//   // remove all by matching the context id\n//   throw new Error('Not Yet Implemented');\n// }\n\n/**\n * Update values in the Server's node state registery.\n *\n * This is for internal use.\n */\nexport function updateNodeState(\n  server: Server,\n  nodeID: number,\n  nodeState: NodeStateType\n) {\n  // unless its n_end then delete\n  server.state.mutate(keys.NODE_WATCHER, state => {\n    return state.mergeIn([keys.NODES, String(nodeID)], Map(), nodeState);\n  });\n}\n\n/**\n * @private\n */\nfunction _registerHandler(\n  type,\n  server: Server,\n  id: string,\n  nodeID: number,\n  handler: Function\n): Function {\n  var dispose = () => {\n    _disposeHandler(type, server, id, nodeID);\n  };\n\n  server.state.mutate(keys.NODE_WATCHER, state => {\n    const handlerId = id + ':' + nodeID;\n\n    return state\n      .mergeDeep({\n        [keys.CALLBACKS]: {\n          [handlerId]: (...args) => {\n            if (type === keys.ON_NODE_GO || type === keys.ON_NODE_END) {\n              dispose();\n            }\n            handler.apply(this, args);\n          }\n        }\n      })\n      .updateIn([type, String(nodeID)], List(), list => list.push(handlerId));\n  });\n\n  return dispose;\n}\n\n/**\n * Delete a handler from state object.\n *\n * @private\n */\nfunction _disposeHandler(type, server: Server, id, nodeID: number) {\n  server.state.mutate(keys.NODE_WATCHER, state => {\n    // why would I get undefined ??\n    // probably no longer happens with new mutate\n    // state = state || Map();\n\n    const handlerId = id + ':' + nodeID;\n\n    return state\n      .deleteIn([keys.CALLBACKS, handlerId])\n      .updateIn([type, String(nodeID)], List(), list =>\n        list.filter(hid => hid !== handlerId));\n  });\n}\n\n/**\n * @private\n */\nfunction _handlersFor(server: Server, type, nodeID: number) {\n  return server.state\n    .getIn([keys.NODE_WATCHER, type, String(nodeID)], List())\n    .map(handlerId => {\n      return server.state.getIn([keys.NODE_WATCHER, keys.CALLBACKS, handlerId]);\n    });\n}\n\n/**\n * @private\n */\nfunction _saveNodeState(server: Server, set, msg) {\n  const nodeID = msg[0];\n  const isGroup = msg[4] > 0;\n  var nodeState: NodeStateType = {\n    parent: msg[1],\n    previous: msg[2],\n    next: msg[3],\n    isGroup: isGroup,\n    head: isGroup ? msg[5] : null,\n    tail: isGroup ? msg[6] : null\n  };\n  nodeState = _.assign(nodeState, set);\n  updateNodeState(server, nodeID, nodeState);\n}\n\n/**\n * Call any handlers registered for n_XXX events.\n *\n * @private\n */\nfunction _callNodeHandlers(server: Server, eventType, nodeID: number) {\n  _handlersFor(server, eventType, nodeID).forEach(h => h(nodeID));\n}\n\n/**\n * @private\n */\nconst _responders = {\n  '/n_go': (server: Server, args) => {\n    _saveNodeState(\n      server,\n      {\n        isPlaying: true,\n        isRunning: true\n      },\n      args\n    );\n\n    _callNodeHandlers(server, keys.ON_NODE_GO, args[0]);\n  },\n  '/n_end': (server: Server, args) => {\n    const nodeID = args[0];\n    server.state.mutate(keys.NODE_WATCHER, state => {\n      return state.deleteIn([keys.NODES, String(nodeID)]);\n    });\n    _callNodeHandlers(server, keys.ON_NODE_END, nodeID);\n  },\n  '/n_on': (server: Server, args) => {\n    _saveNodeState(\n      server,\n      {\n        isRunning: true\n      },\n      args\n    );\n  },\n  '/n_off': (server: Server, args) => {\n    _saveNodeState(\n      server,\n      {\n        isRunning: false\n      },\n      args\n    );\n  },\n  '/n_info': (server: Server, args) => {\n    _saveNodeState(server, {}, args);\n  },\n  '/n_move': (server: Server, args) => {\n    _saveNodeState(server, {}, args);\n  }\n};\n"]}
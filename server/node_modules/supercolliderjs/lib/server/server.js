'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.boot = boot;

var _events = require('events');

var _events2 = _interopRequireDefault(_events);

var _rx = require('rx');

var _child_process = require('child_process');

var _lodash = require('lodash');

var _lodash2 = _interopRequireDefault(_lodash);

var _dgram = require('dgram');

var dgram = _interopRequireWildcard(_dgram);

var _oscMin = require('osc-min');

var osc = _interopRequireWildcard(_oscMin);

var _bluebird = require('bluebird');

var _SendOSC = require('./internals/SendOSC');

var _SendOSC2 = _interopRequireDefault(_SendOSC);

var _utils = require('./osc/utils');

var _msg = require('./osc/msg');

var _resolveOptions = require('../utils/resolveOptions');

var _resolveOptions2 = _interopRequireDefault(_resolveOptions);

var _defaultServerOptions = require('./default-server-options');

var _defaultServerOptions2 = _interopRequireDefault(_defaultServerOptions);

var _logger = require('../utils/logger');

var _logger2 = _interopRequireDefault(_logger);

var _ServerState = require('./ServerState');

var _ServerState2 = _interopRequireDefault(_ServerState);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj.default = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

/**
  * Server - starts a SuperCollider synthesis server (scsynth)
  * as a child process. Enables OSC communication, subscribe to process events,
  * send call and response OSC messages.
  *
  * SuperCollider comes with an executable called scsynth
  * which can be communicated with via OSC.
  *
  * To send raw OSC messages:
  * ```js
  * server.send.msg('/s_new', ['defName', 440])
  * ```
  *
  * Raw OSC responses can be subscribed to:
  * ```js
  * server.receive.subscribe(function(msg) {
  *   console.log(msg);
  * });
  * ```
 */
var Server = function (_EventEmitter) {
  _inherits(Server, _EventEmitter);

  /**
   * @param options - command line options for scsynth
   * @param stateStore - optional parent Store for allocators and node watchers
   */


  /**
   * Node Socket. see /declarations
   * @private
   */


  /**
   * Holds the mutable server state
   * including allocators and the node state watcher.
   * If a parent stateStore is supplied then it will store within that.
   */


  /**
   * A subscribeable stream of STDOUT printed by the scsynth process.
   */


  /**
   * Supports `server.send.msg()` and `server.send.bundle()`
   *
   * You can also subscribe to it and get the OSC messages
   * and bundles that are being sent echoed to you for
   * debugging purposes.
   */


  /**
   * The process id that nodejs spawn() returns
   * @private
   */

  /**
   * ```js
   * host: string,
   * serverPort: string,
   * protocol: string,
   * commandLineOptions: Array<string>,
   * numPrivateAudioBusChannels: number,
   * numAudioBusChannels: number,
   * numControlBusChannels: number,
   * numInputBusChannels: number,
   * numOutputBusChannels: number,
   * numBuffers: number,
   * maxNodes: number,
   * maxSynthDefs: number,
   * blockSize: number,
   * hardwareBufferSize: number,
   * memSize: number,
   * numRGens: number,
   * numWireBufs: number,
   * sampleRate: number,
   * loadDefs: boolean,
   * inputStreamsEnabled: boolean,
   * outputStreamsEnabled: boolean,
   * device: string,
   * verbosity: number,
   * zeroConf: boolean,
   * restrictedPath: string,
   * ugenPluginsPath: string,
   * initialNodeID: number,
   * remoteControlVolume: boolean,
   * memoryLocking: boolean,
   * threads: boolean,
   * useSystemClock: boolean,
   * // Environment variables to set for the server process
   * // eg. SC_JACK_DEFAULT_INPUTS: "system:capture_1,system:capture_2"
   * env: Object
   * ```
   */
  function Server() {
    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var stateStore = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

    _classCallCheck(this, Server);

    var _this = _possibleConstructorReturn(this, (Server.__proto__ || Object.getPrototypeOf(Server)).call(this));

    _this.options = _lodash2.default.defaults(options, _defaultServerOptions2.default);
    _this.address = _this.options.host + ':' + _this.options.port;
    _this.process = null;
    _this.isRunning = false;

    _this.send = new _SendOSC2.default();
    _this.receive = new _rx.Subject();
    _this.stdout = new _rx.Subject();
    _this.processEvents = new _rx.Subject();

    _this._initLogger();
    _this._initEmitter();
    _this._initSender();

    _this._serverObservers = {};

    _this.state = new _ServerState2.default(_this, stateStore);
    return _this;
  }

  /* @private */


  /* @private */


  /**
   * The logger used to print messages to the console.
   */


  /**
   * A subscribeable stream of events related to the scsynth process.
   * Used internally.
   */


  /**
   * A subscribeable stream of OSC events received.
   */


  _createClass(Server, [{
    key: '_initLogger',
    value: function _initLogger() {
      var _this2 = this;

      this.log = new _logger2.default(this.options.debug, this.options.echo, this.options.log);
      this.send.subscribe(function (event) {
        // will be a type:msg or type:bundle
        // if args has a type: Buffer in it then compress that
        var out = JSON.stringify(event.payload || event, function (k, v) {
          if (k === 'data' && _lodash2.default.isArray(v)) {
            return _lodash2.default.reduce(v, function (memo, n) {
              return memo + n.toString(16);
            }, '');
          }
          return v;
        }, 2);
        if (!_this2.osc) {
          out = '[NOT CONNECTED] ' + out;
        }
        _this2.log.sendosc(out);
      });
      this.receive.subscribe(function (o) {
        _this2.log.rcvosc(o);
        // log all /fail responses as error
        if (o[0] === '/fail') {
          _this2.log.err(o);
        }
      }, function (err) {
        return _this2.log.err(err);
      });
      this.stdout.subscribe(function (o) {
        // scsynth doesn't send ERROR messages to stderr
        // if ERROR or FAILURE in output then redirect as though it did
        // so it shows up in logs
        if (o.match(/ERROR|FAILURE/)) {
          _this2.log.stderr(o);
        } else {
          _this2.log.stdout(o);
        }
      }, function (err) {
        return _this2.log.stderr(err);
      });
      this.processEvents.subscribe(function (o) {
        return _this2.log.dbug(o);
      }, function (err) {
        return _this2.log.err(err);
      });
    }

    /**
      * Emit signals are deprecated and will be removed in 1.0
      *
      * Instead use ```server.{channel}.subscribe((event) => { })```
      *
      * Event Emitter emits:
      *    'out'   - stdout text from the server
      *    'error' - stderr text from the server or OSC error messages
      *    'exit'  - when server exits
      *    'close' - when server closes the UDP connection
      *    'OSC'   - OSC responses from the server
      *
      * @private
     */

  }, {
    key: '_initEmitter',
    value: function _initEmitter() {
      var _this3 = this;

      this.receive.subscribe(function (msg) {
        _this3.emit('OSC', msg);
      });
      this.processEvents.subscribe(function () {}, function (err) {
        return _this3.emit('exit', err);
      });
      this.stdout.subscribe(function (out) {
        return _this3.emit('out', out);
      }, function (out) {
        return _this3.emit('stderr', out);
      });
    }
  }, {
    key: '_initSender',
    value: function _initSender() {
      var _this4 = this;

      this.send.on('msg', function (msg) {
        if (_this4.osc) {
          var buf = osc.toBuffer(msg);
          _this4.osc.send(buf, 0, buf.length, _this4.options.serverPort, _this4.options.host);
        }
      });
      this.send.on('bundle', function (bundle) {
        if (_this4.osc) {
          var buf = osc.toBuffer(bundle);
          _this4.osc.send(buf, 0, buf.length, _this4.options.serverPort, _this4.options.host);
        }
      });
    }

    /**
     * Format the command line args for scsynth.
     *
     * The args built using the options supplied to `Server(options)` or `sc.server.boot(options)`
     *
     * ```js
     *  sc.server.boot({device: 'Soundflower (2ch)'});
     *  sc.server.boot({serverPort: '11211'});
     *  ```
     *
     * Supported arguments:
     *
     *     numAudioBusChannels
     *     numControlBusChannels
     *     numInputBusChannels
     *     numOutputBusChannels
     *     numBuffers
     *     maxNodes
     *     maxSynthDefs
     *     blockSize
     *     hardwareBufferSize
     *     memSize
     *     numRGens - max random generators
     *     numWireBufs
     *     sampleRate
     *     loadDefs - (0 or 1)
     *     inputStreamsEnabled - "01100" means only the 2nd and 3rd input streams
     *                          on the device will be enabled
     *     outputStreamsEnabled,
     *     device - name of hardware device
     *            or array of names for [inputDevice, outputDevice]
     *     verbosity: 0 1 2
     *     restrictedPath
     *     ugenPluginsPath
     *     password - for TCP logins open to the internet
     *     maxLogins - max users that may login
     *
     * Arbitrary arguments can be passed in as options.commandLineArgs
     * which is an array of strings that will be space-concatenated
     * and correctly shell-escaped.
     *
     * Host is currently ignored: it is always local on the same machine.
     *
     * See ServerOptions documentation: http://danielnouri.org/docs/SuperColliderHelp/ServerArchitecture/ServerOptions.html
     *
     * @return {Array<string>} List of non-default args
     */

  }, {
    key: 'args',
    value: function args() {
      var flagMap = {
        numAudioBusChannels: '-a',
        numControlBusChannels: '-c',
        numInputBusChannels: '-i',
        numOutputBusChannels: '-o',
        numBuffers: '-b',
        maxNodes: '-n',
        maxSynthDefs: '-d',
        blockSize: '-z',
        hardwareBufferSize: '-Z',
        memSize: '-m',
        numRGens: '-r',
        numWireBufs: '-w',
        sampleRate: '-S',
        loadDefs: '-D', // boolean
        inputStreamsEnabled: '-I',
        outputStreamsEnabled: '-O',
        device: '-H',
        verbosity: '-V',
        zeroConf: '-R',
        restrictedPath: '-P',
        ugenPluginsPath: '-U',
        password: '-p',
        maxLogins: '-l'
      };

      var _options = this.options,
          serverPort = _options.serverPort,
          protocol = _options.protocol,
          commandLineArgs = _options.commandLineArgs;


      var opts = ['-u', serverPort];

      if (protocol === 'tcp') {
        throw new Error('Only udp sockets are supported at this time.');
      }

      _lodash2.default.forEach(this.options, function (option, argName) {
        var flag = flagMap[argName];
        if (flag) {
          if (option !== _defaultServerOptions2.default[argName]) {
            opts.push(flag);
            if (_lodash2.default.isArray(option)) {
              opts.push.apply(opts, _toConsumableArray(option));
            } else {
              opts.push(option);
            }
          }
        }
      });

      if (_lodash2.default.isArray(commandLineArgs)) {
        opts.push.apply(opts, _toConsumableArray(commandLineArgs));
      }

      return opts.map(String);
    }

    /**
     * Boot the server
     *
     * Start scsynth and establish a pipe connection to receive stdout and stderr.
     *
     * Does not connect, so UDP is not yet ready for OSC communication.
     *
     * listen for system events and emit: exit out error
     *
     * @returns {Promise}
     */

  }, {
    key: 'boot',
    value: function boot() {
      var _this5 = this;

      return new _bluebird.Promise(function (resolve, reject) {
        _this5.isRunning = false;

        try {
          _this5._spawnProcess();
        } catch (e) {
          reject(e);
        }

        _this5._serverObservers.stdout = _rx.Observable.fromEvent(_this5.process.stdout, 'data', function (data) {
          return String(data);
        });
        _this5._serverObservers.stdout.subscribe(function (e) {
          return _this5.stdout.onNext(e);
        });
        _this5._serverObservers.stderr = _rx.Observable.fromEvent(_this5.process.stderr, 'data').subscribe(function (out) {
          // just pipe it into the stdout object's error stream
          _this5.stdout.onError(out);
        });

        // Keep a local buffer of the stdout text because on Windows it can be split into odd chunks.
        var stdoutBuffer = '';
        // watch for ready message
        _this5._serverObservers.stdout.takeWhile(function (text) {
          stdoutBuffer += text;
          return !stdoutBuffer.match(/SuperCollider 3 server ready/);
        }).subscribe(function () {}, _this5.log.err, function () {
          // onComplete
          stdoutBuffer = '';
          _this5.isRunning = true;
          resolve(_this5);
        });

        setTimeout(function () {
          if (!_this5.isRunning) {
            reject(new Error('Server failed to start in 3000ms'));
          }
        }, 3000);
      });
    }
  }, {
    key: '_spawnProcess',
    value: function _spawnProcess() {
      var _this6 = this;

      var execPath = this.options.scsynth,
          args = this.args();

      var logMsg = 'Start process: ' + execPath + ' ' + args.join(' ');
      this.processEvents.onNext(logMsg);

      var options = {
        cwd: this.options.cwd,
        detached: false,
        // Environment variables to set for server process
        // eg. SC_JACK_DEFAULT_INPUTS: "system:capture_1,system:capture_2"
        env: this.options.env || {}
      };

      this.process = (0, _child_process.spawn)(execPath, args, options);

      if (!this.process.pid) {
        var error = 'Failed to boot ' + execPath;
        this.processEvents.onError(error);
        throw new Error(error);
      }

      this.processEvents.onNext('pid: ' + this.process.pid);

      // when this parent process dies, kill child process
      var killChild = function killChild() {
        if (_this6.process) {
          _this6.process.kill('SIGTERM');
          _this6.process = null;
        }
      };

      process.on('exit', killChild);

      this.process.on('error', function (err) {
        _this6.processEvents.onError(err);
        _this6.isRunning = false;
        // this.disconnect()
      });
      this.process.on('close', function (code, signal) {
        _this6.processEvents.onError('Server closed. Exit code: ' + code + ' signal: ' + signal);
        _this6.isRunning = false;
        // this.disconnect()
      });
      this.process.on('exit', function (code, signal) {
        _this6.processEvents.onError('Server exited. Exit code: ' + code + ' signal: ' + signal);
        _this6.isRunning = false;
        // this.disconnect()
      });
    }

    /**
     * quit
     *
     * kill scsynth process
     * TODO: should send /quit first for shutting files
     */

  }, {
    key: 'quit',
    value: function quit() {
      if (this.process) {
        this.disconnect();
        this.process.kill('SIGTERM');
        this.process = null;
      }
    }

    /**
     * Establish connection to scsynth via OSC socket
     *
     * @returns {Promise} - resolves when udp responds
     */

  }, {
    key: 'connect',
    value: function connect() {
      var _this7 = this;

      return new _bluebird.Promise(function (resolve, reject) {
        var udpListening = 'udp is listening';

        _this7.osc = dgram.createSocket('udp4');

        _this7.osc.on('listening', function () {
          _this7.processEvents.onNext(udpListening);
        });
        _this7.osc.on('close', function (e) {
          _this7.processEvents.onNext('udp closed: ' + e);
          _this7.disconnect();
        });

        // pipe events to this.receive
        _this7._serverObservers.oscMessage = _rx.Observable.fromEvent(_this7.osc, 'message', function (msgbuf) {
          return osc.fromBuffer(msgbuf);
        });
        _this7._serverObservers.oscMessage.subscribe(function (e) {
          return _this7.receive.onNext((0, _utils.parseMessage)(e));
        });

        _this7._serverObservers.oscError = _rx.Observable.fromEvent(_this7.osc, 'error');
        _this7._serverObservers.oscError.subscribe(function (e) {
          _this7.receive.onError(e);
          reject(e);
        });

        // this will trigger a response from server
        // which will cause a udp listening event.
        // After server responds then we are truly connected.
        _this7.callAndResponse((0, _msg.notify)()).then(function () {
          resolve(_this7);
        });
      });
    }

    /**
     * @private
     */

  }, {
    key: 'disconnect',
    value: function disconnect() {
      if (this.osc) {
        this.osc.close();
        delete this.osc;
      }

      // TODO: its the subscriptions that need to be disposed, these are the Observables
      // this._serverObservers.forEach((obs) => obs.dispose());
      // for (var key in this._serverObservers) {
      //   console.log(key, this._serverObservers[key], this._serverObservers[key].dispose);
      //   this._serverObservers[key].dispose();
      // }
      this._serverObservers = {};
    }

    /**
     * Send OSC message to server
     *
     * @deprecated - use: `server.send.msg([address, arg1, arg2])``
     * @param {String} address - OSC command string eg. `/s_new` which is referred to in OSC as the address
     * @param {Array} args
     */

  }, {
    key: 'sendMsg',
    value: function sendMsg(address, args) {
      this.send.msg([address].concat(args));
    }

    /**
     * Wait for a single OSC response from server matching the supplied args.
     *
     * This is for getting responses async from the server.
     * The first part of the message matches the expected args,
     * and the rest of the message contains the response.
     *
     * The Promise fullfills with any remaining payload including in the message.
     *
     * @param {Array} matchArgs - osc message to match as a single array: `[/done, /notify]`
     * @param {int} timeout - in milliseconds before the Promise is rejected
     * @returns {Promise}
     */

  }, {
    key: 'oscOnce',
    value: function oscOnce(matchArgs) {
      var _this8 = this;

      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4000;

      return new _bluebird.Promise(function (resolve, reject) {
        var subscription = _this8.receive.subscribe(function (msg) {
          var command = msg.slice(0, matchArgs.length);
          if (_lodash2.default.isEqual(command, matchArgs)) {
            var payload = msg.slice(matchArgs.length);
            resolve(payload);
            dispose();
          }
        });

        // if timeout then reject and dispose
        var tid = setTimeout(function () {
          dispose();
          reject(new Error('Timed out waiting for OSC response: ' + JSON.stringify(matchArgs)));
        }, timeout);

        function dispose() {
          subscription.dispose();
          clearTimeout(tid);
        }
      });
    }

    /**
     * Send an OSC command that expects a reply from the server,
     * returning a `Promise` that resolves with the response.
     *
     * This is for getting responses async from the server.
     * The first part of the message matches the expected args,
     * and the rest of the message contains the response.
     *
     * @param {Object} callAndResponse
     *
     *  ```js
     *  {
     *      call: ['/some_osc_msg', 1, 2],
     *      response: ['/expected_osc_response', 1, 2, 3]
     *  }```
     * @param {int} timeout - in milliseconds before rejecting the `Promise`
     * @returns {Promise} - resolves with all values the server responsed with after the matched response.
     */

  }, {
    key: 'callAndResponse',
    value: function callAndResponse(_callAndResponse) {
      var timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 4000;

      var promise = this.oscOnce(_callAndResponse.response, timeout);
      this.send.msg(_callAndResponse.call);
      return promise;
    }
  }]);

  return Server;
}(_events2.default);

/**
 * Boot a server with options and connect
 *
 * @param {Object} options - command line options for server
 * @param {Store} store - optional external Store to hold Server state
 * @returns {Promise} - resolves with the Server
 */


exports.default = Server;
function boot() {
  var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var store = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

  return (0, _resolveOptions2.default)(undefined, options).then(function (opts) {
    var s = new Server(opts, store);
    return s.boot().then(function () {
      return s.connect();
    }).then(function () {
      return s;
    });
  });
}
//# sourceMappingURL=server.js.map
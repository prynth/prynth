{"version":3,"sources":["../../../src/server/osc/utils.js"],"names":["parseMessage","makeMessage","makeBundle","asPacket","deltaTimeTag","osc","msg","oscType","timetagToDate","timetag","concat","elements","map","address","args","a","value","slice","time","packets","thing","isArray","bundle","timeTag","dateToTimetag","seconds","now","d","timestampToTimetag"],"mappings":";;;;;;QAiCgBA,Y,GAAAA,Y;QAWAC,W,GAAAA,W;QAmCAC,U,GAAAA,U;QAgBAC,Q,GAAAA,Q;QA4CAC,Y,GAAAA,Y;;AApIhB;;;;AACA;;IAAYC,G;;;;;;AAGZ;;;;;;;;;;;;;;;;;;;;;;AAXA;;;;;;;AAiCO,SAASL,YAAT,CAAsBM,GAAtB,EAAmD;AACxD,MAAIA,IAAIC,OAAJ,KAAgB,QAApB,EAA8B;AAC5B,WAAO,CAACC,cAAcF,IAAIG,OAAlB,CAAD,EAA6BC,MAA7B,CAAoCJ,IAAIK,QAAJ,CAAaC,GAAb,CAAiBZ,YAAjB,CAApC,CAAP;AACD;AACD;AACA,SAAO,CAACM,IAAIO,OAAL,EAAcH,MAAd,CAAqBJ,IAAIQ,IAAJ,CAASF,GAAT,CAAa;AAAA,WAAKG,EAAEC,KAAP;AAAA,GAAb,CAArB,CAAP;AACD;;AAED;;;AAGO,SAASf,WAAT,CAAqBK,GAArB,EAAkD;AACvD,SAAO;AACLC,aAAS,SADJ;AAELM,aAASP,IAAI,CAAJ,CAFJ;AAGLQ,UAAMR,IAAIW,KAAJ,CAAU,CAAV;AAHD,GAAP;AAKD;;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;;;;;;AAWO,SAASf,UAAT,CACLgB,IADK,EAELC,OAFK,EAGU;AACf,SAAO;AACLZ,aAAS,QADJ;AAELE,aAASS,IAFJ;AAGLP,cAAU,iBAAEC,GAAF,CAAMO,OAAN,EAAehB,QAAf;AAHL,GAAP;AAKD;;AAED;;;;;AAKO,SAASA,QAAT,CAAkBiB,KAAlB,EAA6D;AAClE,MAAI,iBAAEC,OAAF,CAAUD,KAAV,CAAJ,EAAsB;AACpB,WAAOnB,YAAYmB,KAAZ,CAAP;AACD;AACD,MAAIE,SAAUF,KAAd,CAJkE,CAInC;AAC/B,SAAOlB,WAAWoB,OAAOC,OAAlB,EAA2BD,OAAOH,OAAP,IAAkB,EAA7C,CAAP;AACD;;AAED;;;;;;;;;;;;;;;;;;AAkBO,IAAMX,wCAAgBH,IAAIG,aAA1B;;AAEP;;;;;;;AAOO,IAAMgB,wCAAgBnB,IAAImB,aAA1B;;AAEP;;;;;;;AAOO,SAASpB,YAAT,CAAsBqB,OAAtB,EAAuCC,GAAvC,EAAuE;AAC5E,MAAMC,IAAI,CAACD,OAAO,iBAAEA,GAAF,EAAR,IAAmB,IAAnB,IAA2BD,WAAW,CAAtC,CAAV;AACA,SAAOpB,IAAIuB,kBAAJ,CAAuBD,CAAvB,CAAP;AACD","file":"utils.js","sourcesContent":["/**\n * OSC utilities\n *\n * @module utils\n * @flow\n */\n\nimport _ from 'lodash';\nimport * as osc from 'osc-min';\nimport type { MsgType, OSCMinMsgType, OSCTimeType } from '../../Types';\n\n/**\n  * Convert full OSC message to a simple Array\n  *\n  * Converts:\n  *\n  * ```js\n  *  {address: '/n_go',\n  *    args:\n  *     [ Object { type: 'integer', value: 1000 },\n  *       Object { type: 'integer', value: 0 },\n  *       Object { type: 'integer', value: -1 },\n  *       Object { type: 'integer', value: 3 },\n  *       Object { type: 'integer', value: 0 } ],\n  *    oscType: 'message' }\n  * ```\n  *\n  * to:\n  *\n  * ```js\n  * ['/n_go', 1000, 0, -1, 3, 0]\n  * ```\n */\nexport function parseMessage(msg: OSCMinMsgType): MsgType {\n  if (msg.oscType === 'bundle') {\n    return [timetagToDate(msg.timetag)].concat(msg.elements.map(parseMessage));\n  }\n  // for each msg.arg pluck just value\n  return [msg.address].concat(msg.args.map(a => a.value));\n}\n\n/**\n * Format an object for osc-min message\n */\nexport function makeMessage(msg: MsgType): OSCMinMsgType {\n  return {\n    oscType: 'message',\n    address: msg[0],\n    args: msg.slice(1)\n  };\n}\n\n// export function checkTypes(input:[any]) : MsgType {\n// _.each(input, (inp, i) => {\n//   console.log(inp, typeof inp);\n//   switch (typeof inp) {\n//     case 'string':\n//     case 'number':\n//     case 'object':\n//       break;\n//     default:\n//       throw new Error(`Invalid OSC Type at index ${i}: ${inp} of ${input}`);\n//   }\n// });\n\n//   return input;\n// }\n\n/**\n * Format an object for osc-min bundle\n *\n * @param {null|Number|Array|Date} time -\n *  - null: now, immediately\n *  - number: unix timestamp in seconds\n *  - Array: `[secondsSince1900Jan1, fractionalSeconds]`\n *  - Date\n * @param {Array} packets - osc messages as `[address, arg1, ...argN]`\n *                        or sub bundles as `[{timeTag: , packets: }, ...]`\n */\nexport function makeBundle(\n  time: OSCTimeType,\n  packets: [MsgType]\n): OSCMinMsgType {\n  return {\n    oscType: 'bundle',\n    timetag: time,\n    elements: _.map(packets, asPacket)\n  };\n}\n\n/**\n * Format children of a bundle as either message or bundle objects.\n *\n * @private\n */\nexport function asPacket(thing: [MsgType] | MsgType): OSCMinMsgType {\n  if (_.isArray(thing)) {\n    return makeMessage(thing);\n  }\n  let bundle = (thing: MsgType); // typecast\n  return makeBundle(bundle.timeTag, bundle.packets || []);\n}\n\n/**\n * Convert a timetag array to a JavaScript Date object in your local timezone.\n *\n * Received OSC bundles that were converted with `fromBuffer` will have a timetag array:\n * `[secondsSince1970, fractionalSeconds]`\n *\n * That has an accuracy of 0.00000000023283 seconds or 2^32 per second or 4,294,979,169.35102864751106 per second.\n *\n * Note that the sample rate for audio is usually only 44.1kHz.\n *\n * timetagToDate reduces the accuracy but is useful for logging a human readable date.\n *\n * Accuracy is reduced to milliseconds, but the returned `Date` object also has\n * `fractionalSecondsInt` and `fractionalSecondsFloat` properties set.\n *\n * @param {Array} ntpTimeTag\n * @returns {Date}\n */\nexport const timetagToDate = osc.timetagToDate;\n\n/**\n * Convert a JavaScript Date to a NTP timetag array `[secondsSince1970, fractionalSeconds]`.\n *\n * `toBuffer` already accepts Dates for timetags so you might not need this function.\n * If you need to schedule bundles with sub-millisecond accuracy then you\n * could use this to help assemble the NTP array.\n */\nexport const dateToTimetag = osc.dateToTimetag;\n\n/**\n * Make NTP timetag array relative to the current time.\n *\n * @param seconds  - seconds relative to now\n * @param now      - JavaScript timestamp in milliseconds\n * @return `[ntpSecs, ntpFracs]`\n */\nexport function deltaTimeTag(seconds: number, now: ?number): [number, number] {\n  const d = (now || _.now()) / 1000 + (seconds || 0);\n  return osc.timestampToTimetag(d);\n}\n"]}
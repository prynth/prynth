{"version":3,"sources":["../../src/server/ServerPlus.js"],"names":["boot","msg","Group","server","id","send","nodeFree","String","settings","nodeSet","Synth","AudioBus","numChannels","state","freeAudioBus","ControlBus","freeControlBus","Buffer","numFrames","callAndResponse","bufferFree","then","freeBuffer","SynthDef","defName","synthDefResult","sourceCode","path","name","ServerPlus","synthDef","args","group","addAction","AddActions","TAIL","Promise","all","resolve","def","g","nodeId","nextNodeID","sn","synthNew","groupNew","defs","compile","synthDefCompiler","compileAndSend","mapValues","requested","reject","result","defsMap","Error","synthDesc","source","_compileSynthDef","allocBufferID","bufferAlloc","startFrame","numFramesToRead","bufferAllocRead","allocAudioBus","allocControlBus","_synthDefCompiler","options","store","undefined","s","opts","connect"],"mappings":"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","file":"ServerPlus.js","sourcesContent":["/**\n * @flow\n *\n * This is a sketch to make resource creation and management easier.\n *\n * status: ALPHA\n */\nimport _ from 'lodash';\nimport Server from './server';\nimport * as msg from './osc/msg';\nimport { whenNodeGo, whenNodeEnd } from './node-watcher';\nimport SynthDefCompiler from '../lang/SynthDefCompiler';\nimport resolveOptions from '../utils/resolveOptions';\nimport type { SynthDefResultType } from '../Types';\n\n/**\n * scsynth Group\n *\n * See `server.group(...)`\n */\nclass Group {\n  id: number;\n  server: ServerPlus;\n\n  constructor(server: ServerPlus, id: number) {\n    this.id = id;\n    this.server = server;\n  }\n\n  /**\n   * Stop the Group and remove it from the play graph on the server.\n   */\n  free(): Promise<number> {\n    this.server.send.msg(msg.nodeFree(this.id));\n    return whenNodeEnd(this.server, String(this.id), this.id);\n  }\n\n  /**\n   * Update control parameters on the Synth.\n   *\n   * @example\n   * ```js\n   * synth.set({freq: 441, amp: 0.9});\n   * ```\n   *\n   * This method works for Group and Synth.\n   * For a Group it sends the set message to all children Synths\n   * in the Group.\n   */\n  set(settings: Object) {\n    this.server.send.msg(msg.nodeSet(this.id, settings));\n  }\n  // moveAfter\n  // moveBefore\n  // onEnd\n  // run\n  // trace\n}\n\n/**\n * scsynth Synth\n *\n * See `server.synth(...)`\n */\nclass Synth extends Group {\n  // store def and args\n  // synthDef\n  // release\n  // get\n}\n\n/**\n * scsynth audio bus\n\n * See `server.audioBus(...)`\n *\n * These bus numbers (ids) and numChannels are allocated here in the client.\n * The server only gets bus ids for reading and writing to.\n */\nclass AudioBus {\n  id: number;\n  server: ServerPlus;\n  numChannels: number;\n\n  constructor(server: ServerPlus, id: number, numChannels: number) {\n    this.server = server;\n    this.id = id;\n    this.numChannels = numChannels;\n  }\n\n  /**\n   * Deallocate the AudioBus, freeing it for resuse.\n   */\n  free() {\n    this.server.state.freeAudioBus(this.id, this.numChannels);\n  }\n}\n\n/**\n * scsynth control bus\n\n * See `server.controlBus(...)`\n *\n * These bus numbers (ids) and numChannels are allocated here in the client.\n * The server only gets bus ids for reading and writing to.\n */\nclass ControlBus extends AudioBus {\n  /**\n   * Deallocate the ControlBus, freeing it for resuse.\n   */\n  free() {\n    this.server.state.freeControlBus(this.id, this.numChannels);\n  }\n  // set\n  // fill\n  // get\n}\n\n/**\n * scsynth Buffer\n *\n * See `server.buffer(...)` and `server.readBuffer(...)`\n */\nclass Buffer {\n  id: number;\n  server: ServerPlus;\n  numFrames: number;\n  numChannels: number;\n\n  constructor(\n    server: ServerPlus,\n    id: number,\n    numFrames: number,\n    numChannels: number\n  ) {\n    this.server = server;\n    this.id = id;\n    this.numFrames = numFrames;\n    this.numChannels = numChannels;\n  }\n\n  /**\n   * Deallocate the Buffer, freeing memory on the server.\n   */\n  free(): Promise<number> {\n    return this.server.callAndResponse(msg.bufferFree(this.id)).then(() => {\n      this.server.state.freeBuffer(this.id, this.numChannels);\n    });\n  }\n\n  // read\n  // write\n  // zero\n  // set frames\n  // fill\n  // gen\n  // close\n  // query\n  // get\n}\n\n/**\n * scsynth SynthDef\n *\n * See `server.synthDefs(...)`\n *\n * These are currently compiled using sclang,\n * and the synthDefResult holds metadata about the compiled\n * synthdef and the raw compiled bytes.\n *\n * The SynthDef may have been compiled from a sourceCode string\n * or compiled from a file at path.\n */\nclass SynthDef {\n  server: ServerPlus;\n  name: string;\n  synthDefResult: SynthDefResultType;\n  sourceCode: ?string;\n  path: ?string;\n\n  constructor(\n    server: ServerPlus,\n    defName: string,\n    synthDefResult: SynthDefResultType,\n    sourceCode: ?string,\n    path: ?string\n  ) {\n    this.server = server;\n    this.name = defName;\n    this.synthDefResult = synthDefResult;\n    this.sourceCode = sourceCode;\n    this.path = path;\n    // SynthDefCompiler will watch the path\n  }\n\n  // free\n  // setSource\n  // get info about def\n}\n\n/**\n * This extends Server with convienient methods for creating Synth, Group, compiling SynthDefs, creating Buses, Buffers etc.\n *\n * All methods return Promises, and all arguments accept Promises.\n * This means that async actions (like starting a sclang interpreter,\n * compiling SynthDefs and sending them to the server) are complete and their results\n * are ready to be used by whatever they have been supplied to.\n */\nexport default class ServerPlus extends Server {\n  /**\n   * @private\n   */\n  _synthDefCompiler: ?SynthDefCompiler;\n\n  /**\n   * Create a Synth on the server\n   */\n  synth(\n    synthDef: SynthDef,\n    args: Object = {},\n    group: ?Group,\n    addAction: number = msg.AddActions.TAIL\n  ): Promise<Synth> {\n    return Promise.all([\n      Promise.resolve(synthDef),\n      Promise.resolve(group)\n    ]).then(([def, g]) => {\n      let nodeId = this.state.nextNodeID();\n      let sn = msg.synthNew(def.name, nodeId, addAction, g ? g.id : 0, args);\n      this.send.msg(sn);\n      // unique string for callback registration\n      return whenNodeGo(this, String(nodeId), nodeId).then(\n        () => new Synth(this, nodeId)\n      );\n    });\n  }\n\n  // grainSynth with no id\n\n  /**\n   * Create a Group on the server\n   */\n  group(\n    group: ?Group,\n    addAction: number = msg.AddActions.TAIL\n  ): Promise<Group> {\n    return Promise.resolve(group).then(g => {\n      let nodeId = this.state.nextNodeID();\n      let sn = msg.groupNew(nodeId, addAction, g ? g.id : 0);\n      this.send.msg(sn);\n      // unique string for callback registration\n      return whenNodeGo(this, String(nodeId), nodeId).then(() => {\n        return new Group(this, nodeId);\n      });\n    });\n  }\n\n  /**\n   * @private\n   */\n  get synthDefCompiler(): SynthDefCompiler {\n    if (!this._synthDefCompiler) {\n      this._synthDefCompiler = new SynthDefCompiler();\n    }\n    return this._synthDefCompiler;\n  }\n\n  /**\n   * Compile multiple SynthDefs either from source or path.\n   * If you have more than one to compile then always use this\n   * as calling `server.synthDef` multiple times will start up\n   * multiple supercollider interpreters. This is harmless, but\n   * you do have a lot of icons bouncing in your dock.\n   *\n   * @param defs - An object with `{defName: spec, ...}` where spec is\n   *               an object like `{source: \"SynthDef('noise', { ...})\"}`\n   *               or `{path: \"./noise.scd\"}`\n   * @returns An object with the synthDef names as keys and Promises as values.\n   *                    Each Promise will resolve with a SynthDef.\n   *                    Each Promises can be supplied directly to `server.synth()`\n   */\n  synthDefs(defs: Object): { [defName: string]: Promise<SynthDef> } {\n    let compile = this.synthDefCompiler.boot().then(() => {\n      return this.synthDefCompiler.compileAndSend(defs, this);\n    });\n\n    return _.mapValues(defs, (requested, name) => {\n      return new Promise((resolve, reject) => {\n        return compile.then(defsMap => {\n          let result = defsMap[name];\n          if (!result) {\n            return reject(new Error(`${name} not found in compiled SynthDefs`));\n          }\n          if (result.name !== name) {\n            return reject(\n              new Error(\n                `SynthDef compiled as ${result.name} but server.synthDefs was called with: ${name}`\n              )\n            );\n          }\n          resolve(\n            new SynthDef(\n              this,\n              result.name,\n              result,\n              result.synthDesc.sourceCode,\n              requested && requested.path\n            )\n          );\n        });\n      });\n    });\n  }\n\n  /**\n   * @private\n   */\n  _compileSynthDef(\n    defName: string,\n    sourceCode: ?string,\n    path: ?string\n  ): Promise<SynthDef> {\n    return this.synthDefCompiler.boot().then(() => {\n      return this.synthDefCompiler\n        .compileAndSend(\n          {\n            [defName]: sourceCode ? { source: sourceCode } : { path: path }\n          },\n          this\n        )\n        .then(defs => {\n          // what if defName does not match synthDefResult.name ?\n          let synthDefResult = defs[defName];\n          if (!synthDefResult) {\n            throw new Error(\n              `SynthDefResult not found ${defName} in compile return values`\n            );\n          }\n          return new SynthDef(this, defName, synthDefResult, sourceCode, path);\n        });\n    });\n  }\n\n  /**\n   * Load and compile a SynthDef from path and send it to the server.\n   */\n  loadSynthDef(defName: string, path: string): Promise<SynthDef> {\n    return this._compileSynthDef(defName, null, path);\n  }\n\n  /**\n   * Compile a SynthDef from supercollider source code and send it to the server.\n   */\n  synthDef(defName: string, sourceCode: string): Promise<SynthDef> {\n    return this._compileSynthDef(defName, sourceCode);\n  }\n\n  /**\n   * Allocate a Buffer on the server.\n   */\n  buffer(numFrames: number, numChannels: number = 1): Promise<Buffer> {\n    let id = this.state.allocBufferID(numChannels);\n    return this.callAndResponse(\n      msg.bufferAlloc(id, numFrames, numChannels)\n    ).then(() => new Buffer(this, id, numFrames, numChannels));\n  }\n\n  /**\n   * Allocate a Buffer on the server and load a sound file into it.\n   *\n   * Problem: scsynth uses however many channels there are in the sound file,\n   * but the client (sclang or supercolliderjs) doesn't know how many there are.\n   */\n  readBuffer(\n    path: string,\n    numChannels: number = 2,\n    startFrame: number = 0,\n    numFramesToRead: number = -1\n  ): Promise<Buffer> {\n    let id = this.state.allocBufferID(numChannels);\n    return this.callAndResponse(\n      msg.bufferAllocRead(id, path, startFrame, numFramesToRead)\n    ).then(() => new Buffer(this, id, numFramesToRead, numChannels));\n  }\n\n  /**\n   * Allocate an audio bus.\n   */\n  audioBus(numChannels: number = 1): AudioBus {\n    let id = this.state.allocAudioBus(numChannels);\n    return new AudioBus(this, id, numChannels);\n  }\n\n  /**\n   * Allocate a control bus.\n   */\n  controlBus(numChannels: number = 1): ControlBus {\n    let id = this.state.allocControlBus(numChannels);\n    return new ControlBus(this, id, numChannels);\n  }\n}\n\n/**\n * Start the scsynth server with options:\n *\n * ```js\n *   sc.server.boot({device: 'Soundflower (2ch)'}).then(server => {\n *     //\n *   });\n *\n *   sc.server.boot({serverPort: '11211'})\n * ```\n *\n * @memberof server\n *\n * @param {Object} options - Optional command line options for server\n * @param {Store} store - optional external Store to hold Server state\n * @returns {Promise} - resolves with a Server (ServerPlus actually)\n */\nexport function boot(\n  options: Object = {},\n  store: any = null\n): Promise<ServerPlus> {\n  return resolveOptions(undefined, options).then(opts => {\n    var s = new ServerPlus(opts, store);\n    return s.boot().then(() => s.connect()).then(() => s);\n  });\n}\n"]}
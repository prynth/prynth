'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.dryadic = dryadic;
exports.withContext = withContext;
exports.makeChildContext = makeChildContext;
exports.callAndResolve = callAndResolve;
exports.callAndResolveValues = callAndResolveValues;
exports.callAndResolveAll = callAndResolveAll;

var _underscore = require('underscore');

var _underscore2 = _interopRequireDefault(_underscore);

var _sideEffects = require('../server/internals/side-effects');

var _bluebird = require('bluebird');

var _Store = require('../server/internals/Store');

var _Store2 = _interopRequireDefault(_Store);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/* eslint no-console: 0 */
// deprecated

_bluebird.Promise.onPossiblyUnhandledRejection(function (error) {
  console.error(error);
  throw Error(error);
});

function dryadic(fn) {
  var requireSCSynth = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var requireSClang = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  return function (parentContext) {
    return withContext(parentContext, requireSCSynth, requireSClang).then(fn);
  };
}

/**
 * Create a context, inheriting from parentContext.
 *
 * @param {Object|undefined} parentContext
 * @param {Boolean} requireSCSynth - will boot server if required
 * @param {Boolean} requireSClang - will boot language interpreter if required
 */
function withContext(parentContext) {
  var requireSCSynth = arguments.length <= 1 || arguments[1] === undefined ? false : arguments[1];
  var requireSClang = arguments.length <= 2 || arguments[2] === undefined ? false : arguments[2];

  var context = _underscore2.default.assign({ id: '0' }, parentContext);
  if (!context.store) {
    context.store = new _Store2.default();
  }

  var deps = {};
  var options = {
    stdin: false,
    echo: true, // that will make it post OSC send/recv
    debug: false // post debug messages in code, including stdout off lang/synth
    // langPort
  };
  // deprec, but will replace this whole system soon
  if (requireSCSynth && !context.server) {
    deps.server = function () {
      return (0, _sideEffects.bootServer)(options, context.store);
    };
  }
  if (requireSClang && !context.lang) {
    deps.lang = function () {
      return (0, _sideEffects.bootLang)(options, context.store);
    };
  }
  return callAndResolveValues(deps, context).then(function (resolvedDeps) {
    if (resolvedDeps.server) {
      // set root node
      resolvedDeps.group = 0;
    }
    return _underscore2.default.extend(context, resolvedDeps);
  });
}

function makeChildContext(parentContext, keyName) {
  return _underscore2.default.assign({}, parentContext, { id: parentContext.id + '.' + keyName });
}

/**
 * If value is a function then call it,
 * if function returns a Promise then resolve it.
 */
function callAndResolve(value, context, keyName) {
  if (_underscore2.default.isFunction(value)) {
    value = value(makeChildContext(context, keyName || '_'));
  }
  return _bluebird.Promise.resolve(value);
}

/**
 * Call and resolve each of the values of an Object.
 *
 * @param {Object} object - whose values will be called and resolved
 * @param {Object} context - which is passed into any Functions
 * @returns {Promise} - resolves to an Object with values mapped to the resolved results
 */
function callAndResolveValues(object, context) {
  var keys = _underscore2.default.keys(object);
  if (_underscore2.default.isUndefined(context)) {
    throw new Error('Missing context for callAndResolveValues');
  }
  return _bluebird.Promise.map(keys, function (key, i) {
    return callAndResolve(object[key], context, i);
  }).then(function (values) {
    var result = {};
    keys.forEach(function (key, i) {
      result[key] = values[i];
    });
    return result;
  });
}

/**
 * Call and resolve each of the items in a list
 * @param {Array} things
 * @param {Object} parentContext
 * @returns {Promise} - resolves to an Array with the resolved things
 */
function callAndResolveAll(things, parentContext) {
  return _bluebird.Promise.map(things, function (thing, i) {
    return callAndResolve(thing, parentContext, i);
  });
}
//# sourceMappingURL=helpers.js.map
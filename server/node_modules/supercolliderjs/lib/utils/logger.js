'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/* eslint no-console: 0 */

var chalk = require('chalk');

var colors = {
  debug: 'gray',
  error: 'yellow',
  stdout: 'green',
  stderr: 'red',
  stdin: 'blue',
  sendosc: 'cyan',
  rcvosc: 'magenta'
};

/**
 * A customized logging interface for supercollider.js
 *
 * Has special colors for osc messages and for logging stdin/stdout traffic.
 *
 * @example
 *
 *     log = new Logger(true, true);
 *
 *     log.dbug('a message');
 *     log.err('oh no');
 *     log.stdin('command that I sent')
 *     log.stdout('output from server')
 *     log.stderr('error from server')
 *
 */

var Logger = function () {
  /**
   * @param {Boolean} debug - Post all debugging calls to log.
   *                        If false then only errors are posted.
   * @param {Boolean} echo - Echo stdin/stdout and osc traffic to console
   * @param {winston.Logger|undefined} log - Default is to use console.(log|error)
   *                                       but any object with a compatible API such
   *                                       as winston will work.
   */
  function Logger(debug, echo, log) {
    _classCallCheck(this, Logger);

    this.debug = debug;
    this.echo = echo;
    this.colorize = typeof log === 'undefined';
    this.log = log || console;
    this.browser = typeof window !== 'undefined';
  }

  /**
   * Log debugging information but only if this.debug is true
   */


  _createClass(Logger, [{
    key: 'dbug',
    value: function dbug(text) {
      if (this.debug) {
        this.print('debug  ', text, colors.debug);
      }
    }

    /**
     * Log an error.
     */

  }, {
    key: 'err',
    value: function err(text) {
      this.print('error  ', text, colors.error);
    }

    /**
     * Log messages that were sent to stdin or sclang.
     */

  }, {
    key: 'stdin',
    value: function stdin(text) {
      if (this.echo) {
        this.print('stdin  ', text, colors.stdin);
      }
    }

    /**
     * Log messages that were received from stdout of sclang/scsynth.
     */

  }, {
    key: 'stdout',
    value: function stdout(text) {
      if (this.echo) {
        this.print('stdout ', text, colors.stdout);
      }
    }

    /**
     * Log messages that were emitted from stderr of sclang/scsynth.
     */

  }, {
    key: 'stderr',
    value: function stderr(text) {
      if (this.echo) {
        this.print('stderr ', text, colors.stderr);
      }
    }

    /**
     * Log OSC messages sent to scsynth.
     */

  }, {
    key: 'sendosc',
    value: function sendosc(text) {
      if (this.echo) {
        this.print('sendosc', text, colors.sendosc);
      }
    }

    /**
     * Log OSC messages received from scsynth.
     */

  }, {
    key: 'rcvosc',
    value: function rcvosc(text) {
      if (this.echo) {
        this.print('rcvosc ', text, colors.rcvosc);
      }
    }

    /**
     * @private
     */

  }, {
    key: 'print',
    value: function print(label, text, color) {
      if (this.browser) {
        console.log('%c' + label, 'font-size: 10px; color:' + color, text);
      } else {
        // terminal
        if (typeof text !== 'string') {
          text = JSON.stringify(text, undefined, 2);
        }
        var lines = text.split('\n'),
            clean = [label + ': ' + lines[0]],
            rest = lines.slice(1).filter(function (s) {
          return s.length > 0;
        }).map(function (s) {
          return '           ' + s;
        });
        clean = clean.concat(rest).join('\n');
        if (this.colorize) {
          clean = chalk[color](clean);
        }

        switch (label.trim()) {
          case 'debug':
          case 'stdin':
          case 'sendosc':
          case 'rcvosc':
            this.log.info(clean);
            break;
          case 'stderr':
          case 'error':
            this.log.error(clean);
            break;
          default:
            this.log.info(clean);
        }
      }
    }
  }]);

  return Logger;
}();

exports.default = Logger;
//# sourceMappingURL=logger.js.map
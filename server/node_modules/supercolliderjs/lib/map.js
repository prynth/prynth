'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.midiToFreq = midiToFreq;
exports.freqToMidi = freqToMidi;
exports.linToLin = linToLin;
exports.linToExp = linToExp;
exports.expToLin = expToLin;
exports.ampToDb = ampToDb;
exports.dbToAmp = dbToAmp;
exports.linear = linear;
exports.exp = exp;
exports.dB = dB;
exports.fader = fader;
exports.unmapLinear = unmapLinear;
exports.unmapExp = unmapExp;
exports.unmapDb = unmapDb;
exports.unmapFader = unmapFader;
exports.unmapWithSpec = unmapWithSpec;
exports.mapWithSpec = mapWithSpec;
/**
 * Useful mapping functions from supercollider
 *  
 *  @module map
 */

/**
 * Convert a MIDI note (1..127) to frequency.
 */
function midiToFreq(midiNote) {
  return 440.0 * Math.pow(2, (midiNote - 69.0) / 12.0);
}

/**
 * Convert frequency to MIDI note (1..127).
 */
function freqToMidi(freq) {
  var mult = Math.log(freq / 400.0) / Math.log(2);
  return Math.round(12.0 * mult + 69);
}

/**
 * Map a number from linear min/max to min/max.
 */
function linToLin(inMin, inMax, outMin, outMax, value) {
  if (value <= inMin) {
    return outMin;
  }
  if (value >= inMax) {
    return outMax;
  }
  return (value - inMin) / (inMax - inMin) * (outMax - outMin) + outMin;
}

/**
* Map a number from linear min/max to exponential min/max.
 */
function linToExp(inMin, inMax, outMin, outMax, value) {
  if (value <= inMin) {
    return outMin;
  }
  if (value >= inMax) {
    return outMax;
  }
  return Math.pow(outMax / outMin, (value - inMin) / (inMax - inMin)) * outMin;
}

/**
* Map a number from exponential min/max to linear min/max.
 */
function expToLin(inMin, inMax, outMin, outMax, value) {
  if (value <= inMin) {
    return outMin;
  }
  if (value >= inMax) {
    return outMax;
  }
  return Math.pow(outMax / outMin, Math.log(value / inMin) / Math.log(inMax / inMin)) * outMin;
}

/**
 * Map an amplitude value (usually 0..1) to dB.
 */
function ampToDb(amp) {
  return Math.log10(amp) * 20.0;
}

/**
 * Map dB to an amplitude value that can be used as a multiplier.
 */
function dbToAmp(db) {
  return Math.pow(10.0, db * 0.05);
}

/**
 * Returns a function that maps 0..1 input to the spec's minval..maxval with a linear curve.
 */
function linear(spec) {
  var range = spec.maxval - spec.minval;
  return function (value) {
    return value * range + spec.minval;
  };
}

/**
 * Returns a function that maps 0..1 input to the spec's minval..maxval with an exponential curve. minval/maxval must not have oppositive signs -- ie. the output range must not cross zero.
 */
function exp(spec) {
  var ratio = spec.maxval / spec.minval;
  return function (value) {
    return Math.pow(ratio, value) * spec.minval;
  };
}

/**
 * Returns dB mapping function (DbFaderWarp)
 */
function dB(spec) {
  var minval = dbToAmp(spec.minval);
  var range = dbToAmp(spec.maxval) - minval;
  return function (value) {
    return ampToDb(Math.pow(value, 2) * range - minval);
  };
}

/**
 * Returns amp mapping function (FaderWarp)
 */
function fader(spec) {
  var range = spec.maxval - spec.minval;
  return function (value) {
    return Math.pow(value, 2) * range - spec.minval;
  };
}

/**
 * Returns inverse of linear mapping function
 */
function unmapLinear(spec) {
  var range = spec.maxval - spec.minval;
  return function (value) {
    return (value - spec.minval) / range;
  };
}

/**
 * Returns inverse of exponential mapping function
 */
function unmapExp(spec) {
  var ratio = Math.log(spec.maxval / spec.minval);
  return function (value) {
    return Math.log(value / spec.minval) / ratio;
  };
}

/**
 * Returns inverse of dB mapping function (DbFaderWarp)
 */
function unmapDb(spec) {
  var minval = dbToAmp(spec.minval);
  var range = dbToAmp(spec.maxval) - minval;
  return function (value) {
    return (dbToAmp(value) - minval) / Math.sqrt(range);
  };
}

/**
 * Returns inverse of amp mapping function (FaderWarp)
 */
function unmapFader(spec) {
  var range = spec.maxval - spec.minval;
  return function (value) {
    return Math.sqrt((value - spec.minval) / range);
  };
}

/**
 * Returns the inverse mapping function for a spec, using the curve
 * as defined by spec.warp
 */
function unmapWithSpec(value, spec) {
  switch (spec.warp) {
    case 'linear':
    case 'lin':
      return unmapLinear(spec)(value);
    case 'exp':
    case 'exponential':
      return unmapExp(spec)(value);
    case 'amp':
      return unmapFader(spec)(value);
    case 'db':
      return unmapDb(spec)(value);
    default:
      throw new Error('Warp unknown or not yet implemented' + spec.warp);
  }
}

/**
 * Returns the mapping function for a spec, using the curve
 * as defined by spec.warp
 */
function mapWithSpec(value, spec) {
  switch (spec.warp) {
    case 'linear':
    case 'lin':
      return linear(spec)(value);
    case 'exp':
    case 'exponential':
      return exp(spec)(value);
    case 'amp':
      return fader(spec)(value);
    case 'db':
      return dB(spec)(value);
    default:
      throw new Error('Warp unknown or not yet implemented' + spec.warp);
  }
}
//# sourceMappingURL=map.js.map
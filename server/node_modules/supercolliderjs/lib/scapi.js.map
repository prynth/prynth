{"version":3,"sources":["../src/scapi.js"],"names":["events","require","dgram","osc","cuid","_","Promise","SCAPI","schost","scport","requests","log","self","udp","createSocket","on","msgbuf","msg","fromBuffer","address","receive","e","emit","err","close","requestId","oscpath","args","ok","promise","resolve","reject","clientId","clumps","isUndefined","isString","sender","rid","oscArgs","buf","toBuffer","concat","send","length","err2","isNotOsc","a","isObject","isArray","some","JSON","stringify","match","each","clump","i","then","signal","value","result","request","parse","response","request_id","EventEmitter"],"mappings":"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","file":"scapi.js","sourcesContent":["/* jslint node: true */\n\nvar events = require('events'),\n  dgram = require('dgram'),\n  osc = require('osc-min'),\n  cuid = require('cuid'),\n  _ = require('lodash'),\n  Promise = require('bluebird');\n\nimport SCError from './Errors';\nimport Logger from './utils/logger';\n\n/*\n *\n *  Communicates via OSC with the SuperCollider API quark\n *\n *  The 'API' quark implements a two-way communication protocol.\n *  This nodejs code implements the other end of that communcation.\n *\n *  It connects with an sclang process using UDP OSC\n *  and then sends OSC messages to '/API/call'\n *\n *  Sent messages return a promise,\n *  the responses are received here from sclang\n *  and the promises are resolved\n *  (or rejected if there was an error).\n *\n *  Start SuperCollider\n *  Install the API quark ( > 2.0 )\n *  Activate the OSC responders in supercollider:\n *    API.mountDuplexOSC\n *\n *  See examples/call-api-from-node.js\n*/\nexport default class SCAPI extends events.EventEmitter {\n  constructor(schost, scport) {\n    super();\n    this.schost = schost ? schost : 'localhost';\n    this.scport = scport ? scport : 57120;\n    this.requests = {};\n    this.log = new Logger(true, false);\n  }\n\n  connect() {\n    var self = this;\n    this.udp = dgram.createSocket('udp4');\n\n    this.udp.on('message', function(msgbuf) {\n      var msg = osc.fromBuffer(msgbuf);\n      if (msg.address === '/API/reply') {\n        return self.receive('reply', msg);\n      }\n      return self.receive('scapi_error', msg);\n    });\n\n    this.udp.on('error', function(e) {\n      self.emit('error', e);\n      this.log.err('ERROR:' + e);\n    });\n  }\n\n  disconnect() {\n    if (this.udp) {\n      this.udp.close();\n      delete this.udp;\n    }\n  }\n\n  call(requestId, oscpath, args, ok, err) {\n    var promise = new Promise((resolve, reject) => {\n      var clientId = 0, // no longer needed\n        clumps,\n        self = this;\n\n      requestId = _.isUndefined(requestId) ? cuid() : requestId;\n      args = args ? args : [];\n      if (!_.isString(oscpath)) {\n        self.log.err('Bad oscpath' + oscpath);\n        throw 'Bad oscpath' + oscpath;\n      }\n\n      function sender(rid, oscArgs) {\n        var buf = osc.toBuffer({\n          address: '/API/call',\n          args: [clientId, rid, oscpath].concat(oscArgs)\n        });\n        self.udp.send(\n          buf,\n          0,\n          buf.length,\n          self.scport,\n          self.schost,\n          function(err2) {\n            // this will get DNS errors\n            // but not packet-too-big errors\n            if (err2) {\n              self.log.err(err2);\n            }\n          }\n        );\n      }\n\n      this.requests[requestId] = { resolve: resolve, reject: reject };\n\n      function isNotOsc(a) {\n        // if any arg is an object or array\n        // or a large string then pass the args as JSON\n        // in multiple calls\n        return _.isObject(a) ||\n          _.isArray(a) ||\n          (_.isString(a) && a.length > 7168);\n      }\n\n      if (_.some(args, isNotOsc)) {\n        clumps = JSON.stringify(args).match(/.{1,7168}/g);\n        _.each(clumps, function(clump, i) {\n          var rid = '' + (i + 1) + ',' + clumps.length + ':' + requestId;\n          sender(rid, [clump]);\n        });\n      } else {\n        sender(requestId, args);\n      }\n    });\n    if (ok) {\n      return promise.then(ok, err);\n    } else {\n      return promise;\n    }\n  }\n\n  receive(signal, msg) {\n    var // clientId = msg.args[0].value,\n    requestId = msg.args[1].value,\n      result = msg.args[2].value,\n      request = this.requests[requestId];\n    if (!request) {\n      this.emit('error', 'Unknown request ' + requestId);\n      this.log.err('Unknown request ' + requestId);\n      return;\n    }\n\n    // reply or scapi_error\n    if (signal === 'reply') {\n      try {\n        result = JSON.parse(result);\n        result = result.result;\n      } catch (e) {\n        result = 'MALFORMED JSON RESPONSE:' + result;\n        this.log.err(result);\n        signal = 'scapi_error';\n      }\n    }\n\n    var response = {\n      signal: signal,\n      request_id: requestId,\n      result: result\n    };\n\n    if (signal === 'reply') {\n      request.resolve(response);\n    } else {\n      request.reject(new SCError('API Error response', response));\n    }\n    delete this.requests[requestId];\n  }\n}\n"]}
'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = hyperscript;

var _isObject = require('lodash/isObject');

var _isObject2 = _interopRequireDefault(_isObject);

var _isArray = require('lodash/isArray');

var _isArray2 = _interopRequireDefault(_isArray);

var _isString = require('lodash/isString');

var _isString2 = _interopRequireDefault(_isString);

var _mapValues = require('lodash/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

/**
 * Convert a JSON object into a tree of instantiated Dryads.
 *
 * A Domain-specific language for easily creating Dryad trees
 * a la: https://github.com/Raynos/virtual-hyperscript
 *
 * This is used for sending tree documents from remote clients,
 * and for writing dryadic documents in JSON form without having to
 * import classes and construct trees filled with `new Object()` etc.
 *
 * className, properties:
 * ['synth', {freq: 440}]

 * className, properties, children:
 * ['audiobus', {numChannels: 2}, [
 *   ['synth', {defName: 'saw', args: {freq: 440}]
 * ]]

 * If there are only 2 items and the second is an Array (not Object),
 * then parse it as:
 *
 * className, children:
 *
 *  ['group', [
 *    ['synth', {freq: 440}]
 *  ]]
 *
 * If a property value is of the form [string, object] or [string, object, array] then assume it is
 * a dryad.
 *
 * ['synth', {
 *    'freq': ['synth', {'defName': 'lfo', 'freq': 0.3}]
 * }]
 *
 * @param {Array|Dryad} root - The Array is the top level (root) dryad form.
 *                           If a Dryad is supplied then no conversion is needed so it is returned immediately.
 * @param {Function} lookupClassByNameFn
 *        This function is provided by the DryadPlayer and converts strings into
 *        Dryad classes. It should throw an error if no Dryad class exists by that name.
 * @returns {Dryad} - the root Dryad
 */
function hyperscript(root, lookupClassByNameFn) {
  if (!root) {
    die(root, 'Got null|undefined.');
  }

  // if the thing implements isDryad then the answer must be yes.
  if (root.isDryad) {
    return root;
  }

  if (!(0, _isArray2.default)(root)) {
    die(root, 'Expected Array.');
  }

  var _root = _slicedToArray(root, 3),
      tag = _root[0],
      properties = _root[1],
      children = _root[2];

  if (!tag) {
    die(root, 'Null tag');
  }

  if (!((0, _isString2.default)(tag) || tag.isDryadSubclass)) {
    die(root, 'Expected tag to be string');
  }

  if (children) {
    if (!(0, _isObject2.default)(properties)) {
      die(root, 'Expected properties to be an Object');
    }
    if (!(0, _isArray2.default)(children)) {
      die(root, 'Expected children to be an Array');
    }
  } else {
    // If 2nd arg is an array then it is the children and there are no properties.
    if ((0, _isArray2.default)(properties)) {
      children = properties;
      properties = {};
    } else {
      if (properties && !(0, _isObject2.default)(properties)) {
        die(root, 'Expected properties to be an Object');
      }
    }
  }

  // Convert any property value that looks like a hyperscript form to a Dryad
  properties = (0, _mapValues2.default)(properties || {}, function (value) {
    return isDryadForm(value) ? hyperscript(value, lookupClassByNameFn) : value;
  });

  // Convert children
  var childNodes = (children || []).map(function (child) {
    return hyperscript(child, lookupClassByNameFn);
  });

  // If the thing implements isDryadSubclass then the answer must be yes.
  // its a static method on Dryad
  var DryadClass = tag.isDryadSubclass ? tag : lookupClassByNameFn(tag);
  return new DryadClass(properties, childNodes);
}

function isDryadForm(value) {
  return (0, _isArray2.default)(value) && value.length <= 3 && (0, _isString2.default)(value[0]) && (0, _isObject2.default)(value[1]);
}

function die(root, message) {
  throw new Error('Bad argument to hyperscript: [' + (typeof root === 'undefined' ? 'undefined' : _typeof(root)) + '] ' + root + ' ' + message);
}
//# sourceMappingURL=hyperscript.js.map
{"version":3,"sources":["../src/CommandNode.js"],"names":["SELF_THEN_CHILDREN","PROPERTIES_MODE","CALL_ORDER","CommandNode","commands","context","properties","id","children","value","stateTransitionName","middlewares","updateContext","execSelf","execute","call","child","callOrder","all","concat","map","then","slice","Error","callFuncs","calls","middleware","state","error","message","reject"],"mappings":"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","file":"CommandNode.js","sourcesContent":["/* @flow */\nimport isFunction from 'lodash/isFunction';\nimport { Promise } from 'bluebird';\nimport { mapProperties } from './utils';\n\nexport const SELF_THEN_CHILDREN = 'SELF_THEN_CHILDREN';\nexport const PROPERTIES_MODE = 'PROPERTIES_MODE';\nexport const CALL_ORDER = {\n  SELF_THEN_CHILDREN: SELF_THEN_CHILDREN,\n  PROPERTIES_MODE: PROPERTIES_MODE\n};\n\nexport default class CommandNode {\n  commands: Object;\n  context: Object;\n  properties: Object;\n  id: string;\n  children: Array<CommandNode>;\n\n  constructor(\n    commands: Object,\n    context: Object,\n    properties: Object,\n    id: string,\n    children: Array<CommandNode> = []\n  ) {\n    this.commands = commands;\n    this.context = context;\n    this.properties = properties;\n    this.id = id;\n    this.children = children;\n  }\n\n  callFuncs(): Object {\n    return mapProperties(\n      this.properties,\n      (value: any): any => (isFunction(value) ? value(this.context) : value)\n    );\n  }\n\n  /**\n   * Execute this CommandNode and call it's children.\n   *\n   * By default this executes and it's children in parallel.\n   * Each child would also by default execute it's own children\n   * in parallel, so the entire command tree will execute in\n   * parallel and resolve when the last straggler resolves.\n   *\n   * But there are many cases where you wish to block and\n   * complete execution before progressing down the tree.\n   * eg. booting a server before communicating with it.\n   *\n   * So a Dryad may pass a callOrder flag in the commands to\n   * specify one of several modes of blocking.\n   *\n   *   {\n   *     callOrder: CALL_ORDER.SELF_THEN_CHILDREN\n   *   }\n   *\n   * The modes are:\n   *\n   * SELF_THEN_CHILDREN - First execute this, when it resolves\n   * then call the children (in parallel).\n   * This is useful if the Dryad is something like booting a\n   * process that the children will need to call communicate with.\n   * Wait until the process is booted before proceeding.\n   *\n   * PROPERTIES_MODE - Special case for dryads in properties.\n   * The children of Properties are:\n   *\n   *    [dryadicProperty1, dryadicProperty2 ... PropertiesOwner].\n   *\n   * So this mode specifies that each of the dryadicProperties\n   * needs to complete before proceeding to the PropertiesOwner.\n   *\n   * Default is this and children in parallel.\n   */\n  call(\n    stateTransitionName: string,\n    middlewares: Array<Function>,\n    updateContext: Function\n  ): Promise<*> {\n    // console.log('CommandNode.call', stateTransitionName, this.context.id, this.commands, this.commands.callOrder || 'parallel');\n\n    const execSelf = this.execute(\n      stateTransitionName,\n      middlewares,\n      updateContext\n    );\n    const call = child =>\n      child.call(stateTransitionName, middlewares, updateContext);\n\n    if (!this.commands.callOrder) {\n      return Promise.all([execSelf].concat(this.children.map(call)));\n    }\n\n    switch (this.commands.callOrder) {\n      case SELF_THEN_CHILDREN:\n        return execSelf.then(() => {\n          // TODO: remove this return and the tests should fail\n          return Promise.all(this.children.map(call));\n        });\n      case PROPERTIES_MODE:\n        return execSelf.then(() => {\n          // the properties dryads\n          return Promise.all(this.children.slice(0, -1).map(call)).then(() =>\n            call(this.children.slice(-1)[0])\n          );\n        });\n      default:\n        throw new Error(\n          `callOrder mode not recognized: ${this.commands.callOrder}`\n        );\n    }\n  }\n\n  /**\n   * Execute this CommandNode's commands\n   */\n  execute(\n    stateTransitionName: string,\n    middlewares: Array<Function>,\n    updateContext: Function\n  ): Promise<*> {\n    let properties = this.callFuncs();\n    const calls = middlewares.map((middleware: Function) => {\n      return middleware(this.commands, this.context, properties, updateContext);\n    });\n\n    return Promise.all(calls).then(\n      () => {\n        updateContext(this.context, { state: { [stateTransitionName]: true } });\n      },\n      (error: Error) => {\n        // log error\n        updateContext(this.context, {\n          state: { [stateTransitionName]: false, error }\n        });\n        error.message = `${error.message} in ${this.context.id}`;\n        return Promise.reject(error);\n      }\n    );\n  }\n}\n"]}
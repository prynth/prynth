'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.CALL_ORDER = exports.PROPERTIES_MODE = exports.SELF_THEN_CHILDREN = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _bluebird = require('bluebird');

var _utils = require('./utils');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var SELF_THEN_CHILDREN = exports.SELF_THEN_CHILDREN = 'SELF_THEN_CHILDREN';
var PROPERTIES_MODE = exports.PROPERTIES_MODE = 'PROPERTIES_MODE';
var CALL_ORDER = exports.CALL_ORDER = {
  SELF_THEN_CHILDREN: SELF_THEN_CHILDREN,
  PROPERTIES_MODE: PROPERTIES_MODE
};

var CommandNode = function () {
  function CommandNode(commands, context, properties, id) {
    var children = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : [];

    _classCallCheck(this, CommandNode);

    this.commands = commands;
    this.context = context;
    this.properties = properties;
    this.id = id;
    this.children = children;
  }

  _createClass(CommandNode, [{
    key: 'callFuncs',
    value: function callFuncs() {
      var _this = this;

      return (0, _utils.mapProperties)(this.properties, function (value) {
        return (0, _isFunction2.default)(value) ? value(_this.context) : value;
      });
    }

    /**
     * Execute this CommandNode and call it's children.
     *
     * By default this executes and it's children in parallel.
     * Each child would also by default execute it's own children
     * in parallel, so the entire command tree will execute in
     * parallel and resolve when the last straggler resolves.
     *
     * But there are many cases where you wish to block and
     * complete execution before progressing down the tree.
     * eg. booting a server before communicating with it.
     *
     * So a Dryad may pass a callOrder flag in the commands to
     * specify one of several modes of blocking.
     *
     *   {
     *     callOrder: CALL_ORDER.SELF_THEN_CHILDREN
     *   }
     *
     * The modes are:
     *
     * SELF_THEN_CHILDREN - First execute this, when it resolves
     * then call the children (in parallel).
     * This is useful if the Dryad is something like booting a
     * process that the children will need to call communicate with.
     * Wait until the process is booted before proceeding.
     *
     * PROPERTIES_MODE - Special case for dryads in properties.
     * The children of Properties are:
     *
     *    [dryadicProperty1, dryadicProperty2 ... PropertiesOwner].
     *
     * So this mode specifies that each of the dryadicProperties
     * needs to complete before proceeding to the PropertiesOwner.
     *
     * Default is this and children in parallel.
     */

  }, {
    key: 'call',
    value: function call(stateTransitionName, middlewares, updateContext) {
      var _this2 = this;

      // console.log('CommandNode.call', stateTransitionName, this.context.id, this.commands, this.commands.callOrder || 'parallel');

      var execSelf = this.execute(stateTransitionName, middlewares, updateContext);
      var call = function call(child) {
        return child.call(stateTransitionName, middlewares, updateContext);
      };

      if (!this.commands.callOrder) {
        return _bluebird.Promise.all([execSelf].concat(this.children.map(call)));
      }

      switch (this.commands.callOrder) {
        case SELF_THEN_CHILDREN:
          return execSelf.then(function () {
            // TODO: remove this return and the tests should fail
            return _bluebird.Promise.all(_this2.children.map(call));
          });
        case PROPERTIES_MODE:
          return execSelf.then(function () {
            // the properties dryads
            return _bluebird.Promise.all(_this2.children.slice(0, -1).map(call)).then(function () {
              return call(_this2.children.slice(-1)[0]);
            });
          });
        default:
          throw new Error('callOrder mode not recognized: ' + this.commands.callOrder);
      }
    }

    /**
     * Execute this CommandNode's commands
     */

  }, {
    key: 'execute',
    value: function execute(stateTransitionName, middlewares, updateContext) {
      var _this3 = this;

      var properties = this.callFuncs();
      var calls = middlewares.map(function (middleware) {
        return middleware(_this3.commands, _this3.context, properties, updateContext);
      });

      return _bluebird.Promise.all(calls).then(function () {
        updateContext(_this3.context, { state: _defineProperty({}, stateTransitionName, true) });
      }, function (error) {
        var _state2;

        // log error
        updateContext(_this3.context, {
          state: (_state2 = {}, _defineProperty(_state2, stateTransitionName, false), _defineProperty(_state2, 'error', error), _state2)
        });
        error.message = error.message + ' in ' + _this3.context.id;
        return _bluebird.Promise.reject(error);
      });
    }
  }]);

  return CommandNode;
}();

exports.default = CommandNode;
//# sourceMappingURL=CommandNode.js.map
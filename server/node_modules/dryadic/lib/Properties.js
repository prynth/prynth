'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PropertiesOwner = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

exports.invertDryadicProperties = invertDryadicProperties;

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

var _Dryad3 = require('./Dryad');

var _Dryad4 = _interopRequireDefault(_Dryad3);

var _utils = require('./utils');

var _CommandNode = require('./CommandNode');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }
/**
 * If a Dryad has Dryads in it's properties then bring then transform the playgraph.
 *
 * So this:
 *
 *  Synth({
 *    def: SCSynthDef(...)
 *  })
 *
 * is transformed to this in the playgraph:
 *
 *  Properties({}, [
 *    SCSynthDef(...),
 *    PropertiesOwner({...}, [
 *      Synth({def: accessorFunction})
 *    ])
 *  ]);
 *
 * Now the SCSynthDef is in the playgraph ahead of the Synth and can prepare and
 * compile what it needs to before the Synth needs to use the result.
 */


/**
 * Parent wrapper whose children are the properties and the PropertiesOwner as siblings.
 */
var Properties = function (_Dryad) {
  _inherits(Properties, _Dryad);

  function Properties() {
    _classCallCheck(this, Properties);

    return _possibleConstructorReturn(this, (Properties.__proto__ || Object.getPrototypeOf(Properties)).apply(this, arguments));
  }

  _createClass(Properties, [{
    key: 'prepareForAdd',
    value: function prepareForAdd() {
      return {
        callOrder: _CommandNode.PROPERTIES_MODE
      };
    }
  }]);

  return Properties;
}(_Dryad4.default);

/**
 * Object that holds the owner - the Dryad that had Dryads in it's .properties
 */


exports.default = Properties;

var PropertiesOwner = exports.PropertiesOwner = function (_Dryad2) {
  _inherits(PropertiesOwner, _Dryad2);

  function PropertiesOwner() {
    _classCallCheck(this, PropertiesOwner);

    return _possibleConstructorReturn(this, (PropertiesOwner.__proto__ || Object.getPrototypeOf(PropertiesOwner)).apply(this, arguments));
  }

  _createClass(PropertiesOwner, [{
    key: 'prepareForAdd',
    value: function prepareForAdd(player) {
      var _this3 = this;

      return {
        callOrder: _CommandNode.SELF_THEN_CHILDREN,
        updateContext: function updateContext(context) {
          return {
            propertiesValues: _this3.properties.indices.map(function (i) {
              // x.y.z.props.{$context.id} -> x.y.z.props.{$i}
              var propDryadId = context.id.replace(/\.([0-9]+)$/, '.' + i);
              var propDryad = player.tree.dryads[propDryadId];
              var propContext = player.tree.contexts[propDryadId];
              var value = propDryad.value(propContext);
              return value;
            })
          };
        }
      };
    }
  }]);

  return PropertiesOwner;
}(_Dryad4.default);

/**
 * If a Dryad contains Dryads in it's properties then return a Properties
 * that inverts the play graph so those dryadic properties come first.
 *
 * Returns a Properties or undefined if there are no Dryads in the properties.
 */


function invertDryadicProperties(dryad) {
  var ci = -1;
  var children = [];
  var indices = [];

  var cname = (0, _utils.className)(dryad);
  // never
  if (cname === 'Properties' || cname === 'PropertiesOwner') {
    return;
  }

  /**
   * Map the properties to functions that will retrieve the dryad's 'value'.
   */
  var propertyAccessors = (0, _utils.mapProperties)(dryad.properties, function (value) {
    if ((0, _utils.isDryad)(value)) {
      ci = ci + 1;
      var childIndex = ci;
      // It must implement .value
      // if (!isFunction(value.value)) {
      //   throw new Error(`${value} does not implement .value; cannot use this as a .property`);
      // }

      children.push(cloneValue(value));
      indices.push(ci);

      // Here there must be propertiesValues as set by PropertiesOwner
      // in prepareForAdd. that is the direct parent of this (actual owner)
      return function (context) {
        if (!context.propertiesValues) {
          throw new Error('Missing propertiesValues from context ' + context.id);
        }
        return context.propertiesValues[childIndex];
      };
    } else {
      return value;
    }
  });

  // There were no Dryads in .properties
  if (ci < 0) {
    return;
  }

  var owner = new dryad.constructor(propertyAccessors, dryad.children.map(cloneValue));
  children.push(new PropertiesOwner({ indices: indices }, [owner]));

  return new Properties({}, children);
}

function cloneValue(value) {
  return (0, _utils.isDryad)(value) ? value.clone() : (0, _clone2.default)(value);
}
//# sourceMappingURL=Properties.js.map
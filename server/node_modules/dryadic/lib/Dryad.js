'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assign = require('lodash/assign');

var _assign2 = _interopRequireDefault(_assign);

var _clone2 = require('lodash/clone');

var _clone3 = _interopRequireDefault(_clone2);

var _mapValues = require('lodash/mapValues');

var _mapValues2 = _interopRequireDefault(_mapValues);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * >> A dryad (/ˈdraɪ.æd/; Greek: Δρυάδες, sing.: Δρυάς) is a tree nymph, or female tree spirit, in Greek mythology
 *
 * A Dryad is a component for managing the creation and control of something.
 *
 * For instance that 'something' could be a SuperCollider Synth, or a MIDI connection, SVG or Canvas in a webrowser,
 * a datasource, a web resource to fetch or an external process.
 *
 * It is anything that you want to specify parameters for and then create according to those parameters.
 *
 * Dryads have properties and children but do not hold any internal state.
 * Their methods are passed a context object and they perform their functionality
 * based on their properties (what they are supposed to be / to do) and the context
 * which holds the state, temporary variables they need for operation (like supercollider node ids) and gives them access to variables defined by parent nodes in the play graph.
 *
 * They provide functionality by return command objects which are processed by
 * command middleware which is supplied by various Dryadic packages.
 */

var Dryad = function () {

  /**
   * Subclasses should not implement constructor.
   * All Dryad classes take properties and children.
   */
  function Dryad() {
    var properties = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var children = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

    _classCallCheck(this, Dryad);

    this.properties = (0, _assign2.default)({}, this.defaultProperties(), properties || {});
    this.children = children || [];
  }

  /**
   * Defaults properties if none are supplied
   */


  _createClass(Dryad, [{
    key: 'defaultProperties',
    value: function defaultProperties() {
      return {};
    }

    /**
     * Returns a command object that specifies actions that need to be completed
     * before the Dryad's resource is able to play.
     *
     * The most useful command to use here is `updateContext` which when called
     * will allocate resources, start up servers etc. and then save handles,
     * pids, node ids etc. into the context for use by .add()
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'prepareForAdd',
    value: function prepareForAdd(player) {
      return {};
    }

    /**
     * Add the Dryad, make it play, make it start etc.
     *
     * Returns a command object or a function that is called with node context and will return a command object.
     *
     * Middleware supplied by layers will match command keys and will be passed the value.
     * Value is either an object that the middleware uses to do whatever it does (launch things, send messages) or is a function that take context and returns the object.
     *
     * Command middleware for add may return Promises which resolve on success; ie. when the thing is successfully booted, running etc.
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'add',
    value: function add(player) {
      return {};
    }

    /**
     * Remove the Dryad, make it stop etc.
     *
     * Returns a command object or a function that is called with node context and will return a command object.
     *
     * Middleware supplied by layers will match command keys and will be passed the value.
     * Value is either an object that the middleware uses to do whatever it does (launch things, send messages) or is a function that take context and returns the object.
     *
     * Command middleware for run may return Promises which resolve on success; ie. when the thing is successfully stopped, remove etc.
     */
    // eslint-disable-next-line no-unused-vars

  }, {
    key: 'remove',
    value: function remove(player) {
      return {};
    }

    /**
     * Dryad classes may return a subgraph of Dryads to replace itself
     * in the play graph.
     * This lets Dryads compose more complex behavior, add other Dryads that
     * assist. Any Dryads supplied in properties should be included in the subgraph.
     *
     * The subgraph may also contain the Dryad itself in which case its .add .remove
     * will be called. If subgraph is implemented but it does not include itself then
     * .add / .remove will not be called.
     */

  }, {
    key: 'subgraph',
    value: function subgraph() {}

    /**
     * When Dryad requires a parent Dryad to be somewhere above it then it
     * may be specified by its class name here and the parent will be injected
     * into the playgraph. This is similar to subgraph() but make it easy to
     * do and is less error prone.
     *
     * Example: SCSynthDef compiles SynthDefs from source code and requires a supercollider SCLang interpreter as a parent to do that compilation. If there is not already an SCLang in the play graph then include one.
     *
     * @returns {String|undefined} - class name of required parent Dryad
     */

  }, {
    key: 'requireParent',
    value: function requireParent() {}

    /**
     * Initial context
     *
     * This dryad's context is also the parent object for all children.
     */

  }, {
    key: 'initialContext',
    value: function initialContext() {
      return {};
    }

    /**
     * Context for child; used when creating initial context for a node
     *
     * Note that the child already inherits from this context.
     * This is for setting things that should be in the child context
     * and not in the parent context. ie. Things that shadow values in the parent.
     */

  }, {
    key: 'childContext',
    value: function childContext() {
      return {};
    }

    /**
     * This method is never actually called, but merely because its implemented
     * (dryad.isDryad is not undefined) it marks the things as being a Dryad.
     *
     * @returns {Boolean}
     */

  }, {
    key: 'value',


    /**
     * When Dryads are used a properties for other Dryads,
     * they should implement .value to return whatever information
     * the parent Dryad needs from them.
     */
    value: function value() {
      throw new Error('Subclass responsibility: ' + this.constructor.name + ' should implement \'value()\'');
    }
  }, {
    key: 'clone',
    value: function clone() {
      var dup = new this.constructor();
      var cloneValue = function cloneValue(c) {
        return c && c.isDryad ? c.clone() : (0, _clone3.default)(c);
      };
      dup.properties = (0, _mapValues2.default)(this.properties, cloneValue);
      dup.children = this.children.map(cloneValue);
      return dup;
    }
  }, {
    key: 'isDryad',
    get: function get() {
      return true;
    }

    /**
     * This method is never actually called, but merely because its implemented
     * (MyDryad.isDryadSubclass is not undefined) it marks the thing as being a Dryad subclass.
     *
     * @returns {Boolean}
     */

  }], [{
    key: 'isDryadSubclass',
    value: function isDryadSubclass() {
      return true;
    }
  }]);

  return Dryad;
}();

exports.default = Dryad;
//# sourceMappingURL=Dryad.js.map
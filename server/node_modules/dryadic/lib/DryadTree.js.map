{"version":3,"sources":["../src/DryadTree.js"],"names":["DryadTree","rootDryad","getClass","rootContext","root","dryads","contexts","nodeLookUp","Map","tree","_makeTree","walk","node","set","id","fn","memo","children","forEach","child","stateTransitionName","player","dryad","context","commands","prepareForAdd","add","remove","Error","error","log","properties","map","collectCommands","nodeId","value","dryadId","update","formatState","s","JSON","stringify","dbug","state","hasOwnProperty","undefined","r","class","constructor","name","length","asH","parentId","cc","initialContext","parent","parentContext","childContext","childIndex","isDryad","seenTypes","slice","skipRequireParentOf","rq","requireParent","st","requiredParent","propertiesDryad","_createContext","makeSubgraph","subgraph","dr","subMemo","skipSubgraphOf","Array","isArray","dryadType","push","TreeNode","i"],"mappings":"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","file":"DryadTree.js","sourcesContent":["/* @flow */\nimport assign from 'lodash/assign';\nimport clone from 'lodash/clone';\nimport create from 'lodash/create';\nimport find from 'lodash/find';\nimport isFunction from 'lodash/isFunction';\n\nimport { invertDryadicProperties } from './Properties';\nimport { mapProperties, className } from './utils';\nimport CommandNode from './CommandNode';\nimport type Dryad from './Dryad';\nimport type DryadPlayer from './DryadPlayer';\n\n/**\n * Manages the tree structure, contexts for nodes,\n * utilities to walk the tree, collect commands and\n * call command middleware.\n */\nexport default class DryadTree {\n  root: ?Dryad;\n  tree: ?TreeNode;\n  dryads: { [id: string]: Dryad };\n  contexts: { [id: string]: Object };\n  getClass: Function;\n  rootContext: Object;\n  nodeLookUp: Map<string, TreeNode>;\n\n  /**\n   * @param {Dryad} rootDryad\n   * @param {Function} getClass - lookup function\n   */\n  constructor(rootDryad: ?Dryad, getClass: Function, rootContext: Object = {}) {\n    this.root = rootDryad;\n    this.dryads = {};\n    this.contexts = {};\n    this.getClass = getClass;\n    this.rootContext = rootContext;\n    // keep a flat lookup table\n    this.nodeLookUp = new Map();\n    // tree structure\n    if (this.root) {\n      this.tree = this._makeTree(this.root);\n      this.walk((node: TreeNode) => this.nodeLookUp.set(node.id, node));\n    }\n  }\n\n  /**\n   * Depth first traversal of the Dryad tree\n   *\n   * The function is given arguments:\n   *   node {id type children}\n   *   Dryad\n   *   context\n   *   memo\n   *\n   * @param {Function} fn - called with (dryad, context, node)\n   * @param {TreeNode} node - starting node, defaults to the root\n   * @param {Object} memo - for usage during recursion\n   */\n  walk(fn: Function, node: ?TreeNode, memo: Object = {}): Object {\n    if (!node) {\n      node = this.tree;\n    }\n\n    if (node) {\n      memo = fn(node, this.dryads[node.id], this.contexts[node.id], memo);\n      node.children.forEach((child: TreeNode) => {\n        memo = this.walk(fn, child, memo);\n      });\n    }\n\n    return memo;\n  }\n\n  /**\n   * Collect a tree of command objects from each node for a given method.\n   * eg. 'add' 'remove' 'prepareForAdd'\n   *\n   * @param {String} stateTransitionName\n   * @param {TreeNode} node - default is the root\n   * @returns {CommandNode}\n   */\n  collectCommands(\n    stateTransitionName: string,\n    node: TreeNode,\n    player: DryadPlayer\n  ): CommandNode {\n    let dryad = this.dryads[node.id];\n    let context = this.contexts[node.id];\n\n    let commands: ?Object;\n    try {\n      switch (stateTransitionName) {\n        case 'prepareForAdd':\n          commands = dryad.prepareForAdd(player);\n          break;\n        case 'add':\n          commands = dryad.add(player);\n          break;\n        case 'remove':\n          commands = dryad.remove(player);\n          break;\n        // case 'callCommands'\n        default:\n          throw new Error(`Unsupported command ${stateTransitionName}`);\n      }\n    } catch (error) {\n      player.log\n        .log(`Error during collectCommands \"${stateTransitionName}\" for node:\\n`);\n      player.log.log(node);\n      throw error;\n    }\n\n    return new CommandNode(\n      commands,\n      context,\n      dryad.properties,\n      node.id,\n      node.children.map(child =>\n        this.collectCommands(stateTransitionName, child, player)\n      )\n    );\n  }\n\n  /**\n   * Construct a command tree for a single commandObject to be executed\n   * with a single node's context.\n   *\n   * This is for runtime execution of commands,\n   * called from streams and async processes initiated during Dryad's .add()\n   */\n  makeCommandTree(nodeId: string, commands: Object): Object {\n    return new CommandNode(\n      commands,\n      this.contexts[nodeId],\n      this.dryads[nodeId].properties,\n      nodeId,\n      []\n    );\n  }\n\n  /**\n   * For any properties that are functions, call them with context to get the 'value'.\n   * These converted/resolved values are passed into the commands at prepareForAdd/add etc.\n   */\n  dryadProperties(nodeId: string): Object {\n    let dryad = this.dryads[nodeId];\n    let context = this.contexts[nodeId];\n    // invertDryadicProperties replaces Dryads in properties with these accessor functions\n    return mapProperties(dryad.properties, (value): any => {\n      return isFunction(value) ? value(context) : value;\n    });\n  }\n\n  /**\n   * Update a Dryad's context.\n   *\n   * @param {String} dryadId\n   * @param {Object} update - values to assign into context\n   * @returns {Object} context\n   */\n  updateContext(dryadId: string, update: Object): Object {\n    return assign(this.contexts[dryadId], update);\n  }\n\n  getContext(dryadId: string): Object {\n    return this.contexts[dryadId];\n  }\n\n  /**\n   * Get a representation of current state of the tree.\n   * Contains add|remove|prepared and may hold errors.\n   */\n  getDebugState(): Object {\n    const formatState = s => {\n      if (!s) {\n        return s;\n      }\n\n      if (s.error) {\n        return `ERROR: ${s.error}`;\n      }\n\n      if (s.add) {\n        return 'running';\n      }\n\n      if (s.remove) {\n        return 'removed';\n      }\n\n      if (s.prepareForAdd) {\n        return 'prepared';\n      }\n\n      return `Unknown: ${JSON.stringify(s)}`;\n    };\n\n    const dbug = node => {\n      let context = this.contexts[node.id];\n      let state = context.hasOwnProperty('state') ? context.state : undefined;\n      let r = {\n        id: node.id,\n        class: this.dryads[node.id].constructor.name,\n        state: formatState(state)\n        // circular references, cannot print\n        // context: JSON.stringify(this.contexts[node.id], null, 2)\n      };\n      if (node.children.length) {\n        r = assign(r, { children: node.children.map(dbug) });\n      }\n      return r;\n    };\n\n    if (this.tree) {\n      return dbug(this.tree);\n    } else {\n      return {};\n    }\n  }\n\n  /**\n   * Return the current play graph as a hyperscript document.\n   * Useful for testing and debugging.\n   */\n  hyperscript(): ?Array<mixed> {\n    function asH(node) {\n      let dryad = node.dryad;\n      return [\n        className(dryad),\n        dryad.properties, // may contain accessor functions\n        node.children.map(asH)\n      ];\n    }\n\n    if (this.tree) {\n      return asH(this.tree);\n    }\n  }\n\n  /**\n   * Create and return initial context for a Dryad.\n   *\n   * Each context has the parent's context as its prototype,\n   * so parent values are visible to children.\n   *\n   * @returns {Object}\n   */\n  _createContext(\n    dryad: Dryad,\n    dryadId: string,\n    parentId: ?string,\n    rootContext: Object = {}\n  ): Object {\n    let cc = assign({ id: dryadId }, rootContext, dryad.initialContext());\n    if (parentId) {\n      let parent = this.dryads[parentId];\n      // In the case of a Properties at the top level, there is no existing parent although there was a parentId of '0'\n      // passed in.\n      let parentContext = this.contexts[parentId];\n      if (parentContext) {\n        let childContext = parent.childContext(parentContext);\n        return create(parentContext, assign(childContext, cc));\n      }\n    }\n    return cc;\n  }\n\n  /**\n   * Creates the expanded play graph as a tree of TreeNodes.\n   *\n   * It is called initially with the root Dryad, then recursively for each child down the tree.\n   *\n   * - Generates ids for each Dryad\n   * - Creates a context for each, storing in this.contexts\n   *\n   * Each node in the tree contains a TreeNode\n   *\n   * Dryad classes may use requireParent() and subgraph() to replace themselves\n   * with a different graph.\n   *\n   * So this tree is not a direct mapping of the input graph, it is the expanded play graph.\n   *\n   * This method calls itself recursively for children.\n   *\n   * @param {Dryad} dryad\n   * @param {String} parentId\n   * @param {Integer} childIndex\n   * @param {Object} memo - for internal usage during recursion\n   * @returns {Object}\n   */\n  _makeTree(\n    dryad: Dryad,\n    parentId: ?string,\n    childIndex: number | string = 0,\n    memo: Object = {}\n  ): TreeNode {\n    if (!dryad.isDryad) {\n      throw new Error('Not a Dryad: ${dryad}');\n    }\n\n    // Copy seenTypes, pass it to your children\n    // Each branch sees a different descendent list\n    memo.seenTypes = memo.seenTypes ? memo.seenTypes.slice() : [];\n\n    if (memo.skipRequireParentOf === dryad) {\n      delete memo.skipRequireParentOf;\n    } else {\n      let rq = dryad.requireParent();\n      if (rq) {\n        if (!find(memo.seenTypes, st => st === rq)) {\n          // fetch the parent class from dryadTypes registery by name\n          if (!this.getClass) {\n            throw new Error(\n              'A getClass lookup was not provided to DryadTree and ' +\n                dryad.constructor.name +\n                ' needs one for requireParent()'\n            );\n          }\n          let requiredParent: Dryad = new (this.getClass(rq))({}, [dryad]);\n          memo.skipRequireParentOf = dryad;\n          return this._makeTree(requiredParent, parentId, childIndex, memo);\n        }\n      }\n    }\n\n    let id = parentId ? parentId + '.' + childIndex : '0';\n\n    // If any properties are Dryads then clone them into a Properties\n    // dryad with this dryad as it's downstream child. This puts them\n    // higher up in the play graph.\n    let propertiesDryad = invertDryadicProperties(dryad);\n    if (propertiesDryad) {\n      return this._makeTree(\n        propertiesDryad,\n        parentId,\n        `${childIndex}.props`,\n        memo\n      );\n    }\n\n    let context = this._createContext(dryad, id, parentId, this.rootContext);\n    this.dryads[id] = dryad;\n    this.contexts[id] = context;\n\n    let makeSubgraph = dr => {\n      let subgraph = dr.subgraph();\n      if (subgraph) {\n        let subMemo = clone(memo);\n        // When and if this dryad appears in its own subgraph\n        // then do not call subgraph() on that. It will just\n        // do prepare/add/remove on its own self.\n        subMemo.skipSubgraphOf = dryad;\n        // if its an array then should have been supplied in a Branch\n        if (Array.isArray(subgraph)) {\n          throw new Error(\n            'Dryad subgraph should return a single Dryad with children. ${dr} ${subgraph}'\n          );\n        }\n\n        return this._makeTree(subgraph, id, 'subgraph', subMemo);\n      }\n    };\n\n    if (memo.skipSubgraphOf) {\n      if (memo.skipSubgraphOf === dryad) {\n        // may still be subgraph children to come\n        delete memo.skipSubgraphOf;\n      } else {\n        let subgraph = makeSubgraph(dryad);\n        if (subgraph) {\n          return subgraph;\n        }\n      }\n    } else {\n      let subgraph = makeSubgraph(dryad);\n      if (subgraph) {\n        return subgraph;\n      }\n    }\n\n    let dryadType = dryad.constructor.name;\n    memo.seenTypes.push(dryadType);\n\n    return new TreeNode(\n      id,\n      dryad,\n      dryadType,\n      dryad.children.map((child, i) => {\n        return this._makeTree(child, id, i, memo);\n      })\n    );\n  }\n}\n\nclass TreeNode {\n  id: string;\n  dryad: Dryad;\n  dryadType: string;\n  children: Array<TreeNode>;\n\n  constructor(id, dryad, dryadType, children) {\n    this.id = id;\n    this.dryad = dryad;\n    this.dryadType = dryadType;\n    this.children = children;\n  }\n}\n"]}
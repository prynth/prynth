{"version":3,"sources":["../src/Dryad.js"],"names":["Dryad","properties","children","defaultProperties","player","Error","constructor","name","dup","cloneValue","c","isDryad","clone","map"],"mappings":";;;;;;;;AACA;;;;AACA;;;;AACA;;;;;;;;AAGA;;;;;;;;;;;;;;;;;;;IAmBqBA,K;;AAInB;;;;AAIA,mBAAkE;AAAA,QAAtDC,UAAsD,uEAAjC,EAAiC;AAAA,QAA7BC,QAA6B,uEAAJ,EAAI;;AAAA;;AAChE,SAAKD,UAAL,GAAkB,sBAAO,EAAP,EAAW,KAAKE,iBAAL,EAAX,EAAqCF,cAAc,EAAnD,CAAlB;AACA,SAAKC,QAAL,GAAgBA,YAAY,EAA5B;AACD;;AAED;;;;;;;wCAG4B;AAC1B,aAAO,EAAP;AACD;;AAED;;;;;;;;AAQA;;;;kCACcE,M,EAA6B;AACzC,aAAO,EAAP;AACD;;AAED;;;;;;;;;;AAUA;;;;wBACIA,M,EAA6B;AAC/B,aAAO,EAAP;AACD;;AAED;;;;;;;;;;AAUA;;;;2BACOA,M,EAA6B;AAClC,aAAO,EAAP;AACD;;AAED;;;;;;;;;;;;;+BAUmB,CAAE;;AAErB;;;;;;;;;;;;;oCAUyB,CAAE;;AAE3B;;;;;;;;qCAKyB;AACvB,aAAO,EAAP;AACD;;AAED;;;;;;;;;;mCAOuB;AACrB,aAAO,EAAP;AACD;;AAED;;;;;;;;;;;AAoBA;;;;;4BAK+B;AAC7B,YAAM,IAAIC,KAAJ,+BACwB,KAAKC,WAAL,CAAiBC,IADzC,mCAAN;AAGD;;;4BAEc;AACb,UAAIC,MAAM,IAAI,KAAKF,WAAT,EAAV;AACA,UAAIG,aAAa,SAAbA,UAAa,CAACC,CAAD;AAAA,eAAkBA,KAAKA,EAAEC,OAAP,GAAiBD,EAAEE,KAAF,EAAjB,GAA6B,qBAAMF,CAAN,CAA/C;AAAA,OAAjB;AACAF,UAAIP,UAAJ,GAAiB,yBAAU,KAAKA,UAAf,EAA2BQ,UAA3B,CAAjB;AACAD,UAAIN,QAAJ,GAAe,KAAKA,QAAL,CAAcW,GAAd,CAAkBJ,UAAlB,CAAf;AACA,aAAOD,GAAP;AACD;;;wBA/BsB;AACrB,aAAO,IAAP;AACD;;AAED;;;;;;;;;sCAMkC;AAChC,aAAO,IAAP;AACD;;;;;;kBA7HkBR,K","file":"Dryad.js","sourcesContent":["/* @flow */\nimport assign from 'lodash/assign';\nimport clone from 'lodash/clone';\nimport mapValues from 'lodash/mapValues';\nimport type DryadPlayer from './DryadPlayer';\n\n/**\n * >> A dryad (/ˈdraɪ.æd/; Greek: Δρυάδες, sing.: Δρυάς) is a tree nymph, or female tree spirit, in Greek mythology\n *\n * A Dryad is a component for managing the creation and control of something.\n *\n * For instance that 'something' could be a SuperCollider Synth, or a MIDI connection, SVG or Canvas in a webrowser,\n * a datasource, a web resource to fetch or an external process.\n *\n * It is anything that you want to specify parameters for and then create according to those parameters.\n *\n * Dryads have properties and children but do not hold any internal state.\n * Their methods are passed a context object and they perform their functionality\n * based on their properties (what they are supposed to be / to do) and the context\n * which holds the state, temporary variables they need for operation (like supercollider node ids) and gives them access to variables defined by parent nodes in the play graph.\n *\n * They provide functionality by return command objects which are processed by\n * command middleware which is supplied by various Dryadic packages.\n */\n\nexport default class Dryad {\n  properties: Object;\n  children: Array<Dryad>;\n\n  /**\n   * Subclasses should not implement constructor.\n   * All Dryad classes take properties and children.\n   */\n  constructor(properties: Object = {}, children: Array<Dryad> = []) {\n    this.properties = assign({}, this.defaultProperties(), properties || {});\n    this.children = children || [];\n  }\n\n  /**\n   * Defaults properties if none are supplied\n   */\n  defaultProperties(): Object {\n    return {};\n  }\n\n  /**\n   * Returns a command object that specifies actions that need to be completed\n   * before the Dryad's resource is able to play.\n   *\n   * The most useful command to use here is `updateContext` which when called\n   * will allocate resources, start up servers etc. and then save handles,\n   * pids, node ids etc. into the context for use by .add()\n   */\n  // eslint-disable-next-line no-unused-vars\n  prepareForAdd(player: DryadPlayer): Object {\n    return {};\n  }\n\n  /**\n   * Add the Dryad, make it play, make it start etc.\n   *\n   * Returns a command object or a function that is called with node context and will return a command object.\n   *\n   * Middleware supplied by layers will match command keys and will be passed the value.\n   * Value is either an object that the middleware uses to do whatever it does (launch things, send messages) or is a function that take context and returns the object.\n   *\n   * Command middleware for add may return Promises which resolve on success; ie. when the thing is successfully booted, running etc.\n   */\n  // eslint-disable-next-line no-unused-vars\n  add(player: DryadPlayer): Object {\n    return {};\n  }\n\n  /**\n   * Remove the Dryad, make it stop etc.\n   *\n   * Returns a command object or a function that is called with node context and will return a command object.\n   *\n   * Middleware supplied by layers will match command keys and will be passed the value.\n   * Value is either an object that the middleware uses to do whatever it does (launch things, send messages) or is a function that take context and returns the object.\n   *\n   * Command middleware for run may return Promises which resolve on success; ie. when the thing is successfully stopped, remove etc.\n   */\n  // eslint-disable-next-line no-unused-vars\n  remove(player: DryadPlayer): Object {\n    return {};\n  }\n\n  /**\n   * Dryad classes may return a subgraph of Dryads to replace itself\n   * in the play graph.\n   * This lets Dryads compose more complex behavior, add other Dryads that\n   * assist. Any Dryads supplied in properties should be included in the subgraph.\n   *\n   * The subgraph may also contain the Dryad itself in which case its .add .remove\n   * will be called. If subgraph is implemented but it does not include itself then\n   * .add / .remove will not be called.\n   */\n  subgraph(): ?Dryad {}\n\n  /**\n   * When Dryad requires a parent Dryad to be somewhere above it then it\n   * may be specified by its class name here and the parent will be injected\n   * into the playgraph. This is similar to subgraph() but make it easy to\n   * do and is less error prone.\n   *\n   * Example: SCSynthDef compiles SynthDefs from source code and requires a supercollider SCLang interpreter as a parent to do that compilation. If there is not already an SCLang in the play graph then include one.\n   *\n   * @returns {String|undefined} - class name of required parent Dryad\n   */\n  requireParent(): ?string {}\n\n  /**\n   * Initial context\n   *\n   * This dryad's context is also the parent object for all children.\n   */\n  initialContext(): Object {\n    return {};\n  }\n\n  /**\n   * Context for child; used when creating initial context for a node\n   *\n   * Note that the child already inherits from this context.\n   * This is for setting things that should be in the child context\n   * and not in the parent context. ie. Things that shadow values in the parent.\n   */\n  childContext(): Object {\n    return {};\n  }\n\n  /**\n   * This method is never actually called, but merely because its implemented\n   * (dryad.isDryad is not undefined) it marks the things as being a Dryad.\n   *\n   * @returns {Boolean}\n   */\n  get isDryad(): boolean {\n    return true;\n  }\n\n  /**\n   * This method is never actually called, but merely because its implemented\n   * (MyDryad.isDryadSubclass is not undefined) it marks the thing as being a Dryad subclass.\n   *\n   * @returns {Boolean}\n   */\n  static isDryadSubclass(): boolean {\n    return true;\n  }\n\n  /**\n   * When Dryads are used a properties for other Dryads,\n   * they should implement .value to return whatever information\n   * the parent Dryad needs from them.\n   */\n  value(/*context:Object*/): any {\n    throw new Error(\n      `Subclass responsibility: ${this.constructor.name} should implement 'value()'`\n    );\n  }\n\n  clone(): Dryad {\n    let dup = new this.constructor();\n    let cloneValue = (c: any): any => (c && c.isDryad ? c.clone() : clone(c));\n    dup.properties = mapValues(this.properties, cloneValue);\n    dup.children = this.children.map(cloneValue);\n    return dup;\n  }\n}\n"]}
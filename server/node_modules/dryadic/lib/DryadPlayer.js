'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _bind = require('lodash/bind');

var _bind2 = _interopRequireDefault(_bind);

var _DryadTree = require('./DryadTree');

var _DryadTree2 = _interopRequireDefault(_DryadTree);

var _CommandMiddleware = require('./CommandMiddleware');

var _CommandMiddleware2 = _interopRequireDefault(_CommandMiddleware);

var _CommandNode = require('./CommandNode');

var _CommandNode2 = _interopRequireDefault(_CommandNode);

var _bluebird = require('bluebird');

var _hyperscript = require('./hyperscript');

var _hyperscript2 = _interopRequireDefault(_hyperscript);

var _updateContext = require('./updateContext');

var _updateContext2 = _interopRequireDefault(_updateContext);

var _run = require('./run');

var _run2 = _interopRequireDefault(_run);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Manages play/stop/update for a Dryad tree.
 *
 * A Dryad has no state or functionality until it is played
 * by a DryadPlayer. A Dryad can be played more than once at
 * the same time by creating more DryadPlayers.
 *
 * The DryadPlayer also holds the layers and command middleware
 * which execute the functionality that the Dryads specify.
 */
var DryadPlayer = function () {
  function DryadPlayer(rootDryad, layers) {
    var _this = this;

    var rootContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, DryadPlayer);

    this.middleware = new _CommandMiddleware2.default([_updateContext2.default, _run2.default]);
    this.classes = {};
    if (layers) {
      layers.forEach(function (layer) {
        return _this.use(layer);
      });
    }

    if (!rootContext.log) {
      rootContext.log = console;
    }

    this.log = rootContext.log;

    // default logger
    this._errorLogger = function (msg, error) {
      _this.log.error(msg, error, error.stack);
      _this.dump();
      // and emit error event
    };

    this.setRoot(rootDryad, rootContext);
  }

  /**
   * Set a new tree.
   *
   * Behavior while already playing is not yet defined.
   *
   * @param {Dryad} dryad
   */


  _createClass(DryadPlayer, [{
    key: 'setRoot',
    value: function setRoot(dryad) {
      var rootContext = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      var classLookup = (0, _bind2.default)(this.getClass, this);
      this.tree = new _DryadTree2.default(dryad ? this.h(dryad) : null, classLookup, rootContext);
    }

    /**
     * Convert hyperscript graph to Dryad objects with registered classes
     *
     * @param {Object} hgraph - JSON style object
     * @returns {Dryad}
     */

  }, {
    key: 'h',
    value: function h(hgraph) {
      var classLookup = (0, _bind2.default)(this.getClass, this);
      return (0, _hyperscript2.default)(hgraph, classLookup);
    }

    /**
     * Add a layer of functionality by registering Dryad classes and command middleware.
     *
     * @param {Object} layer - .classes is a list of Dryad classes, .middleware is a list of middleware functions
     */

  }, {
    key: 'use',
    value: function use(layer) {
      var _this2 = this;

      this.middleware.use(layer.middleware || []);
      (layer.classes || []).forEach(function (c) {
        return _this2.addClass(c);
      });
      return this;
    }

    /**
     * Register a Dryad class so it can be located when used in hyperscript.
     * Also needed if a class uses requireParent()
     *
     * @param {Dryad} dryadClass
     */

  }, {
    key: 'addClass',
    value: function addClass(dryadClass) {
      this.classes[dryadClass.name.toLowerCase()] = dryadClass;
    }

    /**
     * Lookup Dryad class by name.
     *
     * Used by hyperscript and requireParent, this requires
     * that layers and their classes were registered and any custom
     * classes that you right are registered. If you aren't using
     * hyperscript then you don't need to register your class.
     * @param {String} className - case-insensitive
     * @returns {Dryad}
     */

  }, {
    key: 'getClass',
    value: function getClass(className) {
      var dryadClass = this.classes[className.toLowerCase()];
      if (!dryadClass) {
        throw new Error('Dryad class not found: \'' + className + '\' in classes: ' + Object.keys(this.classes).join(', '));
      }
      return dryadClass;
    }

    /**
     * Prepare Dryads in document for play.
     *
     * This allocates resources and performs any time consuming async work
     * required before the Dryads may play.
     *
     * Prepare commands may fail by rejecting their Promises.
     * Unable to allocate resource, required executables do not exist etc.
     *
     * .play commands should not fail
     *
     */

  }, {
    key: 'prepare',
    value: function prepare() {
      return this.call('prepareForAdd');
    }

    /**
     * Prepares and plays the current document.
     *
     * Optionally updates to a new document.
     *
     * @returns {Promise} - that resolves to `this`
     */

  }, {
    key: 'play',
    value: function play(dryad) {
      var _this3 = this;

      if (dryad) {
        this.setRoot(dryad);
      }

      return this.prepare().then(function () {
        return _this3.call('add');
      }).then(function () {
        return _this3;
      }, function (error) {
        // Log the error but continue the Promise chain
        _this3._errorLogger('Failed to play', error);
        return _bluebird.Promise.reject(error);
      });
    }

    /**
     * @returns {Promise} - that resolves to `this`
     */

  }, {
    key: 'stop',
    value: function stop() {
      var _this4 = this;

      return this.call('remove').then(function () {
        return _this4;
      }, function (error) {
        _this4._errorLogger('Failed to stop', error);
        return _bluebird.Promise.reject(error);
      });
    }
  }, {
    key: '_collectCommands',
    value: function _collectCommands(commandName) {
      if (this.tree && this.tree.tree) {
        return this.tree.collectCommands(commandName, this.tree.tree, this);
      }
      // no-op
      return new _CommandNode2.default({}, {}, {}, '', []);
    }

    /**
     * Collect commands and call for a transition: add|remove|prepareForAdd
     */

  }, {
    key: 'call',
    value: function call(stateTransitionName) {
      var _this5 = this;

      var cmdTree = this._collectCommands(stateTransitionName);
      return this._call(cmdTree, stateTransitionName).then(function () {
        return _this5;
      });
    }

    /**
     * Execute a command tree using middleware.
     */

  }, {
    key: '_call',
    value: function _call(commandTree, stateTransitionName) {
      var _this6 = this;

      return this.middleware.call(commandTree, stateTransitionName, function (context, update) {
        return _this6.tree.updateContext(context.id, update);
      });
    }

    /**
     * Execute a single command object for a single node using middleware
     * outside the prepareForAdd/add/remove full tree command execution routine.
     *
     * This can be called out of band from a Dryad's add/remove method
     *
     * Its for commands that need to be executed during runtime
     * in response to events, streams etc.
     * eg. spawning synths from an incoming stream of data.
     */

  }, {
    key: 'callCommand',
    value: function callCommand(nodeId, command) {
      return this._call(this.tree.makeCommandTree(nodeId, command), 'callCommand');
    }

    /**
     * updateContext - Allow a Dryad to update its own context.
     *
     * This can be called during runtime by event handlers,
     * updates via stream etc. when you need to save new values into the context
     * outside of the add/remove/update functions.
     *
     * Contexts are immutable - this returns a new context object.
     *
     * @param  {Object} context to update
     * @param  {Object} update  updated variables
     * @return {Object}         new context object
     */

  }, {
    key: 'updateContext',
    value: function updateContext(context, update) {
      return this.tree.updateContext(context.id, update);
    }

    /**
     * Get a representation of current state of the tree.
     * Contains add|remove|prepared and may hold errors.
     */

  }, {
    key: 'getDebugState',
    value: function getDebugState() {
      return this.tree.getDebugState();
    }

    /**
     * Get hyperscript representation of current (expanded) play graph
     */

  }, {
    key: 'getPlayGraph',
    value: function getPlayGraph() {
      return this.tree.hyperscript();
    }
  }, {
    key: 'dump',
    value: function dump() {
      // TODO: get a better one
      function replacer(key, value) {
        if (typeof value === 'function') {
          return String(value);
        }
        return value;
      }

      this.log.info(JSON.stringify(this.getPlayGraph(), replacer, 2));
      this.log.error(JSON.stringify(this.getDebugState(), replacer, 2));
    }
  }]);

  return DryadPlayer;
}();

exports.default = DryadPlayer;
//# sourceMappingURL=DryadPlayer.js.map
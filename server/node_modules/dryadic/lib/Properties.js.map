{"version":3,"sources":["../src/Properties.js"],"names":["invertDryadicProperties","Properties","callOrder","PropertiesOwner","player","updateContext","context","propertiesValues","properties","indices","map","i","propDryadId","id","replace","propDryad","tree","dryads","propContext","contexts","value","dryad","ci","children","cname","propertyAccessors","childIndex","push","cloneValue","Error","owner","constructor","clone"],"mappings":";;;;;;;;;QAoEgBA,uB,GAAAA,uB;;AA9ChB;;;;AACA;;;;AACA;;AAEA;;;;;;;;;AAzBA;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;IAGqBC,U;;;;;;;;;;;oCACK;AACtB,aAAO;AACLC;AADK,OAAP;AAGD;;;;;;AAGH;;;;;kBARqBD,U;;IAWRE,e,WAAAA,e;;;;;;;;;;;kCACGC,M,EAAqB;AAAA;;AACjC,aAAO;AACLF,kDADK;AAELG,uBAAe,uBAACC,OAAD,EAAqB;AAClC,iBAAO;AACLC,8BAAkB,OAAKC,UAAL,CAAgBC,OAAhB,CAAwBC,GAAxB,CAA4B,UAACC,CAAD,EAAY;AACxD;AACA,kBAAIC,cAAcN,QAAQO,EAAR,CAAWC,OAAX,CAAmB,aAAnB,QAAsCH,CAAtC,CAAlB;AACA,kBAAII,YAAYX,OAAOY,IAAP,CAAYC,MAAZ,CAAmBL,WAAnB,CAAhB;AACA,kBAAIM,cAAcd,OAAOY,IAAP,CAAYG,QAAZ,CAAqBP,WAArB,CAAlB;AACA,kBAAIQ,QAAQL,UAAUK,KAAV,CAAgBF,WAAhB,CAAZ;AACA,qBAAOE,KAAP;AACD,aAPiB;AADb,WAAP;AAUD;AAbI,OAAP;AAeD;;;;;;AAGH;;;;;;;;AAMO,SAASpB,uBAAT,CAAiCqB,KAAjC,EAA4D;AACjE,MAAIC,KAAK,CAAC,CAAV;AACA,MAAIC,WAAW,EAAf;AACA,MAAId,UAAU,EAAd;;AAEA,MAAIe,QAAQ,sBAAUH,KAAV,CAAZ;AACA;AACA,MAAIG,UAAU,YAAV,IAA0BA,UAAU,iBAAxC,EAA2D;AACzD;AACD;;AAED;;;AAGA,MAAIC,oBAAoB,0BAAcJ,MAAMb,UAApB,EAAgC,iBAAS;AAC/D,QAAI,oBAAQY,KAAR,CAAJ,EAAoB;AAClBE,WAAKA,KAAK,CAAV;AACA,UAAII,aAAaJ,EAAjB;AACA;AACA;AACA;AACA;;AAEAC,eAASI,IAAT,CAAcC,WAAWR,KAAX,CAAd;AACAX,cAAQkB,IAAR,CAAaL,EAAb;;AAEA;AACA;AACA,aAAO,UAAChB,OAAD,EAA0B;AAC/B,YAAI,CAACA,QAAQC,gBAAb,EAA+B;AAC7B,gBAAM,IAAIsB,KAAJ,4CACqCvB,QAAQO,EAD7C,CAAN;AAGD;AACD,eAAOP,QAAQC,gBAAR,CAAyBmB,UAAzB,CAAP;AACD,OAPD;AAQD,KArBD,MAqBO;AACL,aAAON,KAAP;AACD;AACF,GAzBuB,CAAxB;;AA2BA;AACA,MAAIE,KAAK,CAAT,EAAY;AACV;AACD;;AAED,MAAIQ,QAAQ,IAAIT,MAAMU,WAAV,CACVN,iBADU,EAEVJ,MAAME,QAAN,CAAeb,GAAf,CAAmBkB,UAAnB,CAFU,CAAZ;AAIAL,WAASI,IAAT,CAAc,IAAIxB,eAAJ,CAAoB,EAAEM,gBAAF,EAApB,EAAiC,CAACqB,KAAD,CAAjC,CAAd;;AAEA,SAAO,IAAI7B,UAAJ,CAAe,EAAf,EAAmBsB,QAAnB,CAAP;AACD;;AAED,SAASK,UAAT,CAAoBR,KAApB,EAAqC;AACnC,SAAO,oBAAQA,KAAR,IAAiBA,MAAMY,KAAN,EAAjB,GAAiC,qBAAMZ,KAAN,CAAxC;AACD","file":"Properties.js","sourcesContent":["/* @flow */\n/**\n * If a Dryad has Dryads in it's properties then bring then transform the playgraph.\n *\n * So this:\n *\n *  Synth({\n *    def: SCSynthDef(...)\n *  })\n *\n * is transformed to this in the playgraph:\n *\n *  Properties({}, [\n *    SCSynthDef(...),\n *    PropertiesOwner({...}, [\n *      Synth({def: accessorFunction})\n *    ])\n *  ]);\n *\n * Now the SCSynthDef is in the playgraph ahead of the Synth and can prepare and\n * compile what it needs to before the Synth needs to use the result.\n */\nimport clone from 'lodash/clone';\nimport Dryad from './Dryad';\nimport { mapProperties, isDryad, className } from './utils';\nimport type DryadPlayer from './DryadPlayer';\nimport { PROPERTIES_MODE, SELF_THEN_CHILDREN } from './CommandNode';\n\n/**\n * Parent wrapper whose children are the properties and the PropertiesOwner as siblings.\n */\nexport default class Properties extends Dryad {\n  prepareForAdd(): Object {\n    return {\n      callOrder: PROPERTIES_MODE\n    };\n  }\n}\n\n/**\n * Object that holds the owner - the Dryad that had Dryads in it's .properties\n */\nexport class PropertiesOwner extends Dryad {\n  prepareForAdd(player: DryadPlayer) {\n    return {\n      callOrder: SELF_THEN_CHILDREN,\n      updateContext: (context: Object) => {\n        return {\n          propertiesValues: this.properties.indices.map((i): any => {\n            // x.y.z.props.{$context.id} -> x.y.z.props.{$i}\n            let propDryadId = context.id.replace(/\\.([0-9]+)$/, `.${i}`);\n            let propDryad = player.tree.dryads[propDryadId];\n            let propContext = player.tree.contexts[propDryadId];\n            let value = propDryad.value(propContext);\n            return value;\n          })\n        };\n      }\n    };\n  }\n}\n\n/**\n * If a Dryad contains Dryads in it's properties then return a Properties\n * that inverts the play graph so those dryadic properties come first.\n *\n * Returns a Properties or undefined if there are no Dryads in the properties.\n */\nexport function invertDryadicProperties(dryad: Dryad): ?Properties {\n  let ci = -1;\n  let children = [];\n  let indices = [];\n\n  let cname = className(dryad);\n  // never\n  if (cname === 'Properties' || cname === 'PropertiesOwner') {\n    return;\n  }\n\n  /**\n   * Map the properties to functions that will retrieve the dryad's 'value'.\n   */\n  let propertyAccessors = mapProperties(dryad.properties, value => {\n    if (isDryad(value)) {\n      ci = ci + 1;\n      let childIndex = ci;\n      // It must implement .value\n      // if (!isFunction(value.value)) {\n      //   throw new Error(`${value} does not implement .value; cannot use this as a .property`);\n      // }\n\n      children.push(cloneValue(value));\n      indices.push(ci);\n\n      // Here there must be propertiesValues as set by PropertiesOwner\n      // in prepareForAdd. that is the direct parent of this (actual owner)\n      return (context: Object): any => {\n        if (!context.propertiesValues) {\n          throw new Error(\n            `Missing propertiesValues from context ${context.id}`\n          );\n        }\n        return context.propertiesValues[childIndex];\n      };\n    } else {\n      return value;\n    }\n  });\n\n  // There were no Dryads in .properties\n  if (ci < 0) {\n    return;\n  }\n\n  let owner = new dryad.constructor(\n    propertyAccessors,\n    dryad.children.map(cloneValue)\n  );\n  children.push(new PropertiesOwner({ indices }, [owner]));\n\n  return new Properties({}, children);\n}\n\nfunction cloneValue(value: any): any {\n  return isDryad(value) ? value.clone() : clone(value);\n}\n"]}
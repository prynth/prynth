'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _assign = require('lodash/assign');

var _assign2 = _interopRequireDefault(_assign);

var _clone = require('lodash/clone');

var _clone2 = _interopRequireDefault(_clone);

var _create = require('lodash/create');

var _create2 = _interopRequireDefault(_create);

var _find = require('lodash/find');

var _find2 = _interopRequireDefault(_find);

var _isFunction = require('lodash/isFunction');

var _isFunction2 = _interopRequireDefault(_isFunction);

var _Properties = require('./Properties');

var _utils = require('./utils');

var _CommandNode = require('./CommandNode');

var _CommandNode2 = _interopRequireDefault(_CommandNode);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Manages the tree structure, contexts for nodes,
 * utilities to walk the tree, collect commands and
 * call command middleware.
 */
var DryadTree = function () {

  /**
   * @param {Dryad} rootDryad
   * @param {Function} getClass - lookup function
   */
  function DryadTree(rootDryad, getClass) {
    var _this = this;

    var rootContext = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    _classCallCheck(this, DryadTree);

    this.root = rootDryad;
    this.dryads = {};
    this.contexts = {};
    this.getClass = getClass;
    this.rootContext = rootContext;
    // keep a flat lookup table
    this.nodeLookUp = new Map();
    // tree structure
    if (this.root) {
      this.tree = this._makeTree(this.root);
      this.walk(function (node) {
        return _this.nodeLookUp.set(node.id, node);
      });
    }
  }

  /**
   * Depth first traversal of the Dryad tree
   *
   * The function is given arguments:
   *   node {id type children}
   *   Dryad
   *   context
   *   memo
   *
   * @param {Function} fn - called with (dryad, context, node)
   * @param {TreeNode} node - starting node, defaults to the root
   * @param {Object} memo - for usage during recursion
   */


  _createClass(DryadTree, [{
    key: 'walk',
    value: function walk(fn, node) {
      var _this2 = this;

      var memo = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

      if (!node) {
        node = this.tree;
      }

      if (node) {
        memo = fn(node, this.dryads[node.id], this.contexts[node.id], memo);
        node.children.forEach(function (child) {
          memo = _this2.walk(fn, child, memo);
        });
      }

      return memo;
    }

    /**
     * Collect a tree of command objects from each node for a given method.
     * eg. 'add' 'remove' 'prepareForAdd'
     *
     * @param {String} stateTransitionName
     * @param {TreeNode} node - default is the root
     * @returns {CommandNode}
     */

  }, {
    key: 'collectCommands',
    value: function collectCommands(stateTransitionName, node, player) {
      var _this3 = this;

      var dryad = this.dryads[node.id];
      var context = this.contexts[node.id];

      var commands = void 0;
      try {
        switch (stateTransitionName) {
          case 'prepareForAdd':
            commands = dryad.prepareForAdd(player);
            break;
          case 'add':
            commands = dryad.add(player);
            break;
          case 'remove':
            commands = dryad.remove(player);
            break;
          // case 'callCommands'
          default:
            throw new Error('Unsupported command ' + stateTransitionName);
        }
      } catch (error) {
        player.log.log('Error during collectCommands "' + stateTransitionName + '" for node:\n');
        player.log.log(node);
        throw error;
      }

      return new _CommandNode2.default(commands, context, dryad.properties, node.id, node.children.map(function (child) {
        return _this3.collectCommands(stateTransitionName, child, player);
      }));
    }

    /**
     * Construct a command tree for a single commandObject to be executed
     * with a single node's context.
     *
     * This is for runtime execution of commands,
     * called from streams and async processes initiated during Dryad's .add()
     */

  }, {
    key: 'makeCommandTree',
    value: function makeCommandTree(nodeId, commands) {
      return new _CommandNode2.default(commands, this.contexts[nodeId], this.dryads[nodeId].properties, nodeId, []);
    }

    /**
     * For any properties that are functions, call them with context to get the 'value'.
     * These converted/resolved values are passed into the commands at prepareForAdd/add etc.
     */

  }, {
    key: 'dryadProperties',
    value: function dryadProperties(nodeId) {
      var dryad = this.dryads[nodeId];
      var context = this.contexts[nodeId];
      // invertDryadicProperties replaces Dryads in properties with these accessor functions
      return (0, _utils.mapProperties)(dryad.properties, function (value) {
        return (0, _isFunction2.default)(value) ? value(context) : value;
      });
    }

    /**
     * Update a Dryad's context.
     *
     * @param {String} dryadId
     * @param {Object} update - values to assign into context
     * @returns {Object} context
     */

  }, {
    key: 'updateContext',
    value: function updateContext(dryadId, update) {
      return (0, _assign2.default)(this.contexts[dryadId], update);
    }
  }, {
    key: 'getContext',
    value: function getContext(dryadId) {
      return this.contexts[dryadId];
    }

    /**
     * Get a representation of current state of the tree.
     * Contains add|remove|prepared and may hold errors.
     */

  }, {
    key: 'getDebugState',
    value: function getDebugState() {
      var _this4 = this;

      var formatState = function formatState(s) {
        if (!s) {
          return s;
        }

        if (s.error) {
          return 'ERROR: ' + s.error;
        }

        if (s.add) {
          return 'running';
        }

        if (s.remove) {
          return 'removed';
        }

        if (s.prepareForAdd) {
          return 'prepared';
        }

        return 'Unknown: ' + JSON.stringify(s);
      };

      var dbug = function dbug(node) {
        var context = _this4.contexts[node.id];
        var state = context.hasOwnProperty('state') ? context.state : undefined;
        var r = {
          id: node.id,
          class: _this4.dryads[node.id].constructor.name,
          state: formatState(state)
          // circular references, cannot print
          // context: JSON.stringify(this.contexts[node.id], null, 2)
        };
        if (node.children.length) {
          r = (0, _assign2.default)(r, { children: node.children.map(dbug) });
        }
        return r;
      };

      if (this.tree) {
        return dbug(this.tree);
      } else {
        return {};
      }
    }

    /**
     * Return the current play graph as a hyperscript document.
     * Useful for testing and debugging.
     */

  }, {
    key: 'hyperscript',
    value: function hyperscript() {
      function asH(node) {
        var dryad = node.dryad;
        return [(0, _utils.className)(dryad), dryad.properties, // may contain accessor functions
        node.children.map(asH)];
      }

      if (this.tree) {
        return asH(this.tree);
      }
    }

    /**
     * Create and return initial context for a Dryad.
     *
     * Each context has the parent's context as its prototype,
     * so parent values are visible to children.
     *
     * @returns {Object}
     */

  }, {
    key: '_createContext',
    value: function _createContext(dryad, dryadId, parentId) {
      var rootContext = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      var cc = (0, _assign2.default)({ id: dryadId }, rootContext, dryad.initialContext());
      if (parentId) {
        var parent = this.dryads[parentId];
        // In the case of a Properties at the top level, there is no existing parent although there was a parentId of '0'
        // passed in.
        var parentContext = this.contexts[parentId];
        if (parentContext) {
          var childContext = parent.childContext(parentContext);
          return (0, _create2.default)(parentContext, (0, _assign2.default)(childContext, cc));
        }
      }
      return cc;
    }

    /**
     * Creates the expanded play graph as a tree of TreeNodes.
     *
     * It is called initially with the root Dryad, then recursively for each child down the tree.
     *
     * - Generates ids for each Dryad
     * - Creates a context for each, storing in this.contexts
     *
     * Each node in the tree contains a TreeNode
     *
     * Dryad classes may use requireParent() and subgraph() to replace themselves
     * with a different graph.
     *
     * So this tree is not a direct mapping of the input graph, it is the expanded play graph.
     *
     * This method calls itself recursively for children.
     *
     * @param {Dryad} dryad
     * @param {String} parentId
     * @param {Integer} childIndex
     * @param {Object} memo - for internal usage during recursion
     * @returns {Object}
     */

  }, {
    key: '_makeTree',
    value: function _makeTree(dryad, parentId) {
      var _this5 = this;

      var childIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
      var memo = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!dryad.isDryad) {
        throw new Error('Not a Dryad: ${dryad}');
      }

      // Copy seenTypes, pass it to your children
      // Each branch sees a different descendent list
      memo.seenTypes = memo.seenTypes ? memo.seenTypes.slice() : [];

      if (memo.skipRequireParentOf === dryad) {
        delete memo.skipRequireParentOf;
      } else {
        var rq = dryad.requireParent();
        if (rq) {
          if (!(0, _find2.default)(memo.seenTypes, function (st) {
            return st === rq;
          })) {
            // fetch the parent class from dryadTypes registery by name
            if (!this.getClass) {
              throw new Error('A getClass lookup was not provided to DryadTree and ' + dryad.constructor.name + ' needs one for requireParent()');
            }
            var requiredParent = new (this.getClass(rq))({}, [dryad]);
            memo.skipRequireParentOf = dryad;
            return this._makeTree(requiredParent, parentId, childIndex, memo);
          }
        }
      }

      var id = parentId ? parentId + '.' + childIndex : '0';

      // If any properties are Dryads then clone them into a Properties
      // dryad with this dryad as it's downstream child. This puts them
      // higher up in the play graph.
      var propertiesDryad = (0, _Properties.invertDryadicProperties)(dryad);
      if (propertiesDryad) {
        return this._makeTree(propertiesDryad, parentId, childIndex + '.props', memo);
      }

      var context = this._createContext(dryad, id, parentId, this.rootContext);
      this.dryads[id] = dryad;
      this.contexts[id] = context;

      var makeSubgraph = function makeSubgraph(dr) {
        var subgraph = dr.subgraph();
        if (subgraph) {
          var subMemo = (0, _clone2.default)(memo);
          // When and if this dryad appears in its own subgraph
          // then do not call subgraph() on that. It will just
          // do prepare/add/remove on its own self.
          subMemo.skipSubgraphOf = dryad;
          // if its an array then should have been supplied in a Branch
          if (Array.isArray(subgraph)) {
            throw new Error('Dryad subgraph should return a single Dryad with children. ${dr} ${subgraph}');
          }

          return _this5._makeTree(subgraph, id, 'subgraph', subMemo);
        }
      };

      if (memo.skipSubgraphOf) {
        if (memo.skipSubgraphOf === dryad) {
          // may still be subgraph children to come
          delete memo.skipSubgraphOf;
        } else {
          var subgraph = makeSubgraph(dryad);
          if (subgraph) {
            return subgraph;
          }
        }
      } else {
        var _subgraph = makeSubgraph(dryad);
        if (_subgraph) {
          return _subgraph;
        }
      }

      var dryadType = dryad.constructor.name;
      memo.seenTypes.push(dryadType);

      return new TreeNode(id, dryad, dryadType, dryad.children.map(function (child, i) {
        return _this5._makeTree(child, id, i, memo);
      }));
    }
  }]);

  return DryadTree;
}();

exports.default = DryadTree;

var TreeNode = function TreeNode(id, dryad, dryadType, children) {
  _classCallCheck(this, TreeNode);

  this.id = id;
  this.dryad = dryad;
  this.dryadType = dryadType;
  this.children = children;
};
//# sourceMappingURL=DryadTree.js.map